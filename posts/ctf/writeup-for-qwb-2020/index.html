<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Writeup for 强网杯 2020 | Slightwind</title>
<meta name="keywords" content="Crypto, CRT, RSA">
<meta name="description" content="Writeup for 强网杯 2020 强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered
然后看到里面提到可以这样获取 $p$：
$$ \large gcd(m^{c_1}-Sig^e,N)=p $$
这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。
from Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n//p flag = &quot;flag{&quot; &#43; sha1(long_to_bytes(p if p &lt; q else q)).">
<meta name="author" content="Slightwind">
<link rel="canonical" href="https://slightwind.cn/posts/ctf/writeup-for-qwb-2020/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.62636b85483d682266e137b11d6183ecf8085a8d4f979b41001cc50ed5245b55.css" integrity="sha256-YmNrhUg9aCJm4TexHWGD7PgIWo1Pl5tBABzFDtUkW1U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://slightwind.cn/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://slightwind.cn/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://slightwind.cn/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://slightwind.cn/apple-touch-icon.png">
<link rel="mask-icon" href="https://slightwind.cn/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: #282c34;
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: false},
                {left: "\\begin{equation}", right: "\\end{equation}", display: true},
                {left: "\\begin{align}", right: "\\end{align}", display: true},
                {left: "\\begin{aligned}", right: "\\end{aligned}", display: true},
                {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
                {left: "\\begin{gather}", right: "\\end{gather}", display: true},
                {left: "\\begin{CD}", right: "\\end{CD}", display: true},
                {left: "\\[", right: "\\]", display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/atom-one-dark.min.css" integrity="sha512-Fcqyubi5qOvl+yCwSJ+r7lli+CO1eHXMaugsZrnxuU4DVpLYWXTVoHy55+mCb4VZpMgy7PBhV7IiymC0yu9tkQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<meta property="og:title" content="Writeup for 强网杯 2020" />
<meta property="og:description" content="Writeup for 强网杯 2020 强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered
然后看到里面提到可以这样获取 $p$：
$$ \large gcd(m^{c_1}-Sig^e,N)=p $$
这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。
from Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n//p flag = &quot;flag{&quot; &#43; sha1(long_to_bytes(p if p &lt; q else q))." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://slightwind.cn/posts/ctf/writeup-for-qwb-2020/" /><meta property="og:image" content="https://slightwind.cn/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-24T16:23:55+00:00" />
<meta property="article:modified_time" content="2020-08-24T16:23:55+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://slightwind.cn/papermod-cover.png"/>

<meta name="twitter:title" content="Writeup for 强网杯 2020"/>
<meta name="twitter:description" content="Writeup for 强网杯 2020 强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered
然后看到里面提到可以这样获取 $p$：
$$ \large gcd(m^{c_1}-Sig^e,N)=p $$
这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。
from Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n//p flag = &quot;flag{&quot; &#43; sha1(long_to_bytes(p if p &lt; q else q))."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://slightwind.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Writeup for 强网杯 2020",
      "item": "https://slightwind.cn/posts/ctf/writeup-for-qwb-2020/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Writeup for 强网杯 2020",
  "name": "Writeup for 强网杯 2020",
  "description": "Writeup for 强网杯 2020 强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered\n然后看到里面提到可以这样获取 $p$：\n$$ \\large gcd(m^{c_1}-Sig^e,N)=p $$\n这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。\nfrom Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n//p flag = \u0026quot;flag{\u0026quot; + sha1(long_to_bytes(p if p \u0026lt; q else q)).",
  "keywords": [
    "Crypto", "CRT", "RSA"
  ],
  "articleBody": "Writeup for 强网杯 2020 强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered\n然后看到里面提到可以这样获取 $p$：\n$$ \\large gcd(m^{c_1}-Sig^e,N)=p $$\n这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。\nfrom Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n//p flag = \"flag{\" + sha1(long_to_bytes(p if p \u003c q else q)).hexdigest() + \"}\" print(flag) # flag{601cb6f6d990ed5b89cf0de60508a95c07543793} bank proof_of_work:\nfrom hashlib import sha256 from string import digits, ascii_letters from pwn import * r = remote(\"39.101.134.52\", \"8005\") def proof_of_work(): rev = r.recvuntil(\"sha256(XXX+\") suffix = r.recv(17).decode() rev = r.recvuntil(\" == \") tar = r.recv(64).decode() def f(x): hashresult = sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, digits + ascii_letters, 3, 'upto') r.recvuntil(\"Give me XXX:\") r.sendline(prefix) def send_teamtoken(): r.recvuntil(\"teamtoken:\") r.sendline(\"icqc487d794f00cdb22409bd5ea7e736\") proof_of_work() send_teamtoken() r.interactive() 连上去过完 proof of work，输入一个字符串作为名字，会给出余额和菜单：\nyour cash:10 you can choose: transact, view records, provide a record, get flag, hint\n试了一下发现可以向某个商人交易，例如 Alice 1 向 Alice 支付，然后会通过 hint 里面的函数生成这次交易的记录，同时我们也可以给他发送一条记录来伪造一次交易。有了足够的余额（1000）就可以买 flag 了。\n但是，出题人好像没滤交易时的负数？然后….\n可以交易负金额可还行，就拿到了 flag。。。\nWeb dice2cry 题目描述：web+cry，输入team_token进入一个掷骰子的页面，在cookie可以看到encrypto_flag，public_n，public_e，应该是 RSA，然后每次掷骰子都会向abi.php get一次数据，abi.php也可以单独调用，相当于于一个随机返回 0～2 整数的 api，以 json 的形式返回值。然后有 js 来操作一下返回 1～6 的点数。\n然后可以在 http://106.14.66.189/abi.php.bak 拿到 abi.php 的源码：\n\u003c?php session_start(); header(\"Content-type:text/html;charset=utf-8\"); $data = json_decode($json_string, true); $rand_number = isset($_POST['this_is.able']) ? $_POST['this_is.able'] : mt_ rand(); $n = gmp_init($data['n']); $d = gmp_init($data['d']); $c = gmp_init($rand_number); $m = gmp_powm($c,$d,$n); $v3 = gmp_init('3'); $r = gmp_mod($m,$v3); $result=(int)gmp_strval($r); $dice = array(\"num\"=\u003e$result); $json_obj = json_encode($dice); echo $json_obj; ?\u003e 如果没有 post 一个数字，$rand_number 就是随机的，否则就是 post 的那个数字，所以 $rand_number 是可控的。\n然后服务端会通过私钥 d 对 $rand_number 解密，并返回解密后模 3 的值，也就是一开始看到的 0～2 的“随机数”，所以这题显然是选择密文攻击，CTF wiki 上有关于 RSA parity oracle 原理的详细介绍，和这一题唯一的区别是 CTF wiki 上的是模 2。\n我们可以类比 CTF wiki 上的推理来对这题模三情况的推理，最终的思想是一样的，不断缩小上下界的范围逼近正确值。\nupper 和 lower 的初始值分别为 n 和 0，这是明文的范围。还要知道这一题的 n 模 3 得 2。\n第 $i$ 次，明文P的范围是：\n$$ \\frac { x N } { 3 ^ { i } } \\leq P \u003c \\frac { x N + N } { 3 ^ { i } }.\\ \\ (\\ 1\\ ) $$\n第 $i+1$ 次，明文P的范围是：\n$$ \\frac { k N } { 3 ^ { i+1 } } \\leq P \u003c \\frac { k N + N } { 3 ^ { i+1 } }.\\ \\ (\\ 2\\ ) $$\n对于不同的返回值（0～2），可以体现出 $k$ 模 3 后的特征（0～2）：\n$$ \\begin{cases} k=3y, \u0026if\u0026\\ k\\ \\equiv 0\\ (mod\\ 3),y\\in N^* \\\\ k=3y+1, \u0026if\u0026\\ k\\ \\equiv 1\\ (mod\\ 3),y\\in N^* \\\\ k=3y+2, \u0026if\u0026\\ k\\ \\equiv 2\\ (mod\\ 3),y\\in N^* \\end{cases} $$\n将不等式（1）分子分母同时乘 3，第 $i$ 次的：\n$$ \\frac { 3x N } { 3 ^ { i+1 } } \\leq P \u003c \\frac { 3x N + 3N } { 3 ^ { i+1 } }.\\ \\ (\\ 3\\ ) $$\n如果返回 0，将 $k = 3y$ 带入 (2) 得：\n$$ \\frac { 3y N } { 3 ^ { i+1 } } \\leq P \u003c \\frac { 3y N + N } { 3 ^ { i+1 } }.\\ \\ (\\ 4\\ ) $$\n由于P一定存在，所以（3）和（4）存在交集，所以 y = x，那么只需要更新上界“upper”：\nupper = (2*lower+upper)//3 如果返回 1，将 $k = 3y + 1$ 带入（2），\n$$ \\frac { 3y N+N } { 3 ^ { i+1 } } \\leq P \u003c \\frac { 3y N + 2N } { 3 ^ { i+1 } }.\\ \\ (\\ 5\\ ) $$\n由于P一定存在，所以（3）和（5）存在交集，所以 $y = x$，那么需要同时更新上界和下界：\nupper = (lower+2*upper)//3; lower = (2*lower+upper)//3 如果返回 2，将 $k = 3y + 2$ 带入（2），\n$$ \\frac { 3y N +2N} { 3 ^ { i+1 } } \\leq P \u003c \\frac { 3y N + 3N } { 3 ^ { i+1 } }.\\ \\ (\\ 6\\ ) $$\n由于P一定存在，所以（3）和（6）存在交集，所以 $y = x$，那么只需要更新下界“lower”：\nlower = (lower+2*upper)//3 这样每一次范围的更新都会缩小范围，最终逼近明文m。\nimport requests from Crypto.Util.number import* PHPSESSID = \"jpa80o0gbpi4djabq80iopu7st\" c = 47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274 n = 0x8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157 e = 0x10001 head = { 'User-Agent': \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\" } cookies = {\"PHPSESSID\": \"jpa80o0gbpi4djabq80iopu7st\", \"public_n\": \"8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157\", \"public_e\": \"010001\", \"encrypto_flag\": \"47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274\"} r = requests.post(\"http://106.14.66.189/main.php\", cookies=cookies, headers=head) def getNum(new_c): r = requests.post(\"http://106.14.66.189/abi.php\", data={'this[is.able': new_c}, cookies=cookies, headers=head) print(r.text) return int(r.text[7]) upper = n lower = 0 i = 1 while True: # n%3==2 power = pow(3, i, n) new_c = (pow(power, e, n)*c) % n # pow(3^{i}*m,e,n) rev = getNum(new_c) if rev == 0: # power*m mod n == 0 upper = (2*lower+upper)//3 elif rev == 1: # power*m mod n == (1 or 2) temp = upper upper = (lower+2*upper)//3 lower = (2*lower+temp)//3 else: lower = (lower+2*upper)//3 if (upper-lower) \u003c 2: break i += 1 print(long_to_bytes(upper)) Crypto modestudy from Crypto.Util.number import * from string import digits, ascii_letters from binascii import unhexlify from hashlib import sha256 from pwn import * import os r = remote(\"139.224.254.172\", \"7777\") def proof_of_work(): # 多线程爆破 rev = r.recvuntil(\"sha256(\") suffix = r.recvuntil(\"+\")[:-1].decode() rev = r.recvuntil(\"?=\") def f(x): hashresult = hashlib.sha256(suffix.encode()+x.encode()).digest() bits = ''.join(bin(j)[2:].zfill(8) for j in hashresult) return bits.startswith('0'*5) prefix = util.iters.mbruteforce(f, digits + ascii_letters, 8, 'upto') r.sendline(prefix) def challenge1(): r.recvuntil(\"your choice:\") r.sendline(\"1\") r.recvuntil(\"session=\") session = r.recv(16) r.recvuntil(\"checksum=\") checksum = r.recv(64) r.recvuntil(\"cookie:\") plain = \"session={};admin=0\".format(session) bit = ((unhexlify(checksum)[15]) ^ ord('0') ^ ord('1')) checksum = checksum.decode() checksum_final = checksum[:30] + hex(bit)[2:] + checksum[32:] newcookie = \"session={};admin=1;checksum={}\".format( session.decode(), checksum_final) r.sendline(newcookie) def challenge2(): r.recvuntil(\"your choice:\") r.sendline(\"2\") r.recvuntil(\"sha256(iv)=\") sha_iv = r.recv(64).decode() r.recvuntil(\"your choice:\") r.sendline(\"1\") r.sendline(\"A\"*32) r.recvuntil(\"[+] \") plain = r.recvuntil(\"\\n\")[:-1] m0 = bytes.fromhex(plain[:32].decode()) m1 = bytes.fromhex(plain[32:].decode()) iv = long_to_bytes(bytes_to_long(m0) ^ bytes_to_long(m1) ^ bytes_to_long(b\"A\"*16)) r.recvuntil(\"your choice:\") r.sendline(\"2\") assert sha256(iv).hexdigest() == sha_iv r.sendline(iv.hex()) def challenge3(): r.recvuntil(\"your choice:\") r.sendline(\"3\") r.recvuntil(\"128bit_ecb_encrypt(cookie):\") cipher = r.recvuntil(\"\\n\")[:-1].decode() cipher = bytearray.fromhex(cipher) for i in range(16): cipher[32 + i] = cipher[64 + i] r.sendline(cipher.hex()) def challenge4(): r.recvuntil(\"your choice:\") r.sendline(\"4\") r.recvuntil(\"sha256(secret)=\") sha_secret = r.recv(64).decode() secret = b\"\" for Byte in range(16): byte_len = (15 - (Byte % 16)) if ((Byte % 16) != 15) else 16 bound = ((byte_len + Byte + 1) // 16) * 32 r.recvuntil(\"your choice:\") r.sendline(\"1\") r.recvuntil(\"input(encode hex):\") r_ = os.urandom(byte_len) r.sendline(r_.hex()) r.recvuntil(\"encrypted msg: \") C_ = r.recvuntil(\"\\n\")[:-1].decode() print(\"brute force {} byte\".format(Byte+1)) for i in range(256): r.recvuntil(\"your choice:\") r.sendline(\"1\") r.recvuntil(\"input(encode hex):\") Pi = int((r_.hex()+secret.hex())[-30:]+long_to_bytes(i).hex(), 16) r.sendline(long_to_bytes(Pi).hex()) r.recvuntil(\"encrypted msg: \") Ci = r.recvuntil(\"\\n\")[:-1].decode() if Ci[:32] == C_[bound-32:bound]: secret += long_to_bytes(i) print(\"Current secret: {}\".format(secret)) break r.recvuntil(\"your choice:\") r.sendline(\"2\") r.recvuntil(\"secret(encode hex):\") r.sendline(secret.hex()) def challenge5(): r.recvuntil(\"your choice:\") r.sendline(\"5\") r.recvuntil(\"sha256(secret)=\") sha_secret = r.recv(64).decode() r.recvuntil(\"(secret).encode(\\\"hex\\\")=\") c = r.recv(32) secret = \"\" for i in range(8): part_c = c[i*4:i*4+4] guess = \"\" for j in range(0xffff): temp = \"0\"*(4-len(hex(j)[2:]))+hex(j)[2:] guess += temp if len(guess) == 1024: # 由于向服务端发送接收时间成本较高，所以一次发送1024bits加快爆破速度 r.recvuntil(\"your choice:\") r.sendline(\"1\") r.recvuntil(\"input(encode hex):\") r.sendline(guess) r.recvuntil(\"encode(\\\"hex\\\"):\") temp_c = r.recv(1024) flag = False for k in range(256): if temp_c[k*4:k*4+4] == part_c: secret += guess[k*4:k*4+4] flag = True break if flag: break guess = \"\" print(\"Current secret:\", secret) r.recvuntil(\"your choice:\") r.sendline(\"2\") r.recvuntil(\"secret(encode hex):\") r.sendline(secret) def challenge6(): r.recvuntil(\"your choice:\") r.sendline(\"6\") r.recvuntil(\"iv+aes128_cbc(key,iv,padding(secret)):\") iv_cbc = r.recvuntil(\"\\n\")[:-1].decode() iv = bytearray.fromhex(iv_cbc[:32]) cbc = bytearray.fromhex(iv_cbc[32:64]) mid = [] new_iv = bytearray(b'\\x00' * 16) count = 1 for i in range(16): for j in range(256): new_iv[15 - i] = j upload = new_iv + cbc r.sendline('1') r.recvuntil(\"input your iv+c (encode hex):\") r.sendline(upload.hex()) search = r.recvuntil(\"your choice:\") if b\"success\" in search: print(search) ans = j ^ count break count += 1 mid.append(ans) for m in range(15 - i, 16): new_iv[m] = count ^ mid[15 - m] find = \"\" for i in range(16): find += hex(iv[i] ^ mid[15 - i])[2:].rjust(2, '0') r.sendline('2') r.recvuntil(\"secret(encode hex):\") r.sendline(find) proof_of_work() r.recvuntil(\"teamtoken=\") r.sendline(\"icqc487d794f00cdb22409bd5ea7e736\") challenge1() challenge2() challenge3() challenge4() challenge5() challenge6() r.interactive() # 这边再输入7得到flag # icqc487d794f00cdb22409bd5ea7e736 # flag{86ac04cc901a04462c55923eedf5affe} ",
  "wordCount" : "1197",
  "inLanguage": "en",
  "datePublished": "2020-08-24T16:23:55Z",
  "dateModified": "2020-08-24T16:23:55Z",
  "author":{
    "@type": "Person",
    "name": "Slightwind"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://slightwind.cn/posts/ctf/writeup-for-qwb-2020/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Slightwind",
    "logo": {
      "@type": "ImageObject",
      "url": "https://slightwind.cn/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://slightwind.cn/" accesskey="h" title="Slightwind (Alt + H)">Slightwind</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://slightwind.cn/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://slightwind.cn/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://slightwind.cn/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://slightwind.cn/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://slightwind.cn/">Home</a>&nbsp;»&nbsp;<a href="https://slightwind.cn/posts/">Posts</a></div>
    <h1 class="post-title">
      Writeup for 强网杯 2020
    </h1>
    <div class="post-meta"><span title='2020-08-24 16:23:55 +0000 UTC'>August 24, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Slightwind

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#writeup-for-%e5%bc%ba%e7%bd%91%e6%9d%af-2020" aria-label="Writeup for 强网杯 2020">Writeup for 强网杯 2020</a><ul>
                        
                <li>
                    <a href="#%e5%bc%ba%e7%bd%91%e5%85%88%e9%94%8b" aria-label="强网先锋">强网先锋</a><ul>
                        
                <li>
                    <a href="#baby_crt" aria-label="baby_crt">baby_crt</a></li>
                <li>
                    <a href="#bank" aria-label="bank">bank</a></li></ul>
                </li>
                <li>
                    <a href="#web" aria-label="Web">Web</a><ul>
                        
                <li>
                    <a href="#dice2cry" aria-label="dice2cry">dice2cry</a></li></ul>
                </li>
                <li>
                    <a href="#crypto" aria-label="Crypto">Crypto</a><ul>
                        
                <li>
                    <a href="#modestudy" aria-label="modestudy">modestudy</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="writeup-for-强网杯-2020">Writeup for 强网杯 2020<a hidden class="anchor" aria-hidden="true" href="#writeup-for-强网杯-2020">#</a></h1>
<h2 id="强网先锋">强网先锋<a hidden class="anchor" aria-hidden="true" href="#强网先锋">#</a></h2>
<h3 id="baby_crt">baby_crt<a hidden class="anchor" aria-hidden="true" href="#baby_crt">#</a></h3>
<p>考点是 CRT-RSA，找到一篇paper：<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.510.3146&amp;rep=rep1&amp;type=pdf">Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered</a></p>
<p>然后看到里面提到可以这样获取 $p$：</p>
<p>$$
\large gcd(m^{c_1}-Sig^e,N)=p
$$</p>
<p>这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。</p>
<pre><code class="language-python">from Crypto.Util.number import *
from hashlib import sha1

e = 65537
n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997
m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540
sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246

for c1 in range(1, 65536):
    p = GCD(pow(m, c1, n) - pow(sig, e, n), n)
    if p == 1:
        continue
    print(p)
    break

q = n//p
flag = &quot;flag{&quot; + sha1(long_to_bytes(p if p &lt; q else q)).hexdigest() + &quot;}&quot;
print(flag)
# flag{601cb6f6d990ed5b89cf0de60508a95c07543793}
</code></pre>
<h3 id="bank">bank<a hidden class="anchor" aria-hidden="true" href="#bank">#</a></h3>
<p>proof_of_work:</p>
<pre><code class="language-python">from hashlib import sha256
from string import digits, ascii_letters
from pwn import *

r = remote(&quot;39.101.134.52&quot;, &quot;8005&quot;)

def proof_of_work():
    rev = r.recvuntil(&quot;sha256(XXX+&quot;)
    suffix = r.recv(17).decode()
    rev = r.recvuntil(&quot; == &quot;)
    tar = r.recv(64).decode()

    def f(x):
        hashresult = sha256(x.encode()+suffix.encode()).hexdigest()
        return hashresult == tar
    prefix = util.iters.mbruteforce(f, digits + ascii_letters, 3, 'upto')
    r.recvuntil(&quot;Give me XXX:&quot;)
    r.sendline(prefix)


def send_teamtoken():
    r.recvuntil(&quot;teamtoken:&quot;)
    r.sendline(&quot;icqc487d794f00cdb22409bd5ea7e736&quot;)


proof_of_work()
send_teamtoken()
r.interactive()
</code></pre>
<p>连上去过完 proof of work，输入一个字符串作为名字，会给出余额和菜单：</p>
<blockquote>
<p>your cash:10
you can choose: transact, view records, provide a record, get flag, hint</p>
</blockquote>
<p>试了一下发现可以向某个商人交易，例如 Alice 1 向 Alice 支付，然后会通过 hint 里面的函数生成这次交易的记录，同时我们也可以给他发送一条记录来伪造一次交易。有了足够的余额（1000）就可以买 flag 了。</p>
<p>但是，出题人好像没滤交易时的负数？然后&hellip;.</p>
<p>可以交易负金额可还行，就拿到了 flag。。。</p>
<h2 id="web">Web<a hidden class="anchor" aria-hidden="true" href="#web">#</a></h2>
<h3 id="dice2cry">dice2cry<a hidden class="anchor" aria-hidden="true" href="#dice2cry">#</a></h3>
<p>题目描述：web+cry，输入<code>team_token</code>进入一个掷骰子的页面，在<code>cookie</code>可以看到<code>encrypto_flag</code>，<code>public_n</code>，<code>public_e</code>，应该是 RSA，然后每次掷骰子都会向<code>abi.php</code> get一次数据，<code>abi.php</code>也可以单独调用，相当于于一个随机返回 0～2 整数的 api，以 json 的形式返回值。然后有 js 来操作一下返回 1～6 的点数。</p>
<p>然后可以在 <em>http://106.14.66.189/abi.php.bak</em> 拿到 <code>abi.php</code> 的源码：</p>
<pre><code class="language-php">&lt;?php
session_start();
header(&quot;Content-type:text/html;charset=utf-8&quot;);

        $data = json_decode($json_string, true);

        $rand_number = isset($_POST['this_is.able']) ? $_POST['this_is.able'] : mt_      rand();
        $n = gmp_init($data['n']);
        $d = gmp_init($data['d']);
        $c = gmp_init($rand_number);
        $m = gmp_powm($c,$d,$n);
        $v3 = gmp_init('3');
        $r = gmp_mod($m,$v3);
        $result=(int)gmp_strval($r);
        $dice = array(&quot;num&quot;=&gt;$result);
        $json_obj = json_encode($dice);
        echo $json_obj;
?&gt;
</code></pre>
<p>如果没有 post 一个数字，<code>$rand_number</code> 就是随机的，否则就是 post 的那个数字，所以 <code>$rand_number</code> 是可控的。</p>
<p>然后服务端会通过私钥 d 对 <code>$rand_number</code> 解密，并返回解密后模 3 的值，也就是一开始看到的 0～2 的“随机数”，所以这题显然是选择密文攻击，CTF wiki 上有关于 RSA parity oracle 原理的详细介绍，和这一题唯一的区别是 CTF wiki 上的是模 2。</p>
<p>我们可以类比 CTF wiki 上的推理来对这题模三情况的推理，最终的思想是一样的，不断缩小上下界的范围逼近正确值。</p>
<p><code>upper</code> 和 <code>lower</code> 的初始值分别为 n 和 0，这是明文的范围。还要知道这一题的 n 模 3 得 2。</p>
<p>第 $i$ 次，明文P的范围是：</p>
<p>$$
\frac { x N } { 3 ^ { i } } \leq P &lt; \frac { x N + N } { 3 ^ { i } }.\ \ (\ 1\ )
$$</p>
<p>第 $i+1$ 次，明文P的范围是：</p>
<p>$$
\frac { k N } { 3 ^ { i+1 } } \leq P &lt; \frac { k N + N } { 3 ^ { i+1 } }.\ \ (\ 2\ )
$$</p>
<p>对于不同的返回值（0～2），可以体现出 $k$ 模 3 后的特征（0～2）：</p>
<p>$$
\begin{cases}
k=3y,   &amp;if&amp;\ k\ \equiv 0\ (mod\ 3),y\in N^* \\
k=3y+1, &amp;if&amp;\ k\ \equiv 1\ (mod\ 3),y\in N^* \\
k=3y+2, &amp;if&amp;\ k\ \equiv 2\ (mod\ 3),y\in N^*
\end{cases}
$$</p>
<p>将不等式（1）分子分母同时乘 3，第 $i$ 次的：</p>
<p>$$
\frac { 3x N } { 3 ^ { i+1 } } \leq P &lt; \frac { 3x N + 3N } { 3 ^ { i+1 } }.\ \ (\ 3\ )
$$</p>
<p>如果返回 0，将 $k = 3y$ 带入 (2) 得：</p>
<p>$$
\frac { 3y N } { 3 ^ { i+1 } } \leq P &lt; \frac { 3y N + N } { 3 ^ { i+1 } }.\ \ (\ 4\ )
$$</p>
<p>由于P一定存在，所以（3）和（4）存在交集，所以 y = x，那么只需要更新上界“upper”：</p>
<pre><code>upper = (2*lower+upper)//3
</code></pre>
<p>如果返回 1，将 $k = 3y + 1$ 带入（2），</p>
<p>$$
\frac { 3y N+N } { 3 ^ { i+1 } } \leq P &lt; \frac { 3y N + 2N } { 3 ^ { i+1 } }.\ \ (\ 5\ )
$$</p>
<p>由于P一定存在，所以（3）和（5）存在交集，所以 $y = x$，那么需要同时更新上界和下界：</p>
<pre><code>upper = (lower+2*upper)//3; lower = (2*lower+upper)//3
</code></pre>
<p>如果返回 2，将 $k = 3y + 2$ 带入（2），</p>
<p>$$
\frac { 3y N +2N} { 3 ^ { i+1 } } \leq P &lt; \frac { 3y N + 3N } { 3 ^ { i+1 } }.\ \ (\ 6\ )
$$</p>
<p>由于P一定存在，所以（3）和（6）存在交集，所以 $y = x$，那么只需要更新下界“lower”：</p>
<pre><code>lower = (lower+2*upper)//3
</code></pre>
<p>这样每一次范围的更新都会缩小范围，最终逼近明文m。</p>
<pre><code class="language-python">import requests
from Crypto.Util.number import*
PHPSESSID = &quot;jpa80o0gbpi4djabq80iopu7st&quot;
c = 47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274
n = 0x8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157
e = 0x10001
head = {
    'User-Agent': &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36&quot;
}
cookies = {&quot;PHPSESSID&quot;: &quot;jpa80o0gbpi4djabq80iopu7st&quot;, &quot;public_n&quot;: &quot;8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157&quot;, &quot;public_e&quot;: &quot;010001&quot;,
           &quot;encrypto_flag&quot;: &quot;47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274&quot;}
r = requests.post(&quot;http://106.14.66.189/main.php&quot;,
                  cookies=cookies, headers=head)


def getNum(new_c):
    r = requests.post(&quot;http://106.14.66.189/abi.php&quot;,
                      data={'this[is.able': new_c}, cookies=cookies, headers=head)
    print(r.text)
    return int(r.text[7])


upper = n
lower = 0
i = 1
while True:  # n%3==2
    power = pow(3, i, n)
    new_c = (pow(power, e, n)*c) % n  # pow(3^{i}*m,e,n)
    rev = getNum(new_c)
    if rev == 0:  # power*m mod n == 0
        upper = (2*lower+upper)//3
    elif rev == 1:  # power*m mod n == (1 or 2)
        temp = upper
        upper = (lower+2*upper)//3
        lower = (2*lower+temp)//3
    else:
        lower = (lower+2*upper)//3
    if (upper-lower) &lt; 2:
        break
    i += 1

print(long_to_bytes(upper))
</code></pre>
<h2 id="crypto">Crypto<a hidden class="anchor" aria-hidden="true" href="#crypto">#</a></h2>
<h3 id="modestudy">modestudy<a hidden class="anchor" aria-hidden="true" href="#modestudy">#</a></h3>
<pre><code class="language-python">from Crypto.Util.number import *
from string import digits, ascii_letters
from binascii import unhexlify
from hashlib import sha256
from pwn import *
import os


r = remote(&quot;139.224.254.172&quot;, &quot;7777&quot;)


def proof_of_work():  # 多线程爆破
    rev = r.recvuntil(&quot;sha256(&quot;)
    suffix = r.recvuntil(&quot;+&quot;)[:-1].decode()
    rev = r.recvuntil(&quot;?=&quot;)
    def f(x):
        hashresult = hashlib.sha256(suffix.encode()+x.encode()).digest()
        bits = ''.join(bin(j)[2:].zfill(8) for j in hashresult)
        return bits.startswith('0'*5)
    prefix = util.iters.mbruteforce(f, digits + ascii_letters, 8, 'upto')
    r.sendline(prefix)


def challenge1():
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;1&quot;)
    r.recvuntil(&quot;session=&quot;)
    session = r.recv(16)
    r.recvuntil(&quot;checksum=&quot;)
    checksum = r.recv(64)
    r.recvuntil(&quot;cookie:&quot;)
    plain = &quot;session={};admin=0&quot;.format(session)
    bit = ((unhexlify(checksum)[15]) ^ ord('0') ^ ord('1'))
    checksum = checksum.decode()
    checksum_final = checksum[:30] + hex(bit)[2:] + checksum[32:]
    newcookie = &quot;session={};admin=1;checksum={}&quot;.format(
        session.decode(), checksum_final)
    r.sendline(newcookie)


def challenge2():
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;sha256(iv)=&quot;)
    sha_iv = r.recv(64).decode()
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;1&quot;)
    r.sendline(&quot;A&quot;*32)
    r.recvuntil(&quot;[+] &quot;)
    plain = r.recvuntil(&quot;\n&quot;)[:-1]
    m0 = bytes.fromhex(plain[:32].decode())
    m1 = bytes.fromhex(plain[32:].decode())
    iv = long_to_bytes(bytes_to_long(m0) ^ bytes_to_long(m1) ^ bytes_to_long(b&quot;A&quot;*16))
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;2&quot;)
    assert sha256(iv).hexdigest() == sha_iv
    r.sendline(iv.hex())


def challenge3():
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;128bit_ecb_encrypt(cookie):&quot;)
    cipher = r.recvuntil(&quot;\n&quot;)[:-1].decode()
    cipher = bytearray.fromhex(cipher)
    for i in range(16):
        cipher[32 + i] = cipher[64 + i]
    r.sendline(cipher.hex())


def challenge4():
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;4&quot;)
    r.recvuntil(&quot;sha256(secret)=&quot;)
    sha_secret = r.recv(64).decode()
    secret = b&quot;&quot;
    for Byte in range(16):
        byte_len = (15 - (Byte % 16)) if ((Byte % 16) != 15) else 16
        bound = ((byte_len + Byte + 1) // 16) * 32
        r.recvuntil(&quot;your choice:&quot;)
        r.sendline(&quot;1&quot;)
        r.recvuntil(&quot;input(encode hex):&quot;)
        r_ = os.urandom(byte_len)
        r.sendline(r_.hex())
        r.recvuntil(&quot;encrypted msg: &quot;)
        C_ = r.recvuntil(&quot;\n&quot;)[:-1].decode()
        print(&quot;brute force {} byte&quot;.format(Byte+1))
        for i in range(256):
            r.recvuntil(&quot;your choice:&quot;)
            r.sendline(&quot;1&quot;)
            r.recvuntil(&quot;input(encode hex):&quot;)
            Pi = int((r_.hex()+secret.hex())[-30:]+long_to_bytes(i).hex(), 16)
            r.sendline(long_to_bytes(Pi).hex())
            r.recvuntil(&quot;encrypted msg: &quot;)
            Ci = r.recvuntil(&quot;\n&quot;)[:-1].decode()
            if Ci[:32] == C_[bound-32:bound]:
                secret += long_to_bytes(i)
                print(&quot;Current secret: {}&quot;.format(secret))
                break
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;secret(encode hex):&quot;)
    r.sendline(secret.hex())


def challenge5():
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;5&quot;)
    r.recvuntil(&quot;sha256(secret)=&quot;)
    sha_secret = r.recv(64).decode()
    r.recvuntil(&quot;(secret).encode(\&quot;hex\&quot;)=&quot;)
    c = r.recv(32)
    secret = &quot;&quot;
    for i in range(8):
        part_c = c[i*4:i*4+4]
        guess = &quot;&quot;
        for j in range(0xffff):
            temp = &quot;0&quot;*(4-len(hex(j)[2:]))+hex(j)[2:]
            guess += temp
            if len(guess) == 1024: # 由于向服务端发送接收时间成本较高，所以一次发送1024bits加快爆破速度
                r.recvuntil(&quot;your choice:&quot;)
                r.sendline(&quot;1&quot;)
                r.recvuntil(&quot;input(encode hex):&quot;)
                r.sendline(guess)
                r.recvuntil(&quot;encode(\&quot;hex\&quot;):&quot;)
                temp_c = r.recv(1024)
                flag = False
                for k in range(256):
                    if temp_c[k*4:k*4+4] == part_c:
                        secret += guess[k*4:k*4+4]
                        flag = True
                        break
                if flag:
                    break
                guess = &quot;&quot;
        print(&quot;Current secret:&quot;, secret)
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;secret(encode hex):&quot;)
    r.sendline(secret)


def challenge6():
    r.recvuntil(&quot;your choice:&quot;)
    r.sendline(&quot;6&quot;)
    r.recvuntil(&quot;iv+aes128_cbc(key,iv,padding(secret)):&quot;)
    iv_cbc = r.recvuntil(&quot;\n&quot;)[:-1].decode()
    iv = bytearray.fromhex(iv_cbc[:32])
    cbc = bytearray.fromhex(iv_cbc[32:64])
    mid = []
    new_iv = bytearray(b'\x00' * 16)
    count = 1
    for i in range(16):
        for j in range(256):
            new_iv[15 - i] = j
            upload = new_iv + cbc
            r.sendline('1')
            r.recvuntil(&quot;input your iv+c (encode hex):&quot;)
            r.sendline(upload.hex())
            search = r.recvuntil(&quot;your choice:&quot;)
            if b&quot;success&quot; in search:
                print(search)
                ans = j ^ count
                break
        count += 1
        mid.append(ans)
        for m in range(15 - i, 16):
            new_iv[m] = count ^ mid[15 - m]
    find = &quot;&quot;
    for i in range(16):
        find += hex(iv[i] ^ mid[15 - i])[2:].rjust(2, '0')
    r.sendline('2')
    r.recvuntil(&quot;secret(encode hex):&quot;)
    r.sendline(find)


proof_of_work()
r.recvuntil(&quot;teamtoken=&quot;)
r.sendline(&quot;icqc487d794f00cdb22409bd5ea7e736&quot;)

challenge1()
challenge2()
challenge3()
challenge4()
challenge5()
challenge6()
r.interactive()
# 这边再输入7得到flag
# icqc487d794f00cdb22409bd5ea7e736
# flag{86ac04cc901a04462c55923eedf5affe}
</code></pre>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://slightwind.cn/tags/crypto/">Crypto</a></li>
      <li><a href="https://slightwind.cn/tags/crt/">CRT</a></li>
      <li><a href="https://slightwind.cn/tags/rsa/">RSA</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://slightwind.cn/posts/ctf/0xgame-2020-crypto-problems/">
    <span class="title">« Prev</span>
    <br>
    <span>0xGame 2020 Crypto Problems</span>
  </a>
  <a class="next" href="https://slightwind.cn/posts/ctf/writeup-for-crypto-problems-in-wmctf-2020/">
    <span class="title">Next »</span>
    <br>
    <span>Writeup for Crypto problems in WMCTF 2020</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://slightwind.cn/">Slightwind</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
