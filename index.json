[{"content":"Intro to Deep Learning A Single Neuron The Linear Unit 下面是一个neuron（或称unit）的示意图，x是输入；w是x的权重weight；b是bias，是一种特殊的权重，没有和bias相关的输入数据，它可以独立于输入修改输出。神经网络通过修改权重来“learn”。\ny是这个神经元输出的值，$y=wx+b$，刚好是一个直线的方程，w是斜率，b是在y轴上的截距。\nExample - The Linear Unit as a Model 单个神经元是通常只会在更大的网络中发挥作用，单神经元模型是线性模型。当$w=2.5, b=90$时，这个线性模型可以用来反应糖'sugars'和卡路里'calories'的关系：\nMultiple Inputs 对于多个输入，也是这样将每个输入乘以权重，并把它们相加。下面这个对应的公式为：$y=w_{0} x_{0}+w_{1} x_{1}+w_{2} x_{2}+b.$ Linear Units in Keras 在Keras中创建模型最简单的方法是使用keras.Sequential，下面这个示例表示一个线性模型，可以输入3个特征（\u0026lsquo;sugars\u0026rsquo;, \u0026lsquo;fiber\u0026rsquo;, \u0026lsquo;protein\u0026rsquo;），并且只有一个输出：\u0026lsquo;calories\u0026rsquo;。\nfrom tensorflow import keras from tensorflow.keras import layers # Create a network with 1 linear unit model = keras.Sequential([ layers.Dense(units=1, input_shape=[3]) ]) 第一个参数units定义输出的个数，input_shape告诉Keras输入特征的数量。目前只需要用到input_shape=[num_columns]，input_shape还可以支持使用更复杂的数据：[height, width, channels]。\nTensors是TensorFlow版本的numpy数组，并且做了一些使它更适合用于机器学习的改变，Tensors与GPU/TPU加速器兼容，而TPU就是专为Tensors而设计的。在Keras内部，使用Tensors表示神经网络的权重。\nmodel.weights可以用来查看权重，在训练开始前，权重都会被初始化为随机值。\nDeep Neural Networks Layers 神经网络会将神经元组成层（layers），合并有相同的输入的线性神经元，就得到了一个稠密层（dense layer） The Activation Function 两个中间没有其他东西的稠密层，效果并不会比一个稠密层的效果好多少，“稠密层本身不能带我们离开线和面的世界”，我们需要的是非线性（nonlinear），需要激活函数（activation function）。\n激活函数就是应用于每一层输出的函数，最常见的是rectifier函数$max(0,x).$\n把rectifier应用到一个线性单元上时，就得到了rectified linear unit，或简称ReLU。这样这个线性单元的输出就是$max(0,w\\cdot x+b)$\nStacking Dense Layers 堆叠层来获得复杂的数据转换： 输出层之前的层有时被称为隐藏层（hidden），因为我们没有直接看到它们的输出。上图在输出之前使用了一个线性单元，而不是激活函数，这样做使这个模型适用于回归任务，在分类任务中，可能要在这里使用激活函数。\nBuilding Sequential Models 我们将用Sequential模型来连接一系列的层，建立上图的模型，第一次获得输入，最后一层产生输出\nfrom tensorflow import keras from tensorflow.keras import layers model = keras.Sequential([ # ReLU 隐藏层 layers.Dense(units=4, activation='relu', input_shape=[2]), # 输入 layers.Dense(units=3, activation='relu'), # 线性输出层 layers.Dense(units=1), ]) 一定要把所有的图层放在一个列表中，比如[layer，layer，layer，...]。要添加激活函数层，只要设置activation参数即可，比如ReLU：activation='relu'\nStochastic Gradient Descent Introduction 前面两节讲了如何构建全连接的网络（fully-connected networks），新创建的网络中的权重都是随机的，这一节就开始介绍如何训练神经网络。\n训练模型中每条数据需要输入一些特征（features）和一个期望的输出目标（target），训练的过程会调整权重，使网络可以通过输入的特征计算出期望的目标。\n除了训练数据，还需要：\n“损失函数”，用来衡量网络预测结果的好坏。 “优化器”，可以告诉网络如何改变其权重。 The Loss Function 损失函数（loss function）测量target真实值和模型预测值之间的差异。不同的问题需要使用不同的损失函数，比如回归问题（regression problems）常用的损失函数就是平均绝对误差MAE（mean absolute error），MAE通过差的绝对值abs(y_true-y_pred)测量预测值y_pred与真实目标y_true的差异。 数据集上的总MAE，是所有这些差的绝对值的平均值。\n除了MAE之外，回归问题还有其他的损失函数：均方误差（mean-squared error，MSE）或Huber损失（Huber loss），它们都可以在Keras中使用。 在训练期间，模型将使用损失函数作为指导，以找到正确的权重值（loss越小越好）。换句话说，损失函数告诉网络它的目标。\nThe Optimizer - Stochastic Gradient Descent 随机梯度下降，这里的“随机”用的是stochastic，而非random，查了一下维基百科：\nAlthough stochasticity and randomness are distinct in that the former refers to a modeling approach and the latter refers to phenomena themselves, these two terms are often used synonymously. Furthermore, in probability theory, the formal concept of a stochastic process is also referred to as a random process.\nstochastic 偏向指建模方法，random 偏向指现象本身，很多时候这两个词是同义的。\n优化器（optimizer）是一种调整权重来使loss最小化的算法。深度学习中使用的所有优化器算法都属于一个叫做随机梯度下降的家族，训练网络的过程就是一次次迭代下面的算法：\n采集一些训练数据，通过网络进行预测 测量预测值和真实值之间的损失 最后，调整权重使loss更小 使用随机梯度下降的神经网络\n每个迭代的训练数据样本称为一个minibatch（或称batch），而一轮完整的训练数据称为一个epoch。你训练的次数是网络看到每个训练示例的次数。网络看到每个训练示例的次数，就是训练的轮数。\n上面的动画显示了线性模型在使用SGD进行训练，淡红色的点是整个数据集，变化的实心红点表示minibatch，每次SGD看到一个新的minibatch，它都会将权重（w斜率，by轴截距）移向batch的正确值，经过一轮又一轮的batch，直线最终会收敛到最佳状态，可以看到，权重越接近真实值，loss就越小。\nLearning Rate and Batch Size 可以注意到直线每次会在batch的方向上发生一个小的移动，这个移动变化的大小取决于学习率（learning rate），学习率越小，在逼近正确值的过程就越长。\n学习率（Learning Rate）和batch的大小（Batch Size）是对SGD训练进度影响最大的两个参数。它们之间的相互作用往往很微妙，对这些参数的正确选择并不总是显而易见的。（我们将在练习中探讨这些影响）\n幸运的是，对于大多数工作来说，没有必要进行广泛的超参数搜索以获得满意的结果。Adam是一种SGD算法，具有自适应学习率，使其适用于大多数问题，而无需任何参数调整（从某种意义上说，它是“自调整”）。Adam是一个伟大的通用优化器。\nAdding the Loss and Optimizer 定义模型后，可以使用模型的compile方法添加损失函数和优化器：\nmodel.compile( optimizer=\u0026quot;adam\u0026quot;, loss=\u0026quot;mae\u0026quot;, ) 只需要一个字符串就可以指定loss和optimizer；也可以通过Keras API直接访问这些参数——例如想要优化参数——但对我们来说，默认值就可以正常工作。\n梯度（gradient）是一个向量，告诉我们权重应该朝哪个方向移动，也就是说它告诉我们如何改变重量使损失变化最快，我们称过程为梯度下降（descent），是因为它使用梯度将损失曲线下降到最小值，随机（stochastic）是指每次选取的minibatches是从训练数据中随机选取的随机样例。SGD即Stochastic Gradient Descent。\nfrom tensorflow import keras from tensorflow.keras import layers model = keras.Sequential([ layers.Dense(512, activation='relu', input_shape=[11]), layers.Dense(512, activation='relu'), layers.Dense(512, activation='relu'), layers.Dense(1), ]) # 给模型设置优化器和损失函数 model.compile( optimizer='adam', loss='mae', ) # 每轮给模型 256 行数据，这样训练 10 轮 history = model.fit( X_train, y_train, validation_data=(X_valid, y_valid), batch_size=256, epochs=10, ) 在每一轮的训练后，都会输出当前的loss，并且训练过程中的loss都会被保存起来，所以我们可以用它们作图来更直观的看出loss的变化：\nimport pandas as pd # convert the training history to a dataframe history_df = pd.DataFrame(history.history) # use Pandas native plot method history_df['loss'].plot() loss的变化曲线逐渐变得趋于水平了，就说明模型已经学会了它能学会的一切，所以没有必要让它进行更多的迭代，如果想要优化loss，更应该做的是调整模型。\nOverfitting and Underfitting Interpreting the Learning Curves 模型得到的数据是由信息（signal）和噪声（noise）组成的，我们希望它从signal中学习到模式，这样可以使其在预测过程中表现良好，噪声是只在训练数据中正确的案例。\n下图绘制了在训练数据上和在测试数据上的loss情况，这些曲线我们称之为学习曲线（learning curves），为了有效的训练深度学习模型，我们需要能够解释它们。\n在模型学习signal和noise的过程中，训练loss会逐渐下降，但只有模型学习到signal时，验证loss才会降低。在学习signal的过程中，两条曲线都会下降，但是如果模型学习了noise，那么两条曲线之间就会出现空隙（gap），这个空隙的大小，可以反应模型学到了多少noise。理想情况下我们希望模型只学习signal不学习noise，但这几乎是不可能的，只能以学习到很多的noise为代价，让模型尽可能多的学习到signal，从上图可以看出，当出现了某一点后，验证loss会逐渐上升。\n在训练模型时可能会出现两个问题：\nsignal不足或噪声过大。未充分拟合训练集 是指由于模型没有学习到足够的signal，导致loss没有尽可能低。 过度拟合训练集是指由于模型学习了太多的噪声，导致loss没有尽可能低。 训练深度学习模型的诀窍是在两者之间找到最佳平衡，我们将研究几种从训练数据中获取更多signal的方法，同时减少噪声。\nCapacity 模型的容量是指它能够学习的模式的大小和复杂性，对于神经网络来说，这在很大程度上取决于它有多少神经元以及它们如何连接在一起。如果网络似乎不适合数据，应该尝试增加其容量。\n可以通过使网络更宽（将更多神经元添加到现有层）或使其更深（添加更多层）来增加网络的容量。更宽的网络更容易学习更多的线性关系，而更深的网络更喜欢非线性关系。哪个更好取决于数据集。\nmodel = keras.Sequential([ layers.Dense(16, activation='relu'), layers.Dense(1), ]) wider = keras.Sequential([ layers.Dense(32, activation='relu'), layers.Dense(1), ]) deeper = keras.Sequential([ layers.Dense(16, activation='relu'), layers.Dense(16, activation='relu'), layers.Dense(1), ]) Early Stopping 当模型学习到很多噪声时，验证损失可能会在训练期间开始增加，为了防止这种情况，只要验证loss似乎不再减少，我们就可以停止训练。以这种方式中断训练被称为提前停止（Early Stopping）。\n一旦检测到了验证loss再次上升，就可以将权重重置回之前loss最小值的位置，确保了模型不会继续过拟合。\nAdding Early Stopping 在Keras中，我们通过回调（callback）在训练中提前停止，回调函数是一个在网络运行时需要经常运行的函数。提前停止回调将在每个epoch之后运行。（Keras预先定义了各种有用的回调，也可以定义自己的回调。）\nfrom tensorflow.keras.callbacks import EarlyStopping early_stopping = EarlyStopping( min_delta=0.001, # minimium amount of change to count as an improvement patience=20, # 20个 restore_best_weights=True, ) 如果在过去20个epochs中，验证loss没有改善0.001，那么停止训练，保留找到的最佳模型。\nExample - Train a Model with Early Stopping from tensorflow import keras from tensorflow.keras import layers, callbacks early_stopping = callbacks.EarlyStopping( min_delta=0.001, # minimium amount of change to count as an improvement patience=20, # how many epochs to wait before stopping restore_best_weights=True, ) model = keras.Sequential([ layers.Dense(512, activation='relu', input_shape=[11]), layers.Dense(512, activation='relu'), layers.Dense(512, activation='relu'), layers.Dense(1), ]) model.compile( optimizer='adam', loss='mae', ) history = model.fit( X_train, y_train, validation_data=(X_valid, y_valid), batch_size=256, epochs=500, callbacks=[early_stopping], # put your callbacks in a list verbose=0, # turn off training log ) history_df = pd.DataFrame(history.history) history_df.loc[:, ['loss', 'val_loss']].plot(); print(\u0026quot;Minimum validation loss: {}\u0026quot;.format(history_df['val_loss'].min())) Dropout and Batch Normalization keras有几十中layers，可以在 Keras docs 中查看示例。这一节将介绍两种特殊的layer，它们本身不包含神经元。\nDropout Dropout可以帮助修正overfitting。\n前面讲过了数据的欠拟合和过拟合，出现了过拟合的情况，是因为网络模型学习了训练数据中的虚假的模式（噪声的模式），模型为了学习到这个模式 通常会依赖非常特定的权重组合，所以这种权重的组合才实现出的模式，往往是很脆弱的，移除一个就会瓦解。\nDropout就是在训练的每一步都随机删除一层输入单元的一小部分，这使得网络更难从训练数据中学习这些虚假模式。相反，它必须寻找广泛的、一般的模式，其权重模式往往更稳健。\nAdding Dropout 在Keras中，dropout率参数rate定义了要关闭的输入单元的百分比。将Dropout layer放在要应用Dropout的层之前：\nkeras.Sequential([ # ... layers.Dropout(rate=0.3), # apply 30% dropout to the next layer layers.Dense(16), # ... ]) Batch Normalization \u0026ldquo;batch normalization\u0026quot;或称\u0026quot;batchnorm\u0026quot;这个特殊层有助于纠正缓慢或不稳定的训练。在神经网络中通常需要将所有的数据放在一个通用的尺度上，可以使用scikit learn的StandardScaler或MinMaxScaler之类的工具，这是因为SGD根据数据产生的激活量按比例改变网络中的权重，训练中的数值大小范围不一样可能会导致不稳定的训练。\n可以在数据进入网络之前对其进行规范化（normalize），但是更好的操作是在网络的内部对数据进行规范化，batch normalization layer就是用来对网络中的数据进行规范化操作的，它会用其自身的平均值和标准差对batch进行标准化，然后用两个可训练的重缩放参数（trainable rescaling parameters）将数据放在一个新的尺度上。\n使用batchnorm的模型往往需要较少的时间完成训练，也可以解决可能导致训练“停滞”的各种问题，所以可以考虑在模型中添加batchnorm。\nAdding Batch Normalization batchnorm可以放在相对其他层的各种位置上，如果用它作为网络的第一层，就起到了一个代替预处理时对数据进行标准化的操作，类似Sci-Kit Learn的 StandardScaler，也可以放在某一层之后：\nlayers.Dense(16, activation='relu'), layers.BatchNormalization(), 或在某层和它的激活函数之间：\nlayers.Dense(16), layers.BatchNormalization(), layers.Activation('relu'), Example - Using Dropout and Batch Normalization 如果模型中使用了dropout，就应该在层中添加更多的单元，因为每次都会被随机抛弃一部分不参与的单元。\nfrom tensorflow import keras from tensorflow.keras import layers model = keras.Sequential([ layers.Dense(1024, activation='relu', input_shape=[11]), layers.Dropout(0.3), layers.BatchNormalization(), layers.Dense(1024, activation='relu'), layers.Dropout(0.3), layers.BatchNormalization(), layers.Dense(1024, activation='relu'), layers.Dropout(0.3), layers.BatchNormalization(), layers.Dense(1), ]) model.compile( optimizer='adam', loss='mae', ) history = model.fit( X_train, y_train, validation_data=(X_valid, y_valid), batch_size=256, epochs=100, verbose=0, ) # Show the learning curves history_df = pd.DataFrame(history.history) history_df.loc[:, ['loss', 'val_loss']].plot(); Binary Classification Introduction 之前的部分在介绍用深度学习解决回归问题，这一节介绍用深度学习解决分类问题。\nBinary Classification 二分类问题是指分成两类的问题，比如用\u0026quot;Yes\u0026rdquo;/\u0026ldquo;No\u0026quot;来回答的问题。我们需要给数据class label：0 或 1，数字标签是神经网络模型可以使用的数据形式。\nAccuracy and Cross-Entropy 准确性（Accuracy）是衡量分类问题成功与否的众多指标之一。accuracy是正确预测与总预测的比率：accuracy = number_correct / total。一个总是正确预测的模型的准确度得分为1.0。在所有其他条件相同的情况下，每当数据集中的类以大约相同的频率出现时，准确度是一个合理的指标。\naccuracy（以及大多数其他分类指标）的问题在于，它不能用作损失函数。SGD需要一个平稳变化的损失函数，但精度，作为计数的比率，在“跳跃”中变化。因此，我们必须选择一个替代品作为损失函数。这个替代品是交叉熵函数（cross-entropy function）。\n现在，回想一下损失函数定义了训练期间网络的目标。通过回归，我们的目标是最小化预期结果和预测结果之间的距离。我们选择了MAE来测量这个距离。\n对于分类，我们想要的是概率之间的距离，这就是交叉熵提供的。Cross-entropy是一种度量从一个概率分布到另一个概率分布的距离的方法。\n我们希望我们的网络以1.0的概率预测正确的班级。预测概率离1.0越远，交叉熵损失越大。\n我们使用交叉熵的技术原因有点微妙，但从这一节中我们要了解的主要内容是：使用交叉熵来进行分类损失；你可能关心的其他指标（如准确性）也会随之提高。\nMaking Probabilities with the Sigmoid Function 交叉熵和精度函数都需要概率作为输入，即0到1之间的数字。为了将密集层产生的实值输出转化为概率，我们附加了一种新的激活函数，即sigmoid激活函数。\n为了得到最终的类预测，我们定义了一个阈值概率。通常这将是0.5，因此四舍五入将为我们提供正确的类别：低于0.5表示标签为0的类别，0.5或以上表示标签为1的类别。0.5阈值是Keras默认使用的精度指标。\nExample - Binary Classification 除了最后一层用了“sigmoid”激活，它用来产生类概率，其他部分和回归任务一样。\nfrom tensorflow import keras from tensorflow.keras import layers model = keras.Sequential([ layers.Dense(4, activation='relu', input_shape=[33]), layers.Dense(4, activation='relu'), layers.Dense(1, activation='sigmoid'), ]) model.compile( optimizer='adam', # Adam也适用于分类问题 loss='binary_crossentropy', # 损失函数为 交叉熵函数 metrics=['binary_accuracy'], ) # 提前停止 回调函数 early_stopping = keras.callbacks.EarlyStopping( patience=10, min_delta=0.001, restore_best_weights=True, ) history = model.fit( X_train, y_train, validation_data=(X_valid, y_valid), batch_size=512, epochs=1000, callbacks=[early_stopping], verbose=0, # hide the output because we have so many epochs ) history_df = pd.DataFrame(history.history) # Start the plot at epoch 5 history_df.loc[5:, ['loss', 'val_loss']].plot() history_df.loc[5:, ['binary_accuracy', 'val_binary_accuracy']].plot() print((\u0026quot;Best Validation Loss: {:0.4f}\u0026quot; +\\ \u0026quot;\\nBest Validation Accuracy: {:0.4f}\u0026quot;)\\ .format(history_df['val_loss'].min(), history_df['val_binary_accuracy'].max())) Best Validation Loss: 0.5482 Best Validation Accuracy: 0.7619 Detecting the Higgs Boson With TPUs 这是属于Intro to Deep Learning的一节Bonus Lesson，介绍如何使用TPU的。\n# TensorFlow import tensorflow as tf print(\u0026quot;Tensorflow version \u0026quot; + tf.__version__) # Detect and init the TPU try: # detect TPUs tpu = tf.distribute.cluster_resolver.TPUClusterResolver.connect() # TPU detection strategy = tf.distribute.TPUStrategy(tpu) except ValueError: # detect GPUs strategy = tf.distribute.get_strategy() # default strategy that works on CPU and single GPU print(\u0026quot;Number of accelerators: \u0026quot;, strategy.num_replicas_in_sync) Computer Vision The Convolutional Classifier Introduction 卷积神经网络（convolutional neural networks）是最擅长理解图像的神经网络，我们称之为convent或CNN。卷积是一种数学运算，它使网络的各层具有独特的结构。\nThe Convolutional Classifier 用于图像分类的convnet由两部分组成：convolutional base 和 dense head。\nBase用于从图像中提取特征，它主要由执行卷积运算的层组成，但通常也包括其他类型的层。 Head用于确定图像的类别，它主要由致密层构成，但也可能包括其他层，如脱落层。 特征可以是线条、颜色、纹理、形状、图案，也可以是一些复杂的组合。\nTraining the Classifier 训练期间网络的目标是学习两件事：\n要从图像中提取哪些特征 (base)， 哪一类与哪些特征相匹配 (head)。 如今，convnet很少从零开始训练。更常见的情况是，我们重用预训练模型的基础。然后，我们在预先训练好的Base加上一个未经训练的Head。换句话说，我们重用网络中已经学会做提取特征的层，并附加一些新的层来学习分类。\n因为头部通常只有几个密集的层，所以可以从相对较少的数据中创建非常精确的分类器。\n迁移学习就是一种重用预先训练好的模型的技术。它非常有效，现在几乎所有的图像分类器都会使用它。\nExample - Train a Convnet Classifier 我们将创建一个用于分类汽车和卡车的分类器，数据集是大约10000张图片，其中汽车和卡车的几乎各占一半。\nStep 1 - Load Data # 导入一些包 import os, warnings import matplotlib.pyplot as plt from matplotlib import gridspec import numpy as np import tensorflow as tf from tensorflow.keras.preprocessing import image_dataset_from_directory # 设置固定的种子，来保证可复现性 def set_seed(seed=31415): np.random.seed(seed) tf.random.set_seed(seed) os.environ['PYTHONHASHSEED'] = str(seed) os.environ['TF_DETERMINISTIC_OPS'] = '1' set_seed(31415) # 设置 Matplotlib 的默认值 plt.rc('figure', autolayout=True) plt.rc('axes', labelweight='bold', labelsize='large', titleweight='bold', titlesize=18, titlepad=10) plt.rc('image', cmap='magma') warnings.filterwarnings(\u0026quot;ignore\u0026quot;) # to clean up output cells # Load training and validation sets ds_train_ = image_dataset_from_directory( '../input/car-or-truck/train', # 文件夹 labels='inferred', label_mode='binary', image_size=[128, 128], # 图片大小 interpolation='nearest', batch_size=64, shuffle=True, ) ds_valid_ = image_dataset_from_directory( '../input/car-or-truck/valid', labels='inferred', label_mode='binary', image_size=[128, 128], interpolation='nearest', batch_size=64, shuffle=False, ) # Data Pipeline def convert_to_float(image, label): image = tf.image.convert_image_dtype(image, dtype=tf.float32) return image, label AUTOTUNE = tf.data.experimental.AUTOTUNE ds_train = ( ds_train_ .map(convert_to_float) .cache() .prefetch(buffer_size=AUTOTUNE) ) ds_valid = ( ds_valid_ .map(convert_to_float) .cache() .prefetch(buffer_size=AUTOTUNE) ) Step 2 - Define Pretrained Base 最常用的预训练数据集是ImageNet，这是一个包含多种自然图像的大型数据集。Keras在其 applications模块中包含在ImageNet上预训练的各种模型。我们将使用的预训练模型称为VGG16。\npretrained_base = tf.keras.models.load_model( '../input/cv-course-models/cv-course-models/vgg16-pretrained-base', ) pretrained_base.trainable = False VGG16也可以这样直接调用：\ntf.keras.applications.vgg16.VGG16( include_top=True, weights='imagenet', input_tensor=None, input_shape=None, pooling=None, classes=1000, classifier_activation='softmax' ) Step 3 - Attach Head 接下来连接分类器head。先用一个Flatten层，把前面二维的输出转化为一维来提供给后面的层。然后是一个隐藏层，最后一层（输出层）把输出转换为判断是Truck的概率分数。\nfrom tensorflow import keras from tensorflow.keras import layers model = keras.Sequential([ pretrained_base, layers.Flatten(), layers.Dense(6, activation='relu'), layers.Dense(1, activation='sigmoid'), ]) Step 4 - Train 由于这是一个分成两类的问题，所以我们使用二进制版本的crossentropy和accuracy。\nmodel.compile( optimizer='adam', loss='binary_crossentropy', # 损失函数 metrics=['binary_accuracy'], # 准确度评估 ) history = model.fit( ds_train, validation_data=ds_valid, epochs=30, verbose=0, ) 在训练神经网络模型时，最好检查loss和metric曲线，变化过程被存储在history.history中，可以这样把它们显示出来：\nimport pandas as pd history_frame = pd.DataFrame(history.history) history_frame.loc[:, ['loss', 'val_loss']].plot() history_frame.loc[:, ['binary_accuracy', 'val_binary_accuracy']].plot(); Convolution and ReLU 前一节我们了解到卷积分类器有两部分：base和head，base从图像中提取特征，head使用这些特征对图像分类。\n后面的几节教程会介绍base部分 最重要的两种类型的层，它们分别是：具有ReLU激活的卷积层 和 最大池化层。第5节教程将会介绍通过这些层的组合来进行特征提取（Base部分）。\n这一节是关于卷积层和ReLU激活函数的。\nFeature Extraction 由base执行的特征提取包括三个基本操作：\n针对特定特征过滤（filter）图像（卷积） 在过滤后的图像中检测（detect）该特征（ReLU） 压缩（condense）图像以增强特征（最大池化） 下图说明了这个过程，可以看到这三个操作是如何隔离原始图像的某些特定特征的（在本例中为水平线）。\n通常网络会在一个图片上并行的提取，在一些现代的convnets中，最后一层产生1000多个独特的视觉特征也很多见。\nFilter with Convolution 卷积层执行滤波步骤,可以在Keras模型中定义一个卷积层：\nfrom tensorflow import keras from tensorflow.keras import layers model = keras.Sequential([ layers.Conv2D(filters=64, kernel_size=3), # activation is None # More layers follow ]) 我们可以通过观察这些参数与层的权重和激活的关系来理解这些参数。\nWeights convnet在训练期间学习的权重主要包含在其卷积层中，这些权重我们称之为核（kernels），我们可以将它们表示为小数组：\nkernel通过扫描图像并产生像素值的加权和来运行。通过这种方式，内核将像偏振光透镜一样，强调或不强调某些信息模式。\nKernels定义了卷积层如何连接到后面的层，上图中的kernel将前一层的9个神经元的输出，加权求和得到一个值输入到了后面层的一个神经元。我们可以使用kernel_size来设置kernel的维度，大多数情况下，kernel的维数都是奇数，如(3, 3)，(5, 5)，因此只有一个像素位于中心，但这并不是必须的。\n卷积层的kernel决定了它创建的特征类型，在训练期间，convent会尝试解决当前分类问题所需要的特征，这也意味着kernel的最佳取值。\nActivations 网络中的激活（activation），我们称之为特征映射（feature maps），它们是我们对图像应用过滤器时的结果；它们包含kernel提取的视觉特征。下面是一些kernel及其生成的特征映射：\n从kernel中的数字的模式，可以看出它创建的特征映射的类型。通常，卷积在其输入中强调的内容将与内核中正数的形状相匹配。上面的左核和中核都将过滤水平形状。\n使用filters参数，可以告诉卷积层希望它创建多少个特征贴图作为输出。\n","permalink":"https://slightwind.cn/posts/tutorial/notes-kaggle-courses-intro-to-dl/","summary":"Intro to Deep Learning A Single Neuron The Linear Unit 下面是一个neuron（或称unit）的示意图，x是输入；w是x的权重weight；b是bias，是一种特殊的权重，没有和bias相关的输入数据，它可以独立于输入修改输出。神经网络通过修改权重来“learn”。\ny是这个神经元输出的值，$y=wx+b$，刚好是一个直线的方程，w是斜率，b是在y轴上的截距。\nExample - The Linear Unit as a Model 单个神经元是通常只会在更大的网络中发挥作用，单神经元模型是线性模型。当$w=2.5, b=90$时，这个线性模型可以用来反应糖'sugars'和卡路里'calories'的关系：\nMultiple Inputs 对于多个输入，也是这样将每个输入乘以权重，并把它们相加。下面这个对应的公式为：$y=w_{0} x_{0}+w_{1} x_{1}+w_{2} x_{2}+b.$ Linear Units in Keras 在Keras中创建模型最简单的方法是使用keras.Sequential，下面这个示例表示一个线性模型，可以输入3个特征（\u0026lsquo;sugars\u0026rsquo;, \u0026lsquo;fiber\u0026rsquo;, \u0026lsquo;protein\u0026rsquo;），并且只有一个输出：\u0026lsquo;calories\u0026rsquo;。\nfrom tensorflow import keras from tensorflow.keras import layers # Create a network with 1 linear unit model = keras.Sequential([ layers.Dense(units=1, input_shape=[3]) ]) 第一个参数units定义输出的个数，input_shape告诉Keras输入特征的数量。目前只需要用到input_shape=[num_columns]，input_shape还可以支持使用更复杂的数据：[height, width, channels]。\nTensors是TensorFlow版本的numpy数组，并且做了一些使它更适合用于机器学习的改变，Tensors与GPU/TPU加速器兼容，而TPU就是专为Tensors而设计的。在Keras内部，使用Tensors表示神经网络的权重。\nmodel.weights可以用来查看权重，在训练开始前，权重都会被初始化为随机值。\nDeep Neural Networks Layers 神经网络会将神经元组成层（layers），合并有相同的输入的线性神经元，就得到了一个稠密层（dense layer） The Activation Function 两个中间没有其他东西的稠密层，效果并不会比一个稠密层的效果好多少，“稠密层本身不能带我们离开线和面的世界”，我们需要的是非线性（nonlinear），需要激活函数（activation function）。","title":"Notes: Kaggle Courses - Intro to DL \u0026 Computer Vision"},{"content":"Intro to Machine Learning L How Models Work 介绍了当前这篇教程的内容和受众，然后举例说明ml可以做什么，可以使用模型，来代替人对各种类型的房屋价值进行估计。然后用简单的决策树对房屋分类，预测不同房屋的价值。\n从数据中提取模式的过程这一步骤称为拟合(fitting)或训练(training)模型，用于拟合模型的数据称为训练数据(training data)。\nBasic Data Exploration Using Pandas to Get Familiar With Your Data 这里开始讲pandas，一般会把它缩写为pd，可以使用pandas来帮助我们熟悉数据。pandas中有一个重要的概念“DataFrame”，可以把它类比成Excel中的工作表，或者SQL数据库中的table，pandas的功能很强大。\n给了一个简单使用pandas的例子：\n# save filepath to variable for easier access melbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv' # read the data and store data in DataFrame titled melbourne_data melbourne_data = pd.read_csv(melbourne_file_path) # print a summary of the data in Melbourne data melbourne_data.describe() Interpreting Data Description 这里就是解释了一下上面这个例子中，各个列的含义，然后提到了缺失值。\n有些位置可能会出现一些缺失值，这确实是符合现实情况的，比如泰坦尼克号的数据中，有些人的数据收集不全了，这种时候可以通过一些方法把它填上。然后看到有篇文章讲到缺失值可以通过其他的比较全的数据作为X，缺失值对应的特征作为y，来简单构建一个模型预测一下，从而达到通过其他信息补上可能性比较大的值的操作。\nYour First Machine Learning Model Selecting Data for Modeling 有些时候数据中会有太多的变量，这些变量不一定是我们的模型所需要的，应该通过一些方法来选择对我们训练模型有价值的变量。\nimport pandas as pd melbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv' melbourne_data = pd.read_csv(melbourne_file_path) melbourne_data.columns ''' Index(['Suburb', 'Address', 'Rooms', 'Type', 'Price', 'Method', 'SellerG', 'Date', 'Distance', 'Postcode', 'Bedroom2', 'Bathroom', 'Car', 'Landsize', 'BuildingArea', 'YearBuilt', 'CouncilArea', 'Lattitude', 'Longtitude', 'Regionname', 'Propertycount'], dtype='object') ''' 关于axis参数，推荐阅读 https://railsware.com/blog/python-for-machine-learning-pandas-axis-explained/ 来详细了解，简单来说，axis是用来选择行/列的。\n可以使用dropna()把包含缺失值的行/列直接删除，首先创建一个在3行b列出现了缺失值的DataFrame，可以通过改变axis的值，选择删除3行，或者删除整个b列。\n\u0026gt;\u0026gt;\u0026gt; import pandas as pd \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; srs_a = pd.Series([10,30,60,80,90]) \u0026gt;\u0026gt;\u0026gt; srs_b = pd.Series([22, 44, 55, np.nan, 101]) \u0026gt;\u0026gt;\u0026gt; df = pd.DataFrame({'a': srs_a, 'b': srs_b}) \u0026gt;\u0026gt;\u0026gt; df a b 0 10 22.0 1 30 44.0 2 60 55.0 3 80 NaN 4 90 101.0 \u0026gt;\u0026gt;\u0026gt; df.dropna(axis=0) # 删除`3`行 a b 0 10 22.0 1 30 44.0 2 60 55.0 4 90 101.0 \u0026gt;\u0026gt;\u0026gt; df.dropna(axis=1) # 删除`b`列 a 0 10 1 30 2 60 3 80 4 90 其实也可以使用 pd.np 来访问到numpy，但是会提示将来的版本会不再支持这样导入，所以为了代码在将来的版本可以运行，更推荐单独导入numpy\nSelecting The Prediction Target 我们将使用点符号来选择我们想要预测的列，这称为预测目标。按照惯例，预测目标称为 y。所以我们需要保存墨尔本数据中房价的代码是\ny = melbourne_data.Price Choosing \u0026ldquo;Features\u0026rdquo; 输入到我们模型中的列称为“特征”，在我们的例子中，这些将是用于确定房价的列。有些时候会使用除目标之外的所有列作为特征。也有些时候使用更少的特征训练效果会更好。\n按照惯例，训练数据称为 X。\nmelbourne_features = ['Rooms', 'Bathroom', 'Landsize', 'Lattitude', 'Longtitude'] X = melbourne_data[melbourne_features] 可以再使用 X.describe() 来大概看一下数据的数量、平均值等信息，以及使用X.head()来查看表的最前面几行。\nBuilding Your Model 下面使用scikit-learn来创建和训练模型，在代码中使用它的简称sklearn，sklearn可以直接处理存储在DataFrame中的数据。\n构建和使用模型的步骤是：\nDefine：它将是什么类型的模型？以及指定模型类型的一些参数。 Fit：从提供的数据中获取模式。这是建模的核心部分。 Predict：通过未知的X预测出对应的y Evaluate：确定模型的预测有多准确。 这是一个使用 scikit-learn 定义决策树模型并将其与特征和目标变量拟合的示例。\nfrom sklearn.tree import DecisionTreeRegressor # Define model. Specify a number for random_state to ensure same results each run melbourne_model = DecisionTreeRegressor(random_state=1) melbourne_model.fit(X, y) # Fit model print(\u0026quot;Making predictions for the following 5 houses:\u0026quot;) print(X.head()) print(\u0026quot;The predictions are\u0026quot;) print(melbourne_model.predict(X.head())) Many machine learning models allow some randomness in model training. Specifying a number for random_state ensures you get the same results in each run. This is considered a good practice. You use any number, and model quality won\u0026rsquo;t depend meaningfully on exactly what value you choose.\nModel Validation What is Model Validation 常常需要评估自己构建的模型，来验证自己的模型在预测时的准确性，不应该使用训练数据进行预测，这样会得到较准确的预测结果，但是很可能在预测新数据的时候有很大的偏离，一般来说常用的方法是按照一定比例分离自己拥有的数据，一部分用于训练，一部分用来验证，训练过程不应该让模型接触到验证数据。\n总结模型质量的指标有很多，但我们从一个称为平均绝对误差（也称为 MAE）的指标开始。让我们从最后一个词 error 开始分解这个指标。每栋房屋的预测误差为： error=actual−predicted\n使用 MAE 度量，取每个error的绝对值，然后我们计算这些绝对误差的平均值。\nfrom sklearn.metrics import mean_absolute_error predicted_home_prices = melbourne_model.predict(X) mean_absolute_error(y, predicted_home_prices) 这里有个 The Problem with \u0026ldquo;In-Sample\u0026rdquo; Scores，也是在说明不应该使用训练数据去验证模型的效果\nCoding It scikit-learn 库有一个函数 train_test_split 将数据分成两部分。 我们将使用其中一些数据作为训练数据来拟合模型，使用其他数据作为验证数据来计算 mean_absolute_error。\nfrom sklearn.model_selection import train_test_split train_X, val_X, train_y, val_y = train_test_split(X, y, random_state = 0) # Define model melbourne_model = DecisionTreeRegressor() # Fit model melbourne_model.fit(train_X, train_y) # get predicted prices on validation data val_predictions = melbourne_model.predict(val_X) print(mean_absolute_error(val_y, val_predictions)) # 258930.03550677857 Underfitting and Overfitting 这一部分讲模型的欠拟合和过拟合，尽量避免这两种情况可以优化模型的性能。\nExperimenting With Different Models 有了前面衡量模型准确性的指标（MAE），就可以通过选择不同的模型，或者使用不同的参数，来训练出更好的模型。\n比如scikit-learn的决策树模型，我们可以更改树的深度，树的深度是衡量它在进行预测之前进行了多少次分割的量度。比如分割1次，就是分割成了2种情况，分割2次就是4种情况，10次即1024种。。。也就是一棵二叉树叶子节点的数量。比如通过房屋的各种特征来分割，分的种类越多，平均下来每个种类的房屋的数量就越少，如果本就不多的训练数据被分成了1024类，模型几乎完美地匹配训练数据，对于新数据很可能做出不准确的预测，这就是过度拟合（Overfitting）的现象，\n如果一棵决策树只将房屋分成2种或4种情况，每组中会有各种各样的房屋，模型不能详细的体现数据中的重要区别和模式，在用验证数据或训练数据评估时都会发现效果不佳，这称为欠拟合（Underfitting）。\n由于我们希望可以准确地预测新数据，我们希望找到欠拟合和过拟合之间的最佳点，也就是下图中（红色）验证曲线的低点。\nExample 也有方法可以让树的某些路径的深度大于另一些路径的深度，max_leaf_nodes提供了一种非常明智的方法来控制欠拟合和过拟合，我们允许模型生长出的叶子数量越多，从上图中的欠拟合区域移动到过拟合区域的距离就越多。这样就可以通过调节max_leaf_nodes，来获取最佳MAE分数。\nfrom sklearn.metrics import mean_absolute_error from sklearn.tree import DecisionTreeRegressor def get_mae(max_leaf_nodes, train_X, val_X, train_y, val_y): model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=0) model.fit(train_X, train_y) preds_val = model.predict(val_X) mae = mean_absolute_error(val_y, preds_val) return(mae) for max_leaf_nodes in [5, 50, 500, 5000]: my_mae = get_mae(max_leaf_nodes, train_X, val_X, train_y, val_y) print(\u0026quot;Max leaf nodes: %d \\t\\t Mean Absolute Error: %d\u0026quot; %(max_leaf_nodes, my_mae)) 从下面的输出结果可以看出，在这些选择中，500是最好的选择。\nMax leaf nodes: 5 Mean Absolute Error: 347380 Max leaf nodes: 50 Mean Absolute Error: 258171 Max leaf nodes: 500 Mean Absolute Error: 243495 Max leaf nodes: 5000 Mean Absolute Error: 254983 Conclusion Overfitting: capturing spurious patterns that won\u0026rsquo;t recur in the future, leading to less accurate predictions, or Underfitting: failing to capture relevant patterns, again leading to less accurate predictions. 可以用验证数据，去评估模型的性能，为模型选择尽可能适合的参数。\nRandom Forests Introduction 随机森林使用多个树，它通过平均每个树的预测来进行预测。 通常比单个决策树具有更好的预测精度，并且可以很好地使用默认参数。\nfrom sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_absolute_error forest_model = RandomForestRegressor(random_state=1) forest_model.fit(train_X, train_y) melb_preds = forest_model.predict(val_X) print(mean_absolute_error(val_y, melb_preds)) # 191669.7536453626 把之前的决策树类DecisionTreeRegressor替换成随机森林类RandomForestRegressor，可以发现即使是直接使用默认参数，也可以得到优于之前（MAE=258930.03550677857）的结果（MAE=191669.7536453626）。\nMachine Learning Competitions 这里就是一个讲在kaggle上如何参加比赛的教程，跟着做一遍就会在kaggle的服务器上训练模型并得到最后的结果，然后可以提交结果看到排名。\nIntermediate Machine Learning Introduction 解决现实世界数据集中经常出现的数据类型（缺失值、分类变量）， 设计pipelines以提高机器学习代码的质量， 使用先进的模型验证技术（cross-validation，交叉验证）， 构建广泛用于赢得Kaggle竞赛的最先进模型（XGBoost）， 避免常见和重要的数据科学错误（leakage）。 Missing Values 这节教程会介绍3种处理缺失值的方法，在现实世界的数据中，很多情况会存在缺失值：\n一套两卧室的房子，不会包含第三个卧室的大小数据 调查对象可以选择不提供自己的收入 Three Approaches 1) A Simple Option: Drop Columns with Missing Values 直接把含有缺失值的列（特征）删除，这个方法很简单，但是可能会直接导致重要的特征丢失。\n2) A Better Option: Imputation Imputation指用一些数字填充缺失的值。例如，我们可以在NaN处填写每列的平均值。\n3) An Extension To Imputation 在方法2的基础上，再插入一列，用True/False来表示存在缺失值这一列对应的数据是否缺失，这个方法有时候表现良好，也有时候不好。\n我在其他地方还看到一种方法感觉比较好，可以称为方法4，把存在缺失值的这一列，作为target，其他不存在缺失值的列，作为特征，以存在缺失值这一列的其他不缺失的数据作为训练集和验证集，把缺失的行作为test集来为其预测并填充，这样可以得到尽可能准确的填充。\n当然最好是具体问题具体分析，比如某个存在缺失值的数据与预测目标相关性不大，或者缺失值太多，并且类型不方便预测，比如是姓名，就可以直接将这一列删除。如果是第3个卧室的问题（房型只有两个卧室），可以把它的面积置为0，来表示它不存在，如果把它设置为第3个卧室的平均大小，对其他房间小的数据来说太不公平。。。如果某列特征方差比较小，也可以直接取平均值填充来使模型正常运行。\n测试了3种填充方法，在同一模型下预测的结果，可以看出来方法3比方法2稍差，但是差距并不大。\nMAE from Approach 1 (Drop columns with missing values): 183550.22137772635 MAE from Approach 2 (Imputation): 178166.46269899711 MAE from Approach 3 (An Extension to Imputation): 178927.503183954 Categorical Variables 我们会遇到很多非数值型数据，这些数据我们也可以将它们应用到机器学习中，在这节教程里会介绍处理分类变量的三种方法。\n分类变量只接受有限数量的值，比如询问早餐的频率“从不”、“很少”、“大多数”或“每天”，或者对车的品牌进行调查，得到的回答是各个品牌。\nThree Approaches 1) Drop Categorical Variables 删掉分类变量。。。。\n2) Ordinal Encoding 顺序编码将每个唯一值分配给不同的整数。\n这种方法假定类别的排序：“从不”（0）\u0026lt;“很少”（1）\u0026lt;“大多数天”（2）\u0026lt;“每天”（3）。对这样的分类进行排名是没有争议的，我们可以把描述频率的词汇对应到数值上，模型也将会很好的处理这些数据。\n3) One-Hot Encoding One-Hot编码的方法是创建一些新的列来代替原来的列，这些新的列名为具体的分类，值为存在/不存在，比如下面这个图示：\n所以对于没有顺序的分类，可以使用One-Hot编码这种方式来对分类进行数值化。但是它的缺点也很明显，如果分类很多，那么进行One-Hot编码后会出现很多新的列，这些列组成的矩阵将是个很稀疏的矩阵，这个时候可能模型会表现的不好。\nMAE from Approach 1 (Drop categorical variables): 175703.48185157913 MAE from Approach 2 (Ordinal Encoding): 165936.40548390493 MAE from Approach 3 (One-Hot Encoding): 166089.4893009678 方法2和方法3在这里的数据中并没有出现明显的差距，但是很明显都优于直接删除。\nPipelines Pipelines是一个可以把数据预处理和创建模型组装到一起的工具，可以：使代码更整洁，更少的bug，更容易部署，更多验证模型的选择。\n第一步，定义数据预处理的过程\nfrom sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.preprocessing import OneHotEncoder # Preprocessing for numerical data numerical_transformer = SimpleImputer(strategy='constant') # Preprocessing for categorical data categorical_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='most_frequent')), ('onehot', OneHotEncoder(handle_unknown='ignore')) ]) # Bundle preprocessing for numerical and categorical data preprocessor = ColumnTransformer( transformers=[ ('num', numerical_transformer, numerical_cols), ('cat', categorical_transformer, categorical_cols) ]) 第二步，定义模型\nfrom sklearn.ensemble import RandomForestRegressor model = RandomForestRegressor(n_estimators=100, random_state=0) 第三步，创建并评估Pipeline\nfrom sklearn.metrics import mean_absolute_error # Bundle preprocessing and modeling code in a pipeline my_pipeline = Pipeline(steps=[('preprocessor', preprocessor), ('model', model) ]) # Preprocessing of training data, fit model my_pipeline.fit(X_train, y_train) # Preprocessing of validation data, get predictions preds = my_pipeline.predict(X_valid) # Evaluate the model score = mean_absolute_error(y_valid, preds) print('MAE:', score) Cross-Validation 如果碰巧抽出的部分验证集数据有些特殊，而我们对于模型和参数的选择是基于验证集的，可能会干扰我们的决策。\nWhat is cross-validation? 在交叉验证中，我们在不同的数据子集上运行建模过程，以获得模型质量的多个度量。例如，我们可以首先将数据分成5个部分，每个部分占整个数据集的20%。在这种情况下，我们说我们已经将数据分成5个“折叠”。\n在Experiment 1中，我们用1st fold，作为验证集，其他80%作为训练集对模型进行训练，并用验证集评估。 在Experiment 2中，我们用2nd fold，作为验证集，其他80%作为训练集对模型进行训练，并用验证集评估。 重复这个过程，就可以得到不同的5个验证集上的结果，用这个结果来评估当前的模型（参数）会更加合理。 When should you use cross-validation? 对于比较小的数据集，折叠多次 也就是训练多次不会对计算造成太大负担，可以使用交叉验证。 对于比较大的数据集，多次折叠会导致耗费大量的时间，并且既然数据集很大，分割出来的这部分验证集应该会具有不错的随机性，所以只用验证一次即可。 使用Pipelines可以很方便的进行交叉验证，不使用Pipelines的交叉验证代码会比较复杂。\nfrom sklearn.ensemble import RandomForestRegressor from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer my_pipeline = Pipeline(steps=[('preprocessor', SimpleImputer()), ('model', RandomForestRegressor(n_estimators=50, random_state=0)) ]) 我们使用sklearn中的cross_val_score()函数获得交叉验证分数，使用cv参数设置折叠的数量。\nfrom sklearn.model_selection import cross_val_score # Multiply by -1 since sklearn calculates *negative* MAE scores = -1 * cross_val_score(my_pipeline, X, y, cv=5, scoring='neg_mean_absolute_error') print(\u0026quot;MAE scores:\\n\u0026quot;, scores) MAE scores: [301628.7893587 303164.4782723 287298.331666 236061.84754543 260383.45111427] scoring参数可以选择评估的标准，参考sklearn的文档可以了解支持的其他选择。这里我们指定的是negative mean absolute error (MAE)。\nsklearn 约定评估分数的时候，数值越大越好，MAE属于是越小越好的标准，所以sklearn选择只提供negative MAE，来保持自己的约定，我们在使用的时候，取 neg_mean_absolute_error 然后乘 -1 即可。\n通常需要单一指标来评估模型，所以可以取它们的平均值：\nprint(\u0026quot;Average MAE score (across experiments):\u0026quot;) print(scores.mean()) XGBoost 我们之前在很多练习中应用了随机森林模型，这种方法被称为“集成方法”（ensemble method），根据定义，集成方法集成了多个模型的预测。随机森林就是集成了多个决策树的预测，接下来，将学习另一种称为梯度增强（gradient boosting）的集成方法。\nGradient Boosting 梯度增强是一种通过循环将模型迭代地添加到集合中的方法。\n它会被初始化为只有一个模型的集合，它的预测十分不准确，但是后续对这个集合的添加会解决这个问题。\n接下来开始循环：\n首先，我们用集合内的每个模型为数据集生成预测，并把这些预测相加。这些预测用于计算损失函数（例如，均方误差）。 然后，我们使用损失函数来拟合一个新模型，并把该模型添加到集合中。具体来说，我们确定模型参数并将新模型添加到集合中来减少损失。（注：“梯度增强”中的“梯度”指的是我们将使用损失函数的梯度下降来确定这个新模型中的参数。） 最后，我们将新模型添加到集合中\u0026hellip; \u0026hellip;重复 XGBoost 意为 extreme gradient boosting，它是gradient boosting的一种实现，具有一些专注于性能和速度的附加功能，sklearn有其他版本的gradient boosting，但XGBoost有一些技术优势。\nExample from xgboost import XGBRegressor my_model = XGBRegressor() my_model.fit(X_train, y_train) 对模型进行预测和评估：\nfrom sklearn.metrics import mean_absolute_error predictions = my_model.predict(X_valid) print(\u0026quot;Mean Absolute Error: \u0026quot; + str(mean_absolute_error(predictions, y_valid))) Mean Absolute Error: 239435.01260125183 Parameter Tuning XGBoost有几个参数可以显著影响准确性和训练速度：\nn_estimators n_estimators指定了上述过程的周期数，同时它也是集合中模型的数量。\n太低会导致欠拟合，对训练数据和测试数据的预测不准确。 太高会导致过拟合，对训练数据的预测很准确，但是对测试数据的预测比较差。 它的范围在100-1000，但是它的大小 很大程度上也取决于后面要讲的learning_rate参数。 my_model = XGBRegressor(n_estimators=500) # 设置周期数为 500 my_model.fit(X_train, y_train) early_stopping_rounds early_stopping_rounds提供了自动找到理想的n_estimators的方法，当验证分数停止改善时，会提前停止迭代，所以我们可以设置一个比较大n_estimators，然后模型很可能会在这之前自动停止训练。由于训练过程具有一定的随机性，所以有时可能会某一轮没有提升，所以一般会设置early_stopping_rounds=5，即连续5轮验证分数都没有改善那么就停止训练。\n在使用early_stopping_rounds的时候，要留出一部分数据来计算验证分数，这是由eval_set参数来完成的。\n将上面提到的参数应用到模型中，来使模型提前停止：\nmy_model = XGBRegressor(n_estimators=500) my_model.fit(X_train, y_train, early_stopping_rounds=5, eval_set=[(X_valid, y_valid)], verbose=False) learning_rate 我们可以将每个模型的预测乘以一个较小的数字（learning rate）然后再把它们相加。如果学习率比较小，会导致每个模型的预测对我们的帮助都比较小，所以我们应该在不会使它过拟合的前提下 设置尽可能高的学习率。\n一般来说，较小的学习率和较大的模型集合将产生更精确的XGBoost模型，但这样会有较大的计算成本，更多的迭代，每次迭代耗费更长的时间，默认情况XGBoost会设置learning_rate=0.1。\nmy_model = XGBRegressor(n_estimators=1000, learning_rate=0.05) my_model.fit(X_train, y_train, early_stopping_rounds=5, eval_set=[(X_valid, y_valid)], verbose=False) n_jobs 在需要考虑运行时间的大型数据集上，可以将n_jobs设置为核心的数量，使用并行运算更快的构建模型。但是在较小的数据集上这样做不会有帮助。\nmy_model = XGBRegressor(n_estimators=1000, learning_rate=0.05, n_jobs=4) my_model.fit(X_train, y_train, early_stopping_rounds=5, eval_set=[(X_valid, y_valid)], verbose=False) Data Leakage 这节教程会介绍数据泄露，以及如何防止数据泄露，如果不知道如何预防，那么数据泄露就会频繁出现，以微妙而危险的方式破坏模型。\n当训练数据中包含有关target的信息时，会发生数据泄露，但当模型用于预测时，类似的数据将不可用。这将导致模型在训练集（甚至可能在验证集）上性能很高，但是在生产中性能较差。\n泄漏主要有两种类型：target leakage 和 train-test contamination\nTarget leakage 当训练的数据集中存在“在实际使用模型时不存在”的信息，并且这个信息对target有很强的相关性，这样会导致在训练集和测试集上效果都很好，但是在实际使用的时候，模型效果很差，比如下面这个例子：\n假设要通过一些受访者的信息来判断他是否患有肺炎，下图是收集到的部分数据：\ngot_pneumonia age weight male took_antibiotic_medicine \u0026hellip; False 65 100 False False \u0026hellip; False 72 130 True False \u0026hellip; True 58 100 False True \u0026hellip; 其中took_antibiotic_medicine列和目标值got_pneumonia关系很强，因为如果得了肺炎那么他极大可能会吃药，训练过程就会根据吃药的行为判断他得了肺炎，这在实际应用模型时会发生判断不准确的现象，所以在使用数据训练模型的时候，要注意这些数据产生的时间需要是在“生产环境中使用模型进行预测的阶段”之前。\nTrain-Test Contamination 如果在数据预处理的时候，如果验证集也以某种方式参与了进来，比如在train_test_split()之前使用全部数据对空值插补，那么最后的模型很可能在训练集和验证集上表现良好，但在生产环境中表现较差。\n","permalink":"https://slightwind.cn/posts/tutorial/notes-kaggle-courses-intro-to-ml/","summary":"Intro to Machine Learning L How Models Work 介绍了当前这篇教程的内容和受众，然后举例说明ml可以做什么，可以使用模型，来代替人对各种类型的房屋价值进行估计。然后用简单的决策树对房屋分类，预测不同房屋的价值。\n从数据中提取模式的过程这一步骤称为拟合(fitting)或训练(training)模型，用于拟合模型的数据称为训练数据(training data)。\nBasic Data Exploration Using Pandas to Get Familiar With Your Data 这里开始讲pandas，一般会把它缩写为pd，可以使用pandas来帮助我们熟悉数据。pandas中有一个重要的概念“DataFrame”，可以把它类比成Excel中的工作表，或者SQL数据库中的table，pandas的功能很强大。\n给了一个简单使用pandas的例子：\n# save filepath to variable for easier access melbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv' # read the data and store data in DataFrame titled melbourne_data melbourne_data = pd.read_csv(melbourne_file_path) # print a summary of the data in Melbourne data melbourne_data.describe() Interpreting Data Description 这里就是解释了一下上面这个例子中，各个列的含义，然后提到了缺失值。\n有些位置可能会出现一些缺失值，这确实是符合现实情况的，比如泰坦尼克号的数据中，有些人的数据收集不全了，这种时候可以通过一些方法把它填上。然后看到有篇文章讲到缺失值可以通过其他的比较全的数据作为X，缺失值对应的特征作为y，来简单构建一个模型预测一下，从而达到通过其他信息补上可能性比较大的值的操作。\nYour First Machine Learning Model Selecting Data for Modeling 有些时候数据中会有太多的变量，这些变量不一定是我们的模型所需要的，应该通过一些方法来选择对我们训练模型有价值的变量。","title":"Notes: Kaggle Courses - Intro to ML \u0026 Intermediate ML"},{"content":"Pandas Creating, Reading and Writing Creating data import pandas as pd pandas是最受欢迎的python数据分析包。pandas中有两个核心对象DataFrame和Series。\nDataFrame是一个表，由多个数组构成，这些数组常常作为表里面的列。使用pd.DataFrame()来实例化一个DataFrame对象，数据参数使用的是python中的dict，dict的key作为DataFrame的列名，dict的value是一个list，作为对应列的全部元素。\n\u0026gt;\u0026gt;\u0026gt; pd.DataFrame({'Yes': [50, 21], 'No': [131, 2]}) Yes No 0 50 131 1 21 2 \u0026gt;\u0026gt;\u0026gt; pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']}) Bob Sue 0 I liked it. Pretty good. 1 It was awful. Bland. 行的下标（通常称为索引(index)）默认和python的list一样，从0开始，也可以在构造时自定义\n\u0026gt;\u0026gt;\u0026gt; pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']}, index=['Product A', 'Product B']) Bob Sue Product A I liked it. Pretty good. Product B It was awful. Bland. Series是一系列的数据，DataFrame是table，而Series是list，并且也可以设置index，但是没有列名，只可以设置一个name\n\u0026gt;\u0026gt;\u0026gt; pd.Series([1, 2, 3, 4, 5]) 0 1 1 2 2 3 3 4 4 5 dtype: int64 \u0026gt;\u0026gt;\u0026gt; pd.Series([30, 35, 40], index=['2015 Sales', '2016 Sales', '2017 Sales'], name='Product A') 2015 Sales 30 2016 Sales 35 2017 Sales 40 Name: Product A, dtype: int64 可以将DataFrame视为粘在一起的Series。\nReading data files wine_reviews = pd.read_csv(\u0026quot;../input/wine-reviews/winemag-data-130k-v2.csv\u0026quot;) wine_reviews.shape # 输出行和列的数量 # (129971, 14) wine_reviews.head() # 输出前几行的数据 pd.read_csv()的功能强大，可以指定30多个可选参数，比如可以设置csv文件的第0列作为索引：\nwine_reviews = pd.read_csv(\u0026quot;../input/wine-reviews/winemag-data-130k-v2.csv\u0026quot;, index_col=0) 将DataFrame写入csv文件：\nanimals.to_csv(\u0026quot;cows_and_goats.csv\u0026quot;) Indexing, Selecting \u0026amp; Assigning 如果reviews这个DataFrame中包含列名\u0026quot;country\u0026quot;，那么可以通过reviews.country或reviews['country']来访问这一列。\nIndexing in pandas pandas有自己的访问数据的方式：loc和iloc。\nIndex-based selection 可以用iloc这样访问第一行的数据：\nreviews.iloc[0] 可以这样检索第一列的数据：\nreviews.iloc[:, 0] # DataFrame.iloc[行, 列]，行和列都可以是值或区间 在python中:代表全部，在字符串分割的时候，s[:]即s[0:len(s)]，在这里也可以这样使用，比如获取第0列，前3行的数据：\nreviews.iloc[:3, 0] reviews.iloc[[0, 1, 2], 0] # 和上面一行是同样的效果 Label-based selection loc遵循以基于lable的选择，比如可以通过reviews.loc[0, 'country']来访问\u0026rsquo;country\u0026rsquo;的首行位置的数据。\niloc把DataFrame看作一个二维矩阵，通过各种方式来获取对应位置的数据，loc更像把DataFrame看作Excel的表，可以通过lable来选择数据。\nreviews.loc[:, ['taster_name', 'taster_twitter_handle', 'points']] Choosing between loc and iloc 0:10在loc中表示$0,1,\u0026hellip;,10$（闭区间），而在iloc中表示$0,1,\u0026hellip;,9$（左闭右开）。\n比如第3列的列名是\u0026quot;Apples\u0026quot;，可以DataFrame.iloc[:, 2]来访问这一列的数据，也可以使用DataFrame.loc['Apples']，显然后者更直观。\nConditional selection \u0026gt;\u0026gt;\u0026gt; reviews.country == 'Italy' 0 True 1 False ... 129969 False 129970 False Name: country, Length: 129971, dtype: bool 可以通过运算符构造条件筛选出想要的数据：\n# 筛选国家是'Italy'的数据 reviews.loc[reviews.country == 'Italy'] # 筛选国家是'Italy' 并且 points \u0026gt;= 90 的数据 reviews.loc[(reviews.country == 'Italy') \u0026amp; (reviews.points \u0026gt;= 90)] # 筛选国家是'Italy' 或 points \u0026gt;= 90 的数据 reviews.loc[(reviews.country == 'Italy') | (reviews.points \u0026gt;= 90)] isin类似python的is in，筛选country为\u0026rsquo;Italy\u0026rsquo;或\u0026rsquo;France\u0026rsquo;的数据可以：\nreviews.loc[reviews.country.isin(['Italy', 'France'])] isnull和notnull用来判断是否为NaN： reviews.loc[reviews.price.notnull()]\nAssigning data DataFrame也支持更改表中的数值：\n\u0026gt;\u0026gt;\u0026gt; reviews['critic'] = 'everyone' \u0026gt;\u0026gt;\u0026gt; reviews['critic'] 0 everyone 1 everyone ... 129969 everyone 129970 everyone Name: critic, Length: 129971, dtype: object \u0026gt;\u0026gt;\u0026gt; reviews['index_backwards'] = range(len(reviews), 0, -1) \u0026gt;\u0026gt;\u0026gt; reviews['index_backwards'] 0 129971 1 129970 ... 129969 2 129970 1 Name: index_backwards, Length: 129971, dtype: int64 Summary Functions and Maps Summary functions pandas提供了一些汇总函数，比如之前提到过的describe()，DataFrame可以直接调用：reviews.points.describe()。\ndescribe()对类型敏感，对于不同的数据类型，也会返回不同的结果。对于数字类型的数据，调用describe()会显示mean等信息，也可以直接使用reviews.points.mean()获取。\nreviews.taster_name.unique() # 不重复的输出全部出现过的 taster_name值 reviews.taster_name.value_counts() # 输出各个taster_name值对应的出现次数 如果想要获取这些分数和平均值的差距，可以使用map()，返回这一列Series，不会覆盖原来的值：\nreview_points_mean = reviews.points.mean() reviews.points.map(lambda p: p - review_points_mean) 如果想获取整个DataFrame，可以使用apply()，也不会覆盖原来的值：\ndef remean_points(row): row.points = row.points - review_points_mean return row reviews.apply(remean_points, axis='columns') 还可以有更快的方法：\nreview_points_mean = reviews.points.mean() reviews.points - review_points_mean 这样直接用一个数值和Series进行操作，就像在python中直接用数字和list运算，显然在python里是不允许的，但是pandas会知道将Series的每一个值和这个数操作，而且速度比map和apply更快，但是map和apply更灵活，可以做更高级的事情。\n计算\u0026quot;tropical\u0026quot;和\u0026quot;fruity\u0026quot;在description中出现的次数：\nn_trop = reviews.description.map(lambda desc: \u0026quot;tropical\u0026quot; in desc).sum() n_fruity = reviews.description.map(lambda desc: \u0026quot;fruity\u0026quot; in desc).sum() descriptor_counts = pd.Series([n_trop, n_fruity], index=['tropical', 'fruity']) Grouping and Sorting Groupwise analysis 分组可以把某一列值相同的数据合为一组，然后我们可以获取这些组的各种信息：\n# points相同的分别分组，然后统计这些分组中成员的数量 \u0026gt;\u0026gt;\u0026gt; reviews.groupby('points').points.count() points 80 397 # 得分 80 的，有 397 条 81 692 ... 99 33 100 19 Name: points, Length: 21, dtype: int64 # points相同的分别分组，然后获取每组的最低价格 \u0026gt;\u0026gt;\u0026gt; reviews.groupby('points').price.min() points 80 5.0 # 80分的，最低可以以5.0的价格买到 81 5.0 ... 99 44.0 100 80.0 Name: price, Length: 21, dtype: float64 # 获取每个酒厂的第一条数据的title \u0026gt;\u0026gt;\u0026gt; reviews.groupby('winery').apply(lambda df: df.title.iloc[0]) # 获取每个国家和省份的评分最高的酒，`idxmax()`可以返回最大值的下标。 \u0026gt;\u0026gt;\u0026gt; reviews.groupby(['country', 'province']).apply(lambda df: df.loc[df.points.idxmax()]) Multi-indexes groupby有时候会用到多索引MultiIndex，可以用reset_index()把它转换成常规的索引。如果想要获取多列值，需要使用agg([])\n\u0026gt;\u0026gt;\u0026gt; countries_reviewed = reviews.groupby(['country', 'province']).description.agg([len]) \u0026gt;\u0026gt;\u0026gt; mi = countries_reviewed.index \u0026gt;\u0026gt;\u0026gt; type(mi) pandas.core.indexes.multi.MultiIndex \u0026gt;\u0026gt;\u0026gt; countries_reviewed.reset_index() Sorting sort_values()默认是升序排序，可以更改参数ascending=False来使其降序排序，\ncountries_reviewed = countries_reviewed.reset_index() countries_reviewed.sort_values(by='len') # 按值排序 countries_reviewed.sort_index() # 按index排序 # 以多个key排序，country为主键，country相同的时候内部按len排序 countries_reviewed.sort_values(by=['country', 'len']) Data Types and Missing Values Dtypes DataFrame或Series中某一列的数据类型（data type）称为 Dtype。\n\u0026gt;\u0026gt;\u0026gt; reviews.price.dtype # 返回 price 这一列的 Dtype dtype('float64') \u0026gt;\u0026gt;\u0026gt; reviews.dtypes # 返回每一列的Dtype country object description object ... variety object winery object Length: 13, dtype: object 使用astype()函数可以将一种类型的列转换为另一种类型：\n\u0026gt;\u0026gt;\u0026gt; reviews.points.astype('float64') 0 87.0 1 87.0 ... 129969 90.0 129970 90.0 Name: points, Length: 129971, dtype: float64 index也有自己的Dtype：reviews.index.dtype（dtype(\u0026lsquo;int64\u0026rsquo;)）\nMissing data 缺失值会自动被赋值NaN，它的Dtype始终是\u0026rsquo;float64\u0026rsquo;。pandas也提供了一些函数来用NaN筛选数据，比如pd.isnull()和pd.notnull()：\nreviews[pd.isnull(reviews.country)] # 筛选 country 值为 NaN 的数据 fillna()可以直接用某些值 比如\u0026quot;Unknown\u0026quot;替换NaN：\nreviews.region_2.fillna(\u0026quot;Unknown\u0026quot;) replace()函数可以把某列的\u0026quot;@kerinokeefe\u0026quot;替换成\u0026quot;@kerino\u0026quot;：\nreviews.taster_twitter_handle.replace(\u0026quot;@kerinokeefe\u0026quot;, \u0026quot;@kerino\u0026quot;) Renaming and Combining Renaming rename()可以用来修改列名或索引名，下面这个例子是：\n# 将列名中的'points'重命名为 'score' reviews.rename(columns={'points': 'score'}) # 将索引中的 0 重命名为 'firstEntry'，1 重命名为 'secondEntry' reviews.rename(index={0: 'firstEntry', 1: 'secondEntry'}) 行（rows）和列（columns）的名字也是可以更改的：\nreviews.rename_axis(\u0026quot;awines\u0026quot;, axis='rows').rename_axis(\u0026quot;fields\u0026quot;, axis='columns') Combining pandas有三种方法用来组合DataFrame（Series），concat()、join()和merge()。\ncanadian_youtube = pd.read_csv(\u0026quot;../input/youtube-new/CAvideos.csv\u0026quot;) british_youtube = pd.read_csv(\u0026quot;../input/youtube-new/GBvideos.csv\u0026quot;) pd.concat([canadian_youtube, british_youtube]) 就复杂性而言，最中间的组合器是join()，join()允许组合具有共同索引的不同DataFrame对象。 例如，要合并恰好在同一天在加拿大和英国流行的视频，我们可以执行以下操作：\nleft = canadian_youtube.set_index(['title', 'trending_date']) right = british_youtube.set_index(['title', 'trending_date']) left.join(right, lsuffix='_CAN', rsuffix='_UK') lsuffix和rsuffix是分别给left和right这两个DataFrame的列名加后缀的，因为这两个DataFrame中含有相同的列名，所以加上列名来避免冲突，如果已经提前为这两个DataFrame重命名过，保证没有列名的冲突，就可以不用设置这两个参数。\n","permalink":"https://slightwind.cn/posts/dataprocess/kaggle-courses-pandas/","summary":"Pandas Creating, Reading and Writing Creating data import pandas as pd pandas是最受欢迎的python数据分析包。pandas中有两个核心对象DataFrame和Series。\nDataFrame是一个表，由多个数组构成，这些数组常常作为表里面的列。使用pd.DataFrame()来实例化一个DataFrame对象，数据参数使用的是python中的dict，dict的key作为DataFrame的列名，dict的value是一个list，作为对应列的全部元素。\n\u0026gt;\u0026gt;\u0026gt; pd.DataFrame({'Yes': [50, 21], 'No': [131, 2]}) Yes No 0 50 131 1 21 2 \u0026gt;\u0026gt;\u0026gt; pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']}) Bob Sue 0 I liked it. Pretty good. 1 It was awful. Bland. 行的下标（通常称为索引(index)）默认和python的list一样，从0开始，也可以在构造时自定义\n\u0026gt;\u0026gt;\u0026gt; pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']}, index=['Product A', 'Product B']) Bob Sue Product A I liked it.","title":"Notes: Kaggle Courses - Pandas"},{"content":"由于参与了一个在 PLC 和上位机之间建立加密信道的项目，需要在PLC的Win7-32bit系统中安装OpenSSL和GmSSL，因为PLC硬盘太小，所以我实际上是在虚拟机里面进行的编译。\nOpenSSL 一开始是打算编译一下的，下载了OpenSSL的源码，OpenSSL的Configure是依赖Perl的。然后下载安装了Strawberry Perl for win32，然后发现会出现各种报错，一番搜索了解到需要安装ActivePerl：\nInstall ActivePerl and remove Stawberry Perl as it is not compatible with openssl.\n但是ActivePerl的官网只提供64bit的版本，安装32bit版本的ActivePerl需要支付$912/yr：\nThe site states: \u0026ldquo;if you need 32-bit or other older/legacy versions, they are available through our new ActiveState Platform by subscribing to at least Team Tier. See pricing here.\u0026rdquo;\n这就很难搞，只能去下载安装现成的二进制文件：http://slproweb.com/products/Win32OpenSSL.html\nGmSSL GmSSL官方的编译与安装教程虽然字数不多但是很有帮助，编译过程比较顺利。\n虽然也提及要用ActivePerl，但是我在对Configure进行了一点简单修改之后，用Strawberry Perl也可以成功运行perl Configure VC-WIN32。\n直接运行perl Configure VC-WIN32会遇到报错：\u0026quot;glob\u0026quot; is not exported by the File::Glob module。\n分别在Configure和test/build.info两个文件中，把：\nuse if $^O ne \u0026quot;VMS\u0026quot;, 'File::Glob' =\u0026gt; qw/glob/; 修改为：\nuse if $^O ne \u0026quot;VMS\u0026quot;, 'File::Glob' =\u0026gt; qw/:glob/; 就可以了，接下来如果不是在Visual Studio中直接make，会报错缺少stddef.h，这时需要启动VS中的CMD来进行编译，我的版本是VS Community 2017，需要手动配置一下VS的命令行环境。\n在Visual Studio中配置命令行环境 可以参考https://blog.csdn.net/u013553529/article/details/77417058\n工具(T) -\u0026gt; 外部工具(E)... -\u0026gt; 添加(A) -\u0026gt;\n标题: Terminal 自定义，设置好会显示在工具(T)下拉框中 命令: C:\\Windows\\System32\\cmd.exe cmd.exe的绝对路径 参数: /k \u0026quot;C:\\Program Files\\Microsoft Visual Studio\\2017\\Common7\\Tools\\VsDevCmd.bat\u0026quot; 英文引号中是VsDevCmd.bat的绝对路径 初始目录: $(ProjectDir) 自定义，打开cmd时的初始目录 -\u0026gt; 确定\n配置完成之后，就可以通过工具(T)-\u0026gt;Terminal来打开cmd，这时再进入GmSSL的目录下就可以make了，遇到了新的报错：无法解析的外部符号 EVP_get_ciphernames，这个问题在https://github.com/guanzhi/GmSSL/issues/1037 有提到解决方法，定位到EVP_get_ciphernames和EVP_get_digestnames，并把它们注释掉即可。\n/* char *EVP_get_ciphernames(int aliases); char *EVP_get_digestnames(int aliases); */ 现在就可以畅通无阻的make、make install了。\n配置环境变量 命令行调用gmssl环境变量：\n右键计算机-\u0026gt;属性-\u0026gt;高级系统设置-\u0026gt;环境变量-\u0026gt;系统变量Path-\u0026gt;编辑-\u0026gt;添加C:\\Program Files\\GmSSL\\bin;-\u0026gt;确定-\u0026gt;确定-\u0026gt;确定\ngcc/g++编译环境变量：\n变量 值 备注 PATH C:\\Program Files\\GmSSL\\bin; 命令行可执行文件 LIBRARY_PATH C:\\Program Files\\GmSSL\\lib; 编译时调用的lib C_INCLUDE_PATH C:\\Program Files\\GmSSL\\include; C程序#include\u0026lt;\u0026gt; CPLUS_INCLUDE_PATH C:\\Program Files\\GmSSL\\include; C++程序#include\u0026lt;\u0026gt; 编译时参数-lcrypto一直不能用，结果在C:\\Program Files\\GmSSL\\lib中把libcrypto.lib重命名为crypto.lib后成功解决，可以正常编译包含gmssl的c/cpp程序。\n","permalink":"https://slightwind.cn/posts/environment/install-openssl-and-gmssl-on-win32/","summary":"由于参与了一个在 PLC 和上位机之间建立加密信道的项目，需要在PLC的Win7-32bit系统中安装OpenSSL和GmSSL，因为PLC硬盘太小，所以我实际上是在虚拟机里面进行的编译。\nOpenSSL 一开始是打算编译一下的，下载了OpenSSL的源码，OpenSSL的Configure是依赖Perl的。然后下载安装了Strawberry Perl for win32，然后发现会出现各种报错，一番搜索了解到需要安装ActivePerl：\nInstall ActivePerl and remove Stawberry Perl as it is not compatible with openssl.\n但是ActivePerl的官网只提供64bit的版本，安装32bit版本的ActivePerl需要支付$912/yr：\nThe site states: \u0026ldquo;if you need 32-bit or other older/legacy versions, they are available through our new ActiveState Platform by subscribing to at least Team Tier. See pricing here.\u0026rdquo;\n这就很难搞，只能去下载安装现成的二进制文件：http://slproweb.com/products/Win32OpenSSL.html\nGmSSL GmSSL官方的编译与安装教程虽然字数不多但是很有帮助，编译过程比较顺利。\n虽然也提及要用ActivePerl，但是我在对Configure进行了一点简单修改之后，用Strawberry Perl也可以成功运行perl Configure VC-WIN32。\n直接运行perl Configure VC-WIN32会遇到报错：\u0026quot;glob\u0026quot; is not exported by the File::Glob module。\n分别在Configure和test/build.info两个文件中，把：\nuse if $^O ne \u0026quot;VMS\u0026quot;, 'File::Glob' =\u0026gt; qw/glob/; 修改为：","title":"Install OpenSSL and GmSSL on Win32"},{"content":"树莓派是个一直听说，但是一直没玩过的东西，所以在今年年初搞了一块折腾了一段时间。在上面起了一些服务，确实很好玩。在上面搭建了私有网盘、Minecraft、SageMath 还有几个密码学题目。这篇博客记录了我折腾树莓派的经历～\n解决公网IP问题 我想在公网连接到家里的树莓派，访问到上面的服务，所以需要有公网IP或者使用 frp 内网穿透。当然如果不需要让树莓派暴露在公网下，就不需要搞公网 IP 了。\n静态公网IP 如果有角度可以搞到企业专线，那还是很香的，不仅拥有运营商分配的静态公网 IP，还有上下行相等的大带宽，当然费用也很高，也需要注册的企业资质。所以我是搞不到静态的公网 IP。\n动态公网IP 没有静态的，可以退而求其次搞动态的，跟运营商交涉一下是可以得到动态的公网 IP 的，虽然是上下行不对等的家庭带宽，但是作为服务器来说绰绰有余，已经远超很多便宜的云服务器了。\n第一次我直接跟人工客服打电话申请要一个静态公网IP被拒绝了；然后第二天我又一次联系了人工客服，询问能不能申请动态的公网IP（可以说装摄像头要用到，不能说在家里搭建服务器），结果很快就回电通知我已经给了动态的公网IP，还算顺利～\nDynamic DNS 后面使用发现，我们这边的动态的公网IP大约2～3天变动一次，这就可以通过 Dynamic DNS（DDNS） 将动态的IP解析到固定的域名，就能通过固定的域名访问到服务器了。\nDDNS需要服务端和本地各运行一个服务：本地的树莓派或路由器上运行一个服务，每隔一段时间（几分钟）就获取一下自己的公网IP，判断一下有没有发生改变，如果发生改变就将新的 IP 发送给服务端，服务端得到新的 IP，就重新将域名解析到新的IP，所以是动态DNS。\nDDNS的服务端只提供域名的动态解析服务，所以服务端的带宽对访问树莓派的速度没有影响（但是可能会影响到延时？实际使用没有明显感觉到）\nDDNS服务：\n直接使用一些网站（oray.com/3322.org/Dyndns.com/No-ip.com）免费提供的DDNS服务，但是他们给的域名都是比较杂乱的三级域名，需要再把自己租的阿里云/腾讯云域名CNAME解析到这个三级域名。花生壳（oray.com）可以免费使用；而No-ip.com免费版需要每30天登录上去手动续约。 使用自己的vps运行脚本为树莓派提供DDNS服务，由于需要通过脚本进行域名解析，所以需要在vps上安装对应的SDK，然后开发对应的脚本，可以直接将自己的阿里云/腾讯云域名解析到家里的公网IP。 我现在是选择使用花生壳（oray.com）的DDNS服务，只需要注册即可得到一个三级域名，通过控制台-\u0026gt;域名-\u0026gt;壳域名来查看。我的路由器是小米 4A，可以在后台设置DDNS，选择“花生壳”并输入账号密码域名和检查 IP 的时间间隔即可。路由器不支持的话就需要在树莓派上运行一个脚本来发送新的IP。\n也有很多树莓派玩家通过每次变动IP时，让树莓派将新IP发送给自己的邮箱，使自己总是可以知道最新的IP地址。\nfrp内网穿透 如果也申请不到动态 IP，那就只能用 frp 做内网穿透了，需要借助一台有公网 IP 的 vps，流量也都需要经过这台 vps，所以享受不到家庭宽带的低价大带宽了。\n测试上下行带宽 可以在 speedtest.cn 测试下行带宽和上行带宽（最好直接连网线测）。\n从公网访问树莓派下载文件需要的是家里的上行带宽，而家庭宽带的上行都是很低的，只能去升级下行带宽，上行才能对应的提升一点。。。。所以如果感觉带宽不太够还是要去升级一下宽带的。\n我家的联通宽带就不太行，一开始是100M下行，20M上行，实测大约下行90~100M，上行20~40M。于是换了500M下行，50M上行的宽带，实测大约下行450～550M，上行60～70M。\n组装树莓派和安装Ubuntu 我的是树莓派 4B。启动树莓派还需要有 5V 3A 的电源和一张 TF 卡。\n各版本树莓派的对照表：https://shumeipai.nxez.com/wp-content/uploads/2017/03/raspberrypi-version-compare-4b.png\n然后就是愉快的组装环节，树莓派 PCB 边缘是有毛糙的，最好用砂纸磨光滑再装到壳子里。 写入Ubuntu镜像 树莓派支持安装很多种系统，我选择的是 Ubuntu Server 20.04.2 LTS 64-bit，可以在这里下载：https://ubuntu.com/download/raspberry-pi，先把镜像下载到本地，把 TF 卡插到读卡器里，再把读卡器插在这台电脑上。\n电脑上需要安装 balenaEtcher 来为 TF 卡写入 Ubuntu 镜像，balenaEtcher 支持 MacOS/Windows/Linux，可以在官网下载：https://www.balena.io/etcher/\n写入镜像过程很简单，跟着点就可以，下图这样就是写入成功了。 写入完成后不需要手动推出磁盘（TF 卡读卡器），可以直接拔掉，然后将 TF 卡插入树莓派即可。\n树莓派的 Wi-Fi 网卡性能较弱，而搭 NAS 比较需要速度，所以我直接给树莓派插上了网线。这时就可以直接通电了，树莓派会自动开机。\n内网SSH连接树莓派 现在就可以用电脑连接 Wi-Fi 并进入无线路由器的后台，应该可以看到连接路由器的所有设备的内网 IP 地址和MAC 地址，等待几分钟可以看到一个设备的名称是ubuntu，接入方式是网线连接，那么这个就是树莓派了。可以通过 ssh ubuntu@内网IP来连接树莓派，默认密码是ubuntu。\n公网SSH连接树莓派 接着可以设置一下路由器，为了防止树莓派的内网IP发生改变，需要在路由器后台，高级设置-\u0026gt;DHCP静态IP分配 把树莓派的MAC地址和当前的内网IP地址绑定起来。然后为了让公网对路由器的访问都转向树莓派，高级设置-\u0026gt;端口转发-\u0026gt;开启DMZ，把DMZ这边的IP地址设置为树莓派的内网IP地址。这样设置完成之后，就可以通过 ssh ubuntu@公网IP 来远程控制树莓派了，公网IP地址可以通过访问 http://testipv6.com/来查看。\n较为遗憾的是运营商一般会屏蔽掉80端口和443端口。。。所以如果在树莓派上起服务，只能通过端口访问，这个问题可以通过在一台有公网IP并且开着80端口的vps上配置Nginx反向代理来解决，不过这样的话流量还是要走vps，所以为了快速的下载上传文件，只能通过加着端口这种方法来访问了，不过好在最终速度理想。\n初始配置 在同一文件夹下备份默认的源：\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 编辑 /etc/apt/sources.list 并替换成下面的内容：（sudo vim /etc/apt/sources.list）\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse 然后更新：\nsudo apt update sudo apt upgrade 安装KodExplorer 私有云有很多种选择：seafile、nextcloud、KodExplorer 等，我使用的是 KodExplorer（可道云），比较美观并且可以创建低权限用户支持预览的格式也很多。\nKodExplorer 官网链接：https://kodcloud.com/，官网的文档很详细。\n为树莓派安装好 lamp 环境，然后将 KodExplorer 的文件夹放到 web 目录下即可，开放好对应的端口之后，我们就可以通过http://[域名]/[目录名]来访问到 KodExplorer 了。\n不过要注意的是，服务要开在其他开放了的端口（80，443 会被运营商屏蔽）。\n优化上传和下载的速度，可以按照这个方法操作一下：https://teddysun.com/489.html，速度提升非常明显。\n挂载硬盘 安装好 KodExplorer 之后，就可以上传下载文件了，不过是存到 TF 卡里的，作为 NAS 当然需要给树莓派外挂硬盘，树莓派上有两个 USB 3.0 接口和两个 USB 2.0 接口，可以在这里挂上移动硬盘或者是硬盘加硬盘盒。\n我使用的方法是给树莓派的 USB 3.0 接口插了一个硬盘盒，可以自己选择需要大小的硬盘放在硬盘盒里，缺点是硬盘需要 12v 的供电，而树莓派的 USB 3.0 仅有 5v，所以需要给硬盘盒外接一个 12v 电源，不是很优雅，但硬盘的容量选择很多。\n首先为了让树莓派支持ExFat和NTFS格式的硬盘，需要安装下面两个依赖：\nsudo apt-get install exfat-fuse sudo apt-get install ntfs-3g 然后就可以挂载硬盘了，插上硬盘之后可以 sudo fdisk -l 来查看到自己的硬盘，然后 df -h 查看已经挂载的磁盘，这时这里是没有自己的硬盘的。\nsudo mkdir /www/wwwroot/[站点名称]/nas sudo mount /dev/sda1 /www/wwwroot/[站点名称]/nas [站点名称]换成自己的站点名称。\n就可以通过 df -h 查看到已经挂载到这个目录的硬盘了，加载内核模块modprobe fuse，然后设置开机自动挂载，先 sudo vim /etc/fstab，然后在底部添加这一行：\n/dev/sda1 /www/wwwroot/[站点名称]/nas ntfs-3g defaults,nofail,noexec,umask=0000 0 0 安装SageMath 只需要一行命令，就可以在树莓派上安装好 SageMath 了，也可以很方便的为 SageMath 里的 Python 环境安装第三方包。\nsudo apt-get install sagemath --fix-missing sage -python3 -m pip install pycryptodome 用 sage exp.sage 来直接运行 sage 脚本。\n散热风扇改造 店家送的风扇只能直接连接树莓派的供电引脚，然后满转运行，我觉得这样很不优雅，至少应该像机箱的风扇一样，可以随着当前CPU温度改变转速，温度不太高的时候完全可以停下，可以尽可能的减小噪声，所以我开始动手改装了树莓派的风扇。\n在寻找合适的树莓派风扇的过程中，偶然发现一种很强劲的小风扇：悬浮轴承、18128RPM、5V、直径 3CM，这也太适合树莓派了，就选择它了。\n然后是写脚本来控制转速，要利用到树莓派可玩性最高的东西——GPIO，可以用 Python 写脚本，并且 GPIO 支持 PWM 输出，通过调节占空比来调节转速。\nimport RPi.GPIO as GPIO import os import time # Configuration PWM_BOARD_IN1 = 8 # BOARD pin used to drive PWM fan PWM_BOARD_IN2 = 10 # BOARD pin (keep it LOW except want the fan to reverse) WAIT_TIME = 1 # [s] Time to wait between each refresh PWM_FREQ = 25000 # [Hz] 25kHz for PWM control MIN_TEMP = 35 MAX_TEMP = 65 FAN_LOW = 5 FAN_HIGH = 100 TEMP_COEFFICIENT = float(FAN_HIGH - FAN_LOW)/float(MAX_TEMP - MIN_TEMP) def setFanSpeed(speed): fan.start(speed) def getCpuTemperature(): res = os.popen('cat /sys/class/thermal/thermal_zone0/temp').readline() return float(res)/1000 def handleFanSpeed(temperature): fanSpeed = round(FAN_LOW + (round(max(0, temperature-MIN_TEMP)) * TEMP_COEFFICIENT), 3) setFanSpeed(fanSpeed) with open(\u0026quot;fan_speed\u0026quot;, \u0026quot;w\u0026quot;) as f: f.write(str(fanSpeed)) try: GPIO.setwarnings(False) GPIO.setmode(GPIO.BOARD) out_list = [PWM_BOARD_IN1, PWM_BOARD_IN2] GPIO.setup(out_list, GPIO.OUT) GPIO.output(out_list, GPIO.LOW) fan = GPIO.PWM(out_list[0], PWM_FREQ) while True: handleFanSpeed(getCpuTemperature()) time.sleep(WAIT_TIME) except KeyboardInterrupt: setFanSpeed(50) 为了方便实时监控到树派的转速，脚本会一直吧速度写进fan_speed文件里，供另外一个程序获取。\n开发树莓派资源监控页面 资源监控这边希望可以看到树莓派的公网 IP、CPU 温度、CPU 的资源占用情况，ROM/RAM 的资源占用情况，风扇的转速。\n风扇的转速写在了文件里，并且实时更新，所以这边去获取一下即可。\n. ├── assets │ ├── css ├── images │ ├── js │ └── vendors ├── fan_control │ ├── fan_control.py │ └── fan_speed ├── pi_dashboard.py └── templates ├── assets │ ├── css │ ├── images │ ├── js │ └── vendors └── index.html 后端使用flask，前端用的是mazer组件库。\nfrom flask import Flask, render_template import os import re import requests app = Flask(__name__,template_folder='templates',static_folder=\u0026quot;assets\u0026quot;) def get_cpu_temperature(): try: res = os.popen('cat /sys/class/thermal/thermal_zone0/temp').readline() temp = float(res)/1000 return temp except: return \u0026quot;Error\u0026quot; def get_cpu_info(): try: res = os.popen(\u0026quot;top -bn1 1 | grep Cpu\u0026quot;).read() us = [float(i[:-3].strip(\u0026quot; \u0026quot;)) for i in re.findall(r\u0026quot;[0-9. ]*us\u0026quot;, res)] sy = [float(i[:-3].strip(\u0026quot; \u0026quot;)) for i in re.findall(r\u0026quot;[0-9. ]*sy\u0026quot;, res)] cpu_used = [round(x[0]+x[1], 1) for x in zip(us, sy)] assert len(cpu_used)==4 return cpu_used except: return [\u0026quot;Error\u0026quot; for _ in range(4)] def get_rom_info(Filesystem): '''return list: [Size, Used, Avail, Use%]''' try: res = os.popen(\u0026quot;df -h\u0026quot;).read() card_data = re.findall(Filesystem+\u0026quot;[0-9. KMG%]*\u0026quot;, res)[0].split()[1:] card_data = [i[:-1] if (i[-1]==\u0026quot;G\u0026quot; or i[-1]==\u0026quot;%\u0026quot;) else i for i in card_data] assert len(card_data)==4 return card_data except: return [\u0026quot;Error\u0026quot; for _ in range(4)] def get_public_ip(): try: res = requests.get(\u0026quot;http://members.3322.org/dyndns/getip\u0026quot;) return res.text.strip() except: return \u0026quot;Error\u0026quot; def get_intranet_ip(): try: res = os.popen(\u0026quot;hostname -i\u0026quot;).read().split(\u0026quot; \u0026quot;)[0] return res except: return \u0026quot;Error\u0026quot; def get_ram_info(): try: res = os.popen('free').read() ram_info = re.findall(\u0026quot;Mem:[0-9 ]*\u0026quot;, res)[0].split()[1:3] return [str(int(i)//1024) for i in ram_info] except: return [\u0026quot;Error\u0026quot; for _ in range(2)] def get_fan_speed(): try: with open(\u0026quot;fan_control/fan_speed\u0026quot;, \u0026quot;r\u0026quot;) as f: fan_speed = f.read() return fan_speed except: return \u0026quot;Error\u0026quot; @app.route('/') def dashboard_page(): context = { \u0026quot;cpu_used\u0026quot;:get_cpu_info(), \u0026quot;cpu_temp\u0026quot;:get_cpu_temperature(), \u0026quot;fan_speed\u0026quot;:get_fan_speed(), \u0026quot;ip_adress\u0026quot;:{\u0026quot;intranet\u0026quot;:get_intranet_ip(),\u0026quot;public\u0026quot;:get_public_ip()}, \u0026quot;ram\u0026quot;:get_ram_info(), \u0026quot;rom\u0026quot;:get_rom_info(\u0026quot;/dev/mmcblk0p2\u0026quot;), \u0026quot;external_storage\u0026quot;:get_rom_info(\u0026quot;/dev/sda1\u0026quot;) } return render_template('index.html', **context) if __name__ == '__main__': app.run(\u0026quot;0.0.0.0\u0026quot;, 82) # nohup gunicorn -w 4 -b 0.0.0.0:82 pi_dashboard:app \u0026amp; 感觉对我来说，树莓派是个比较有意思的玩具，折腾了一段时间学到了一些杂七杂八的东西，算是填补了一直以来对树莓派的好奇心。\n用树莓派跑了一些脚本，虽然可以 24h 稳定运行，但是性能差点意思，还有一些服务由于各种原因导致在树莓派上兼容不是很好。\n为了更强的性能、更稳定的运行一些服务，我后面又装了一台裸金属服务器～然后把树莓派挂咸鱼出掉了，由于树莓派在涨价，运行了半年的树莓派竟然没赔，理财产品了属于是。\n","permalink":"https://slightwind.cn/posts/environment/raspberrypi4b/","summary":"树莓派是个一直听说，但是一直没玩过的东西，所以在今年年初搞了一块折腾了一段时间。在上面起了一些服务，确实很好玩。在上面搭建了私有网盘、Minecraft、SageMath 还有几个密码学题目。这篇博客记录了我折腾树莓派的经历～\n解决公网IP问题 我想在公网连接到家里的树莓派，访问到上面的服务，所以需要有公网IP或者使用 frp 内网穿透。当然如果不需要让树莓派暴露在公网下，就不需要搞公网 IP 了。\n静态公网IP 如果有角度可以搞到企业专线，那还是很香的，不仅拥有运营商分配的静态公网 IP，还有上下行相等的大带宽，当然费用也很高，也需要注册的企业资质。所以我是搞不到静态的公网 IP。\n动态公网IP 没有静态的，可以退而求其次搞动态的，跟运营商交涉一下是可以得到动态的公网 IP 的，虽然是上下行不对等的家庭带宽，但是作为服务器来说绰绰有余，已经远超很多便宜的云服务器了。\n第一次我直接跟人工客服打电话申请要一个静态公网IP被拒绝了；然后第二天我又一次联系了人工客服，询问能不能申请动态的公网IP（可以说装摄像头要用到，不能说在家里搭建服务器），结果很快就回电通知我已经给了动态的公网IP，还算顺利～\nDynamic DNS 后面使用发现，我们这边的动态的公网IP大约2～3天变动一次，这就可以通过 Dynamic DNS（DDNS） 将动态的IP解析到固定的域名，就能通过固定的域名访问到服务器了。\nDDNS需要服务端和本地各运行一个服务：本地的树莓派或路由器上运行一个服务，每隔一段时间（几分钟）就获取一下自己的公网IP，判断一下有没有发生改变，如果发生改变就将新的 IP 发送给服务端，服务端得到新的 IP，就重新将域名解析到新的IP，所以是动态DNS。\nDDNS的服务端只提供域名的动态解析服务，所以服务端的带宽对访问树莓派的速度没有影响（但是可能会影响到延时？实际使用没有明显感觉到）\nDDNS服务：\n直接使用一些网站（oray.com/3322.org/Dyndns.com/No-ip.com）免费提供的DDNS服务，但是他们给的域名都是比较杂乱的三级域名，需要再把自己租的阿里云/腾讯云域名CNAME解析到这个三级域名。花生壳（oray.com）可以免费使用；而No-ip.com免费版需要每30天登录上去手动续约。 使用自己的vps运行脚本为树莓派提供DDNS服务，由于需要通过脚本进行域名解析，所以需要在vps上安装对应的SDK，然后开发对应的脚本，可以直接将自己的阿里云/腾讯云域名解析到家里的公网IP。 我现在是选择使用花生壳（oray.com）的DDNS服务，只需要注册即可得到一个三级域名，通过控制台-\u0026gt;域名-\u0026gt;壳域名来查看。我的路由器是小米 4A，可以在后台设置DDNS，选择“花生壳”并输入账号密码域名和检查 IP 的时间间隔即可。路由器不支持的话就需要在树莓派上运行一个脚本来发送新的IP。\n也有很多树莓派玩家通过每次变动IP时，让树莓派将新IP发送给自己的邮箱，使自己总是可以知道最新的IP地址。\nfrp内网穿透 如果也申请不到动态 IP，那就只能用 frp 做内网穿透了，需要借助一台有公网 IP 的 vps，流量也都需要经过这台 vps，所以享受不到家庭宽带的低价大带宽了。\n测试上下行带宽 可以在 speedtest.cn 测试下行带宽和上行带宽（最好直接连网线测）。\n从公网访问树莓派下载文件需要的是家里的上行带宽，而家庭宽带的上行都是很低的，只能去升级下行带宽，上行才能对应的提升一点。。。。所以如果感觉带宽不太够还是要去升级一下宽带的。\n我家的联通宽带就不太行，一开始是100M下行，20M上行，实测大约下行90~100M，上行20~40M。于是换了500M下行，50M上行的宽带，实测大约下行450～550M，上行60～70M。\n组装树莓派和安装Ubuntu 我的是树莓派 4B。启动树莓派还需要有 5V 3A 的电源和一张 TF 卡。\n各版本树莓派的对照表：https://shumeipai.nxez.com/wp-content/uploads/2017/03/raspberrypi-version-compare-4b.png\n然后就是愉快的组装环节，树莓派 PCB 边缘是有毛糙的，最好用砂纸磨光滑再装到壳子里。 写入Ubuntu镜像 树莓派支持安装很多种系统，我选择的是 Ubuntu Server 20.04.2 LTS 64-bit，可以在这里下载：https://ubuntu.com/download/raspberry-pi，先把镜像下载到本地，把 TF 卡插到读卡器里，再把读卡器插在这台电脑上。","title":"使用树莓派4B作为一台服务器"},{"content":"hxb 2021 crypto signin $n1/n2$ 的连分数展开是对 $q1/q2$ 的一个逼近，所以枚举连分数中的每一项，就可以得到 $q1, q2$ 了，分解之后正常进行 RSA 解密得到 flag。\nfrom Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime pk = (1150398070565459492080597718626032792435556703413923483458704675295997646493249759818468321328556510074044954676615760446708253531839417036997811506222349194302791943489195718713797322878586379546657275419261647635859989280700191441312691274285176619391539387875252135478424580680264554294179123254566796890998243909286508189826458854346825493157697201495100628216832191035903848391447704849808577310612723700318670466035077202673373956324725108350230357879374234418393233, 1242678737076048096780023147702514112272319497423818488193557934695583793070332178723043194823444815153743889740338870676093799728875725651036060313223096288606947708155579060628807516053981975820338028456770109640111153719903207363617099371353910243497871090334898522942934052035102902892149792570965804205461900841595290667647854346905445201396273291648968142608158533514391348407631818144116768794595226974831093526512117505486679153727123796834305088741279455621586989) c1, c2 = (361624030197288323178211941746074961985876772079713896964822566468795093475887773853629454653096485450671233584616088768705417987527877166166213574572987732852155320225332020636386698169212072312758052524652761304795529199864805108000796457423822443871436659548626629448170698048984709740274043050729249408577243328282313593461300703078854044587993248807613713896590402657788194264718603549894361488507629356532718775278399264279359256975688280723740017979438505001819438, 33322989148902718763644384246610630825314206644879155585369541624158380990667828419255828083639294898100922608833810585530801931417726134558845725168047585271855248605561256531342703212030641555260907310067120102069499927711242804407691706542428236208695153618955781372741765233319988193384708525251620506966304554054884590718068210659709406626033891748214407992041364462525367373648910810036622684929049996166651416565651803952838857960054689875755131784246099270581394) n1, n2 = pk e = 0x10001 def getRoot(x, n): high = 1 while high ** n \u0026lt;= x: high *= 2 low = high//2 while low \u0026lt; high: mid = (low + high) // 2 if low \u0026lt; mid and mid**n \u0026lt; x: low = mid elif high \u0026gt; mid and mid**n \u0026gt; x: high = mid else: return mid return mid + 1 # https://github.com/pablocelayes/rsa-wiener-attack def rational_to_contfrac(x, y): a = x//y pquotients = [a] while a * y != x: x, y = y, x-a*y a = x//y pquotients.append(a) return pquotients def convergents_from_contfrac(frac): convs = [] for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0:i])) return convs def contfrac_to_rational(frac): if len(frac) == 0: return (0, 1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac)-1, -1): num, denom = frac[_]*num+denom, num return (num, denom) frac = rational_to_contfrac(n1, n2) convergents = convergents_from_contfrac(frac) p1, p2 = None, None for (P1, P2) in convergents: gcd1, gcd2 = GCD(P1, n1), GCD(P2, n2) p1 = gcd1 if (gcd1.bit_length() \u0026lt;= 128 and isPrime(gcd1)) else p1 p2 = gcd2 if (gcd2.bit_length() \u0026lt;= 128 and isPrime(gcd2)) else p2 print(f\u0026quot;[+]p1: {p1}\u0026quot;) print(f\u0026quot;[+]p2: {p2}\u0026quot;) q1, q2 = getRoot(n1//p1, 4), getRoot(n2//p2, 4) phi1 = (p1-1)*(q1-1)*q1**3 phi2 = (p2-1)*(q2-1)*q2**3 m1 = pow(c1, inverse(e, phi1), n1) m2 = pow(c2, inverse(e, phi2), n2) flag = (long_to_bytes(m1)+long_to_bytes(m2)).decode() print(f\u0026quot;[~]flag: {flag}\u0026quot;) ''' [+]p1: 181856133933383097933223133658050179553 [+]p2: 196443958511498599913330690975430421229 [~]flag: flag{8ef333ac-21a7-11ec-80f1-00155d83f114} ''' fastOT Python 的random的内部是MT19937 伪随机数生成器，虽然生成的随机数周期很大，但是内部状态（state）很少，仅仅有 624 个，每个值都是 32bit 的。\n这题给了足够的交互次数，题目中选项 1 里生成的m列表刚好是 8 个 32bit 的随机数，所以如果每次都能得到m列表，那么只需要交互 $624/8=78$ 次就可以得到全部的内部状态了，然后就能回推前面的随机数了。primate_key就是在前面生成的随机数。\n为了得到m，需要对发送的内容构造一下，我们期望返回的结果也就是解密的结果对我们来说是已知的，服务端会对我们的消息分别用 $d_1, d_2$ 进行解密，所以发送的消息可以是 $c = m^{e_1\\cdot e_2} \\bmod n$，$m$ 可以是任意的已知明文，这样 $d_1$ 解密后的是 $c_2 = m^{e_2} \\bmod n$，$d_2$ 解密后的是 $c_1 = m^{e_1} \\bmod n$，$c_2, c_1$ 都是已知的，那么只需要异或一下就能得到m列表了。\n有了所有的内部状态，也同样可以预测后面的值，每次的cur_rand都可以预测出来了，那么就可以解密得到 flag 了。\nfrom Crypto.Util.number import * from hashlib import sha256 from Crypto.Cipher import AES from tqdm import tqdm from pwn import * r = remote(\u0026quot;127.0.0.1\u0026quot;, \u0026quot;9999\u0026quot;) e1, e2 = 65537, 92431 msg = 1175078221 def unshift(value, key, mask=None, nbits=32, direction=\u0026quot;right\u0026quot;): maxn = (1 \u0026lt;\u0026lt; nbits) - 1 if not mask: mask = (1 \u0026lt;\u0026lt; (nbits + 1)) - 1 i = 0 if direction == 'right': while i * key \u0026lt; nbits: part_mask = ((maxn \u0026lt;\u0026lt; (nbits - key)) \u0026amp; maxn) \u0026gt;\u0026gt; (i * key) value ^= ((value \u0026amp; part_mask) \u0026gt;\u0026gt; key) \u0026amp; mask i += 1 return value elif direction == 'left': while i * key \u0026lt; nbits: part_mask = ((maxn \u0026gt;\u0026gt; (nbits - key)) \u0026amp; maxn) \u0026lt;\u0026lt; (i * key) value ^= ((value \u0026amp; part_mask) \u0026lt;\u0026lt; key) \u0026amp; mask i += 1 return value else: raise ValueError(\u0026quot;Invalid direction: %s, direction must be 'left' or 'right'.\u0026quot; % direction) def getState(number): number = unshift(number, 18, direction=\u0026quot;right\u0026quot;) number = unshift(number, 15, mask=0xefc60000, direction=\u0026quot;left\u0026quot;) number = unshift(number, 7, mask=0x9d2c5680, direction=\u0026quot;left\u0026quot;) number = unshift(number, 11, direction=\u0026quot;right\u0026quot;) return number def backtrace(numbers): assert(len(numbers) == 624) state = [] for number in numbers: state.append(getState(number)) return state def getOldStates(states): for i in range(3, -1, -1): tmp = states[i + 624] ^ states[i + 397] if tmp \u0026amp; 0x80000000 == 0x80000000: tmp ^= 0x9908b0df res = (tmp \u0026amp; 0x40000000) \u0026lt;\u0026lt; 1 tmp = states[i - 1 + 624] ^ states[i + 396] if tmp \u0026amp; 0x80000000 == 0x80000000: tmp ^= 0x9908b0df res |= 1 res |= (tmp \u0026amp; 0x3fffffff) \u0026lt;\u0026lt; 1 states[i] = res def add(x, y): assert y.bit_length() \u0026gt;= 128 return (x + y) ^ (x \u0026gt;\u0026gt; 53) def get_m(message): m0_list, m1_list = [], [] m0, m1 = int(message[0]) ^ pow(msg, e2, n), int(message[1]) ^ pow(msg, e1, n) for _ in range(4): m0_list.append(m0 \u0026amp; ((1 \u0026lt;\u0026lt; 32) - 1)) m0 \u0026gt;\u0026gt;= 32 m1_list.append(m1 \u0026amp; ((1 \u0026lt;\u0026lt; 32) - 1)) m1 \u0026gt;\u0026gt;= 32 m0_list.reverse() m1_list.reverse() return m0_list + m1_list def choice_1(): r.sendlineafter(b'choice\u0026gt;', b'1') r.sendlineafter(b\u0026quot;\\n\u0026quot;, hex(pow(msg, e1 * e2, n))[2:].encode()) r.recvuntil(b\u0026quot;Your message is (\u0026quot;) message = r.recvline().decode().strip()[:-2].split(\u0026quot;L, \u0026quot;) return get_m(message) def choice_2(): r.sendlineafter(b'choice\u0026gt;', b'2') r.sendlineafter(b\u0026quot;\\n\u0026quot;, hex(pow(msg, e1, n))[2:].encode()) r.recvuntil(b\u0026quot;Your cipher is: \u0026quot;) return r.recvline().decode().strip() def get_datalist(): datalist = [] for _ in tqdm(range(78)): datalist += choice_1() assert len(datalist) == 624 return datalist r.recvuntil(b\u0026quot;Your pubkey is: \u0026quot;) n = int(r.recvline().decode().strip().replace('L', '')[2:], 16) print(f\u0026quot;[+] n: {n}\u0026quot;) datalist = get_datalist() states = [0]*4 + backtrace(datalist) getOldStates(states) random.setstate(tuple([3, tuple(states[:624] + [0]), None])) primate_key = random.getrandbits(128) print(f\u0026quot;[+] primate_key: {primate_key}\u0026quot;) for _ in range(624): random.getrandbits(32) c = choice_2() print(f\u0026quot;[+] cipher is: {c}\u0026quot;) t = (pow(pow(msg, e1, n), e1, n), pow(pow(msg, e1, n), e2, n)) cur_rand = random.getrandbits(128) cur_k = t[cur_rand \u0026amp; 1] ^ cur_rand key = sha256(long_to_bytes(add(primate_key, cur_k))).digest()[:16] aes = AES.new(key, AES.MODE_ECB) flag = aes.decrypt(bytes.fromhex(c)).decode() r.close() print(f\u0026quot;[~] flag: {flag}\u0026quot;) hxb 2020 crypto 古典美++ 在 https://www.guballa.de/vigenere-solver 上解密，得到 key 是orderby。\nfrom hashlib import md5 print(md5(b\u0026quot;ORDERBY\u0026quot;).hexdigest()) 得到flag：c82bbc1ac4ab644c0aa81980ed2eb25b\n简单的密码3 only admin can get flag Menu: 1) login 2) edit 3) flag 交互一下可以发现能修改iv，并且发送的用户名会和name:一起拼起来并加密，结合only admin can get flag可以猜测，如果解密后是name:admin就可以得到 flag 了，直接登陆 admin 也是不行的，只能通过修改iv来改变解密结果。\n这里只需要观察解密过程最左侧的一块即可，密文经过key的解密后，异或iv，得到明文。\n如果我们设置的用户名为1234567890，我们可以用name:1234567890异或当前的iv，得到key解密后的中间量，然后异或我们期望的明文name:admin即可。\nnewiv = iv ^ \u0026quot;name:1234567890\u0026quot; ^ \u0026quot;name:admin\u0026quot; from Crypto.Util.number import * iv = \u0026quot;\u0026quot; iv = bytes.fromhex(iv) def xor(x, y): return b''.join([long_to_bytes(x[i]^y[i]) for i in range(len(x))]) def pad(x): return x+long_to_bytes(16-len(x))*(16-len(x)) payload = pad(b\u0026quot;name:admin\u0026quot;) plaintext = pad(b\u0026quot;name:1234567890\u0026quot;) # newiv = iv ^ plaintext ^ payload print(xor(xor(iv, plaintext), payload).hex()) LFSXOR 明文是由长度为512字节的随机字符串和 flag 拼接起来的。加密脚本使用两个不同的 LSFR，分别生成了k4、k5两个密钥，并将用它们分别加密这同一段明文。\n枚举全部的 k4 和 k5 的组合 pylfsr是一个可以自定义反馈函数的 lfsr 伪随机数生成器，L4和L5分别是定义在 $f = x^4 + x^3 + 1$ 和 $f = x^5 + x^4 + x^2 + x +1$ 上的 LFSR，初始状态都是随机的，周期分别为 15 和 31（因为全为 0 的状态不允许出现，所以是 $2^k-1$），初始状态也是 15 或 31 个中的其中一个。\n由于它们周期都很小，初始状态也完全可以枚举，$15\\cdot 31$ 种情况很容易爆破，对于每一组确定的初始状态，可以开始用它来生成 $k_4,k_5$，一共只有 $15\\cdot 31$ 组 $k_4,k_5$，但是问题在于加密之前又将 $k_4, k_5$ 乱序了，所以接下来要想办法恢复 $k_4,k_5$ 正确的顺序。\n获取乱序后的 k4 和 k5 可以利用前面提到的，乱序后的 $k_4,k_5$ 最终被用来加密同一段明文了，进行的是异或操作，所以对于一个字节的密文：\n$$c_{1i} = k_{4i} \\oplus m_i \\ c_{2i} = k_{5i} \\oplus m_i$$\n所以可以利用 $c_{1i} \\oplus k_{4i} = c_{2i} \\oplus k_{5i} = m_i$ 来缩小当前位置是正确字节的可能，因为对于 $k_4$ 中的随机一个字节 $k_{4i}$ 和 $k_5j$ 中的随机一个字节 $k_{5k}$，刚好能异或对应位置 $c_{1i}, c_{2i}$ 得到相同结果的可能性并不高，在这个很小的范围中依次取一组信任，继续往下递归，直到这组 $k_4, k_5$ 一直可以满足条件，那么就用它们来解密。\nfrom Crypto.Util.number import * from pylfsr import LFSR enc1 = b'\\xbb\\xd3\\x08\\x15\\xc6:\\x08\\xb2\\xb2\\x9f\\xe4p\\xc7\\xec\\x7f\\xfd)\\xf6f\\x9c\\xe4\\xd12\\xaeJ\\x81\\xb1\\x88\\xab\\xa5V\\xa9\\x88\\x14\\xdf`~\\xf6\\xdbJ\\xb4\\x06S!0\\xbb\\xe4\\x1a\\xe6R\\x8e\\x84X\\x19K\\x95\\x07C\\xe8\\xb2\\'\\xa9\\x80\\x15\\xec\\x8f\\x8dY\\nK\\x85\\x99\\xb7!\\x134\\xa9\\xb6\\x15\\xcf\u0026amp;\\r\\x9b\\xe1\\x99\\xe4]3h~\\xf0\\xa9\\xa5\\x14\\xee}\\xd19l\\x14h\\x07v *a0\\x12\\x14\\xfe\\x0f\\x05\\xdem\\x1d\\xe4s2J\\x7f\\xc28\\xf6RR\\x8e\\xba\\xb2m\\x18M\\xf1\\xef!4\\x17\\xa8\\xb4\\x14\\xc2\\x8f\\xb9Y:K\\xaa\\x06T!\\x1b\\xbb\\xfd\\xf6Gv\\x8e\\x9a\\xeb\\xd9K\\xbb\\x06N\\x9a\\x82c\\xa9\\xa0\\x14\\xed!\\x04\\xdbm\\x13\\xe5w3B\\x7f\\xd0\\xa9\\xbf\\xb7\\x9c\\xe3\\xd00\\x83K\\x86\\xab3\\x7f\\xc1\\xbb\\xfd\\x11\\x15\\xdf\\x8e\\x80Y\\x07\\xd8\\xe5]2m\\xe9\\xbb\\xce`\\x91o\\x8f\\x8cY!\\x81\\xe4J\\x92\\x8c\\xa7T\\x16E\\x15\\xf1WMY(\\xb8[\\x8e2y~\\xcbM\\x10\\x15\\xc7\\x1fWY\\x0cK\\x87\\xce\\xe5 !b\\xa8\\x83\\x14\\xec6\\xd1!\\xc8\\x905\\xe52L\\xf1\\xba\\xcf\\n\\x9d\\x9d\\xe7u\\xadm\\x06\\xe4n2r\\xd8\\xba\\xed\\xf6\\x7f\\x9d\\xd8\\xd02m\\x12G\\x07Y\\x89\\x7f\\xc0\\xa8\\xa4\\x15\\xe5\\x043Y\\x1eJ\\xae\\x07n\\x94\\x87\\xbb\\xcf_\\x8d\\x9d\\xd1\\x14Y,\\x9e\\xe5b\\xd7\\x8c\\x7f\\xf7\\xa8\\x8f\\x14\\xc7\\x8f\\xb3\\xb6\\xf1\\x93\\xe4O\\xdd\\xc4\\xdb\\xba\\xf6!\\x15\\xfd.\\xd1\\x18\\xcf\\xf6\\x03\\xea2E\\x7f\\xe1\\xa9\\xa5\\xfe\\x9d\\xc9\\xd1;\\xd9\\xee\\x05\\x06z\\xc8\\xb2\\xbb\\xe2\\xf7{JW4\\xcdm\\x1a\\xe5U\\x8d \\x0f\u0026amp;\\x14\\x7f\\xf6\\x9d\\xd4E\\xbf\\xc3\\xdb\\xe4L\\xe1\\xf7\\x90\\xbb\\xdaZ\\xf4\\x9d\\xd13\\xb8m3\\xe2D3o~\\xf8H\\xf6U*\\x07lY\\x03K\\xab\\x07~\\xa3\\x87\\xbb\\xc9\\xf7sAQ\\x08Y6J\\x86\\x07Y\\xec\\xf7\\xbb\\xc6s\\x15\\xc6\\x7fEY\\x02J\\x95\\x07Z \\x11\\xbb\\xc6T\\x15\\xfc-\\xd0\\x06\\xe6\\x9f-\\x07^ \\x15\\xbb\\xccz\\x14\\xf3\\x8f\\x97\\xd4l9t\\x85\\xe8\\x8a\\xbe\\xbb\\xf9\\xf6f\\x9d\\xf2\\xd19\\xa2K\\xb6\\xcd\\xcf\\xf6~\\xd5\\xa9\\xaa\\x15\\xd8\\x8e\\xb3\\x81m9\\xe4f\\xb2!\\x1e\\xba\\xd8s\\xfd\\x11\\x08W\\xa1l;\\x01\\x07_!\\x11\\xbb\\xdd\\xf6x\\x9d\\xf0\\x17Y\\x15\\xfe\\x02\\xc7\\xa0!.W\\xa9\\xa5\\x8f\\x9c\\xe8\\xd1\\x12m\\x04\\xe5s3Q~\\xdd\\xa9\\xa3\\x15\\xdb\\x8f\\xac\\xaf\\xec\\xbb\\x10\\xde2_\\xba\\xba\\xe8\\xf6f.\\x1e\\xd1\\x17l\\x06\\xe4U\\xdd\\xf0\\xd6~\\x0fA\\x14\\xcb\\x8e\\xb0Y\\x1fJ\\xb2\\xe4\\xb3!\u0026quot;\\xba\\xfeU\\x14\\xedY\\xd0\u0026gt;l-~\\x06P 1\\xbb\\xf2\\xf6waD\\xd1(m\\x12`\\x06@\\xb6~\\xfa\\xa9\\xb1\\xb0\\x9d\\xfb\\x18\\xfbm\u0026amp;\\xe4v2w\\xce\\xba\\xcbo\\xd5\\x07\\x11QX\u0026lt;J\\xbd\\xb22O\\x7f\\xd8x\u0026gt;\\xc8\\x9c\\xd3\\xd03\\x9d\\xb5\\x1e\\xd72S\\xf2ry\\xf1W\\x9c\\xc89Y\\rK\\x8f\\xff\\x8a\\xe0\\xb5{\\xa9\\xae\\xb1\\x9d\\xdd\\xd1=\\xbeK\\xa3\\x06e!\\x08\\xba\\xd2\\xf6j\\x9c\\xf6\\xd0\\x0fl#\\xe5o\\xf5\\xaa~\\xc2\\xa9\\x99\\x15\\xea6\\xd1:\\xe7\\xa8\\xe4n\\xbb \\nV\\xa9\\x91\\x14\\xf9}\\xd0!m/\\xe5|2o\\x81\\xba\\xf8\\r\\x14\\xeb\\tR\\xc9\\xec\\xdd`\\xbf\\xc6\\x81\\xdfKXW\\xb3o.%\\xa9\\xcd\\xb9\\x14\\xfd\\x97\\x83\\x8eO\\n\\x03\\xb6iuu\\xab\\x9d\\xbc\\x15\\xf4\\xc3\\xd6\\xc1' enc2 = b'p\\xfd\\x1ff\\xcaB\\xa5\\xe6`\\x87\\xa8\\x8ci\\x855\\x92O8P\\xa5}^\\xd8\\xed\\x1a\\x88=c\\xe0\\x9f\\xedq\\xf8\\xe1%\\x7fX\\xd2\\xba\\xbe\\x03\\xa8\\x9a\\x9c\\x075\\x98\u0026quot;\\xca\\xed\\xa4C^\\xc6.j\\xec\\xfa\\x10\\xa7\\xd9\\x01\\x06\\x87\\x90f\\xcc\\xf6\\x1b\\x0c\\xde\\xcc,\\xfb\\xf0\\xc74\\x94\\xcfj\\x8ay\\xd5\\xd2`.@\\xed\\xc2\\xd8!DSp\\xf5\\x12f\\xf1\\xf6#\\x80\\xbe\\x16\\xa8\\xaeF\\xd0\\xd1\\xd4\\xad\\xb9\\xf7#\\x16\\x08\\xb2[\\x1a\\x87\\x8b\\xa0\\xfaEF\\xbf\\x86\\x8b\\x8c\\x90\\xa4\\xd5\\xfbcR\\xe2W\\x9c\\n5\\x8b\\xcfQ\u0026quot;\\xf2\\x16\\x10\\xb2I\\x1a\\x88\\x8b\\x8cj\\x16\\xebp\\xccS\\xd2\\x90\\xa8|q\\x05\\xafq\\xfa\\xcaHE{\\x1a\\xba#\\xfd\\x17/\\xb2L\\x1a\\x87\\x8a\\x90\\xc9Dmp\\xef\\x0ef\\xf2Z|S\\x00R\\xfc\\x1c\\x9d\\n5\\x84\\xceS\\xb0\\xa4M_\\xff\\xb9\\x1a\\x8a\\x1d\\\\\\x98D\\\\p\\xcb*f\\xdcV\\xd0\\xd5Q\\xec\\x1a\\xfa\\xf0\\x91\\xa8\\xd4\\x8a\\xca\\x9c-\\x17\\x07\\xb2_\\xff\\n\\x8a\\x83\\xfb\\xc2\\x00\\x10\\x87\\x83\\xaeF\\xf7#\\xd4\\xbe\\'\\xa9\\x8a$IMp\\x14\\xe8\\xc0\\xa4z\\xd1\\xb2H\\xe6e\\x8b\\xb0\\xcf\\xb1\\x01\u0026lt;\\x87\\x88g\\xc2Q|H\\xbe9\\xa9\\xad\\x9c#4\\x8cl8I\\x0c\\x17$\\xb3}\\x1b\\x94\\x01:j7\\x00;\\x86\\xbd\\xd2i\\xf6\\x1a\\xa4\\'R\\xf6?\\x9c\\x08\\xe1\\xd4\\xab\\xdd\\x8f\\xa4[_\\xca/@\\xed\\xe86\\xf7\\x9c\\x018i\\x04\\xc3\\x90\\xa8\\xaa\\x0c\\xde\\xf2\\xa8\\xba?\\xf4\\xd39\\xce\\\\\u0026quot;\\xfe\\x16\\x0cY/]\\xed\\xe9l\\xce\\xa5\\x018o,g\\xdb\\xf7\\x12\\xdag\\xb6=\\xfa\\xccHgk\\xcfH\\xbf\\x18\\x9e\\xbd\\xb3u\\x8f\\n$Hk\\x0e\\xd3\\xa6i\\xe1\\x15=\\x16}R]\\xb3\\xa8\\x82\\x9b\\x0b4\\x9a\\xcf{\\xc2\\xa4V\\xe8:\\x93\\x1a\\x83\\x8a\\x97j\\t\\x82\\x88\\x86\\x80f\\xf6*\\xa2\\xd5\\xbe\\x08\\xa9\\x98\\x9c#\\xf8\\\\\\xceV\\xa7\\xa5L\\xae\u0026amp;/t\\xec\\xfb\\xd9\\x02Dnp\\xe8Cf\\xf0U}R4\\x87a\\xfb\\xf0I_\\xd4\\xaa\\xb4\u0026quot;\\xca\\x16\\x18\u0026gt;/i}\\t\\x03\\xc1\\x84\\x00!\\x86\\x93g\\xed\\xf7\\x1d\\xc3\\xbf\\x01c\\x06KI[\\xd5\\x929g\\xa4t\\x87\\xb2\\\\\\x1b\\x8d\\x0b\\xd9\\x0bDp\\xf5om\\xe1\\x16\\x0e}|ZR\\xc4\\xfb\\xf2H@\\xd4\\xa28\\\\c\\x17\u0026amp;\\x07\\xc8\\xda~\\x8b\\x88\\x86DS\\xeb\\x87\\x87f\\xda\\xf73\\r\\xcaS\\xd9\\xfa\\xfaI`\\xd5\\x889^R\\x97\\xaeF\\xf6\\x1a\\x92N\\xd8*Er\\xc3\\x16\\xe0)\\x91\\xba|_Q\\x83\\x00\u0026gt;;\\xff5\\x82\\xceX\u0026quot;\\xd7\\x17\\x08P\\xae\\x1a\\xb1\\x8a\\x8f\\xc9Ep\\xa7\\x86\\x86g\\xf6m|o\\xbf\\x1c\\xa9\\xa1\\x9c+\\xc9\\x1e\\xcfI#\\xfc\\x92^\\xc1\\xb8\\x1b\\xad\\x8a\\x9e\\xceEu\\xb8$\\xe0\\x0b\\x90\\x87}[\\x0fS\\xcab]\\xd2\\xaaU\\xcfh\u0026quot;\\xfc\\xa2_\\xdd/y\u0026lt;C\\x05k\\x18\\x00\\x1aw\\x1e\\x9cA\\xf6\\x0f\\x80w\\x83\\xae\\xb8\\x9d\\x0e\\xdc\\xd4\\xaf9H\\\\\\xaf\\x9ey\\xef\\x1b\\xb4.\\xd99Dd\\xa2\\x87\\xa7f\\xc6\\xf6\\n\\x0c\\xc4R\\xd7\\xfa\\xe4Hc\\xd4\\xa78Jc\\x9c^\\xca.u\\xed\\xfcak\u0026amp;\\x8b\\x92\\x87\\x88\\xee\\x90\\x83\\x90\\x0c\\xd9R\\xcd\\x08\\x9c04\\xb1\\xceC\u0026quot;\\xea\\xe9^\\xe3\\xd4\\x1a\\x9a\\x0c[\\xfa\\xc5\\x97\\xf5\u0026gt;\\x15\\xc71\\x06\\x8d\\xac\\x19\\xa0\\t\\x0el\\xe9\\xc6%4\\x9d\\x80U\\xe3\\xfdF\\x8d\\xee\\x17.+\\x9b\\xb3\\xf0\\x83w\\x16\\xd9' enc1 = list(enc1) enc2 = list(enc2) # 如果候选随机顺序的密钥，和当前定好顺序的密钥 含有相同数量的相同字节Int，那么就需要排除掉这个字节，不需要再对这个字节进行处理 def counter(Lis1, Lis2, Int): return sum([int(i == Int) for i in Lis1]) == sum([int(i == Int) for i in Lis2]) ''' 对于每一次递归的开始，k4 k5被认定是正确的密钥，但是顺序不对 ir 是当前递归的深度（用于判断的第i个密文字节） ''' def dfs(nk4, nk5, k4, k5, ir): if ir == 300: print(\u0026quot;k4 =\u0026quot;, nk4) print(\u0026quot;k5 =\u0026quot;, nk5) content = b''.join([long_to_bytes(nk4[i % len(nk4)] ^ enc1[i]) for i in range(len(enc1))]) print(content) exit(0) if len(nk4) \u0026lt; 15 and len(nk5) \u0026lt; 31: for k4i in k4: # 15 if counter(nk4, k4, k4i): continue for k5i in k5: # 31 # 如果使用k4中的一个值 和 k5中的一个值和当前密文字节异或结果相同，那么可以继续往下递归 if (k4i ^ enc1[ir]) == (k5i ^ enc2[ir]): if counter(nk5, k5, k5i): continue dfs(nk4+[k4i], nk5+[k5i], k4, k5, ir+1) return if len(nk4) == 15 and len(nk5) \u0026lt; 31: for k5i in k5: if (nk4[ir % 15] ^ enc1[ir]) == (k5i ^ enc2[ir]): if counter(nk5, k5, k5i): continue dfs(nk4, nk5+[k5i], k4, k5, ir+1) return if len(nk4) == 15 and len(nk5) == 31: if (nk4[ir % 15] ^ enc1[ir]) == (nk5[ir % 31] ^ enc2[ir]): dfs(nk4, nk5, k4, k5, ir+1) return for i in range(2**4): ini = [int(r) for r in list(\u0026quot;0\u0026quot;*(4-len(bin(i)[2:]))+bin(i)[2:])] L4 = LFSR(fpoly=[4, 3], initstate=ini, verbose=True) data = L4.runFullCycle() k4 = b\u0026quot;\u0026quot; for _ in range(len(data)): a = b'' for _ in range(8): a += str(L4.next()).encode() k4 += long_to_bytes(int(a, 2)) k4 = list(k4) for ii in range(2**5): iini = [int(r) for r in list(\u0026quot;0\u0026quot;*(5-len(bin(ii)[2:]))+bin(ii)[2:])] L5 = LFSR(fpoly=[5, 4, 2, 1], initstate=iini, verbose=True) data = L5.runFullCycle() k5 = b\u0026quot;\u0026quot; for _ in range(len(data)): a = b'' for _ in range(8): a += str(L5.next()).encode() k5 += long_to_bytes(int(a, 2)) k5 = list(k5) dfs([], [], k4, k5, 0) # DASCTF{7cc33bd1c63b029fa27a6a78f1253024} Offline CTF (travel) 2021 密码正常 ak，signin 硬推了一会儿没想起用连分数，都被打烂了才交 flag；fastOT 三血，进了决赛。不过现在由于疫情，可能会去不成长沙。\n线下赛：疫情，寄了\n2020 线上赛密码ak，队友输出很猛，成功进决赛。\n线下赛去了湖南，留影记念。\n","permalink":"https://slightwind.cn/posts/ctf/huxiangbei2021/","summary":"hxb 2021 crypto signin $n1/n2$ 的连分数展开是对 $q1/q2$ 的一个逼近，所以枚举连分数中的每一项，就可以得到 $q1, q2$ 了，分解之后正常进行 RSA 解密得到 flag。\nfrom Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime pk = (1150398070565459492080597718626032792435556703413923483458704675295997646493249759818468321328556510074044954676615760446708253531839417036997811506222349194302791943489195718713797322878586379546657275419261647635859989280700191441312691274285176619391539387875252135478424580680264554294179123254566796890998243909286508189826458854346825493157697201495100628216832191035903848391447704849808577310612723700318670466035077202673373956324725108350230357879374234418393233, 1242678737076048096780023147702514112272319497423818488193557934695583793070332178723043194823444815153743889740338870676093799728875725651036060313223096288606947708155579060628807516053981975820338028456770109640111153719903207363617099371353910243497871090334898522942934052035102902892149792570965804205461900841595290667647854346905445201396273291648968142608158533514391348407631818144116768794595226974831093526512117505486679153727123796834305088741279455621586989) c1, c2 = (361624030197288323178211941746074961985876772079713896964822566468795093475887773853629454653096485450671233584616088768705417987527877166166213574572987732852155320225332020636386698169212072312758052524652761304795529199864805108000796457423822443871436659548626629448170698048984709740274043050729249408577243328282313593461300703078854044587993248807613713896590402657788194264718603549894361488507629356532718775278399264279359256975688280723740017979438505001819438, 33322989148902718763644384246610630825314206644879155585369541624158380990667828419255828083639294898100922608833810585530801931417726134558845725168047585271855248605561256531342703212030641555260907310067120102069499927711242804407691706542428236208695153618955781372741765233319988193384708525251620506966304554054884590718068210659709406626033891748214407992041364462525367373648910810036622684929049996166651416565651803952838857960054689875755131784246099270581394) n1, n2 = pk e = 0x10001 def getRoot(x, n): high = 1 while high ** n \u0026lt;= x: high *= 2 low = high//2 while low \u0026lt; high: mid = (low + high) // 2 if low \u0026lt; mid and mid**n \u0026lt; x: low = mid elif high \u0026gt; mid and mid**n \u0026gt; x: high = mid else: return mid return mid + 1 # https://github.","title":"湖湘杯 2021 Crypto"},{"content":"easyxor shift函数是个常见的移位异或操作，convert是对一个数字使用不同的 key 和 mask 进行 4 次移位异或，这个函数在已知 key 的情况下是可逆的。\nencrypt函数是对明文块进行两种模式（CBC和OFB）的块加密，块长度为 8，对于每一块的加密使用的就是上面的convert函数。\n首先通过密文的长度可以得知一共被分成了 6 块；前 3 块明文使用 OFB 模式，后三块明文使用 CBC 模式；keys 是一个长度为 4 的列表，列表中每个值的范围是(-32, 32)，$64^4$ 爆破也是可以接受的。\n读完题目代码之后可以想到其实我们已经知道第一块明文了，就是 flag 的格式ByteCTF{，而OFB模式实际上是加密的key，最终结果和明文块异或，所以第一个明文块异或第一个密文块就可以知道第一个 key 加密的结果，也就是cur_c = convert(last, k)的cur_c，这样就可以得到第二块的 last。\n现在对于第二块，已知 IV（last），未知 keys，已知明文是可显示字符，所以可以爆破 keys 了，把能解出可显示字符明文的 keys 都保留出来，发现有 4836 个 keys 是满足的，那么我们还要借助第三块再筛一次，最终只得到一组 keys。\nfrom itertools import product from tqdm import tqdm from Crypto.Util.number import bytes_to_long, long_to_bytes def check(s): return min([((i\u0026lt;129) and (i\u0026gt;31)) for i in s]) c = \u0026quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026quot; c_list = [int(c[i*16:i*16+16], 16) for i in range(len(c)//16)] known_m = bytes_to_long(b'ByteCTF{') range64 = list(range(-32, 33)) cur_c = known_m^c_list[0] print(cur_c) k_cnt = 0 for a,b,c,d in tqdm(product(range64, range64, range64, range64)): last = cur_c k = [a, b, c, d] try_cur_c = convert(last, k) m1 = long_to_bytes(try_cur_c ^ c_list[1]) if check(m1): # 只筛选这第一轮的话，4836个k是满足条件的，所以得筛第二轮 last = try_cur_c try_cur_c = convert(last, k) m2 = long_to_bytes(try_cur_c ^ c_list[2]) if check(m2): k_cnt += 1 try: print(m1.decode() + m2.decode(), k) except: print(\u0026quot;error\u0026quot;) print(k_cnt) # keys = [-12, 26, -3, -31] # ByteCTF{5831a241s-f30980 现在已经得到了keys和前三块的明文，可以接着解后三块明文了。\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes k = [-12, 26, -3, -31] c = \u0026quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026quot; cl = [int(c[i*16:i*16+16], 16) for i in range(len(c)//16)] cur_c = bytes_to_long(b'ByteCTF{') ^ cl[0] def shift(m, k, c): if k \u0026lt; 0: return m ^ m \u0026gt;\u0026gt; (-k) \u0026amp; c return m ^ m \u0026lt;\u0026lt; k \u0026amp; c def convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return m def unshift_right(value, key, mask=None, nbits=32): if not mask: mask = (1 \u0026lt;\u0026lt; (nbits + 1)) - 1 i = 0 while i * key \u0026lt; nbits: part_mask = ((((1 \u0026lt;\u0026lt; nbits)-1) \u0026lt;\u0026lt; (nbits - key)) \u0026amp; ((1 \u0026lt;\u0026lt; nbits)-1)) \u0026gt;\u0026gt; (i * key) part = value \u0026amp; part_mask value ^= (part \u0026gt;\u0026gt; key) \u0026amp; mask i += 1 return value def unshift_left(value, key, mask=None, nbits=32): if not mask: mask = (1 \u0026lt;\u0026lt; (nbits + 1)) - 1 i = 0 while i * key \u0026lt; nbits: part_mask = ((((1 \u0026lt;\u0026lt; nbits)-1) \u0026gt;\u0026gt; (nbits - key)) \u0026amp; ((1 \u0026lt;\u0026lt; nbits)-1)) \u0026lt;\u0026lt; (i * key) part = value \u0026amp; part_mask value ^= (part \u0026lt;\u0026lt; key) \u0026amp; mask i += 1 return value def my_unshift(m, k, c): if k \u0026lt; 0: tmp = unshift_right(m, -k, c, 64) return tmp tmp = unshift_left(m, k, c, 64) return tmp def re_convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3, -1, -1): m = my_unshift(m, key[t], c_list[t]) return m IV = re_convert(cur_c, k) assert IV.bit_length() == 64 last = IV cur = re_convert(cl[3], k) m3 = long_to_bytes(cur ^ last) print(m3) last = cl[3] cur = re_convert(cl[4], k) m4 = long_to_bytes(cur ^ last) print(m4) last = cl[4] cur = re_convert(cl[5], k) m5 = long_to_bytes(cur ^ last) print(m5) print(m3 + m4 + m5) # q535af-2156547475u2t}$$$ 拼接起来得到完整 flag:ByteCTF{5831a241s-f30980q535af-2156547475u2t}$$$\nabusedkey 首先把用到的数据放在了task_data.py，方便些其他脚本时直接导入：\nURL = \u0026quot;http://39.105.181.182:30000\u0026quot; msg11 = URL+\u0026quot;/abusedkey/server/msg11\u0026quot; msg13 = URL+\u0026quot;/abusedkey/server/msg13\u0026quot; msg21 = URL+\u0026quot;/abusedkey/server/msg21\u0026quot; msg23 = URL+\u0026quot;/abusedkey/ttp/msg23\u0026quot; msg25 = URL+\u0026quot;/abusedkey/server/msg25\u0026quot; # -------------------------------- Secp256k1 -------------------------------- p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F a, b = 0, 7 G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8) # ------------------ https://en.bitcoin.it/wiki/Secp256k1 ------------------- Pc = (0xb5b1b07d251b299844d968be56284ef32dffd0baa6a0353baf10c90298dfd117, 0xea62978d102a76c3d6747e283091ac5f2b4c3ba5fc7a906fe023ee3bc61b50fe) 协议2的部分，想要拿到hint很简单，只要按照描述实现出来，就拿到了hint，hint.sage:\nimport requests, os, random from Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes from task_data import p, a, b, G, msg21, msg23, msg25 from hashlib import sha256 E = EllipticCurve(IntegerModRing(p), [a, b]) G = E(G) # sid2 = hex(random.getrandbits(256))[2:] sid2 = \u0026quot;8d1a95ce724141a0ea7c8ffa7eddc48605b3117c8aa886bcc2aff3b0c2175b56\u0026quot; msg22 = requests.get(msg21, data=sid2).text Qs_hex = msg22 rc = 1 # random.randint(1, p) Rc = rc*G Pic = long_to_bytes(int('FFFF', 16)) hc = int(sha256(Pic).hexdigest(), 16) Qc = hc*Rc Qc_hex = hex(Qc[0])[2:].rjust(64) + hex(Qc[1])[2:].rjust(64) assert len(Qc_hex) == 128 msg24 = requests.get(msg23, data=Qc_hex+Qs_hex).text assert len(msg24) == 256 Yc_hex, Ys_hex = msg24[:128], msg24[128:] msg26 = requests.get(msg25, data=sid2+Yc_hex).text Ys = E((int(Ys_hex[:64], 16), int(Ys_hex[64:], 16))) Zcs = rc*Ys Zcsx = long_to_bytes(int(Zcs[0])) sk2 = sha256(Zcsx).digest() msg26 = bytes.fromhex(msg26) iv, ciphertext, mac = msg26[:12], msg26[12:-16], msg26[-16:] cipher = AES.new(sk2, mode=AES.MODE_GCM, nonce=iv) try: m = cipher.decrypt_and_verify(ciphertext, mac) print(m.decode()) except ValueError: print(\u0026quot;MAC check failed\u0026quot;) # off-line guessing on protocol_II, and key compromise impersonation on protocol_I Hint: off-line guessing on protocol_II, and key compromise impersonation on protocol_I\nhint和题目描述都在说明，两个协议共用一个 Server 端的 key，那么大概思路就是通过协议 2 拿到 key，再将这个 key 用于解协议 1 的 flag，可以先简单分析一下：\n已知 rc-(随机), hc-H(c口令) 未知 rs-(随机), hs-H(s口令) Qc = rc * hc * G --- 已知 Qs = rs * hs * G --- 已知 Yc = rc * rt * G --- 已知 Ys = rs * rt * G --- 已知 Zcs = rc * rs * rt * G --- 已知 公共密钥 这里面的rc是我们可以控制的，所以可以令rc=1让问题看起来简单一点。\nrc = 1 时： Qc = hc * G --- 已知 Qs = rs * hs * G --- 已知 Yc = rt * G --- 已知 Ys = rs * rt * G --- 已知 Zcs = rs * rt * G --- 已知 公共密钥 $hs$是两个字节的sha256结果，显然是让我们爆破的，也就是说我们需要得到一组形式为$hs\\cdot Point$和$Point$的数据，这样去爆两个字节就可以了，为了得到这样的数据，我们需要构造一下发送的数据。\n发送假的 Qc = hc * rs * hs * G = hc * Qs 得到 Yc = hs * rs * rt * G 发送 Qs = rs * hs * G 得到 Ys = rs * rt * G 这样以来，$Ys$ 和 $Yc$ 刚好是我们需要的一组数据，$Yc=hs\\cdot Ys$，然后爆破一下两个字节的哈希，如果某两个字节的 sha256 乘 $Ys$ 等于 $Yc$，那么这个 sha256 的值就是 $hs$：\nimport requests, os, random, tqdm from Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes from task_data import p, a, b, G, msg21, msg23, msg25 from hashlib import sha256 E = EllipticCurve(IntegerModRing(p), [a, b]) G = E(G) sid2 = \u0026quot;8d1a95ce724141a0ea7c8ffa7eddc48605b3117c8aa886bcc2aff3b0c2175b56\u0026quot; msg22 = requests.get(msg21, data=sid2).text Qs = E((int(msg22[:64], 16), int(msg22[64:], 16))) rc = 1 # random.randint(1, p) Rc = rc*G Pic = long_to_bytes(int('FFFF', 16)) hc = int(sha256(Pic).hexdigest(), 16) fake_Qc = hc * Qs # hc * rs * hs * G fake_Qc_hex = hex(fake_Qc[0])[2:].rjust(64) + hex(fake_Qc[1])[2:].rjust(64) msg24 = requests.get(msg23, data=fake_Qc_hex+msg22).text assert len(msg24) == 256 Yc_hex, Ys_hex = msg24[:128], msg24[128:] # hs * rs * rt * G Yc = E((int(Yc_hex[:64], 16), int(Yc_hex[64:], 16))) # rs * rt * G Ys = E((int(Ys_hex[:64], 16), int(Ys_hex[64:], 16))) for pis in tqdm.tqdm(range(0xff, 0xffff+1)): hs = int(sha256(long_to_bytes(pis)).hexdigest(), 16) if ((hs*Ys) == Yc): print(f'pis = {pis}\\nhs = {hs}') break ''' pis = 36727 hs = 67294392667457530634966084521984708026794776225602296684920633502274376489620 ''' 协议 2 搞到了 $hs$，也就是协议 1 中的服务端私钥 ds，所以服务端的公钥也很容易得到，这样就有了 $(d_S,P_S)$，还有题目给我们的 $P_C$，一旦计算出 $K_{CS}$ 就可以解出 flag 了，那么问题是看起来我们必须知道 $t_S$ 和 $d_C$ 中的一个，所以需要想办法把它消掉，在要求上传 $T_C$ 的时候，上传 $-T_C$ 就可以了。\nimport requests, random from Crypto.Util.number import * from Crypto.Cipher import AES from task_data import p, a, b, G, msg11, msg13, Pc from hashlib import sha256 E = EllipticCurve(IntegerModRing(p), [a, b]) G = E(G) sid1 = \u0026quot;8d1a95ce724141a0ea7c8ffa7eddc48605b3117c8aa886bcc2aff3b0c2175b56\u0026quot; msg12 = requests.get(msg11, data=sid1).text ds = 67294392667457530634966084521984708026794776225602296684920633502274376489620 Ps = ds*G Pc = E(Pc) invPc = -1*Pc print(invPc) invPc_hex = hex(invPc[0])[2:].rjust(64) + hex(invPc[1])[2:].rjust(64) msg14 = requests.get(msg13, data=sid1+invPc_hex).text Kcs = ds*invPc sk1 = sha256(long_to_bytes(int(Kcs[0]))).digest() msg26 = bytes.fromhex(msg14) iv, ciphertext, mac = msg26[:12], msg26[12:-16], msg26[-16:] cipher = AES.new(sk1, mode=AES.MODE_GCM, nonce=iv) try: m = cipher.decrypt_and_verify(ciphertext, mac) print(m.decode()) except ValueError: print(\u0026quot;MAC check failed\u0026quot;) JustDecrypt 和美团 CTF 决赛的 secret_decryption_system 几乎是一样的题，不同的地方是给的交互次数不够，最后 unpad 不一定会被截断到什么地方，所以用一样的脚本跑出结果的概率是1/256\nfrom Crypto.Util.number import * from pwn import * from tqdm import tqdm def main(): r = remote('39.105.181.182', '30001') plaintext = b\u0026quot;Hello, I'm a Bytedancer. Please give me the flag!\u0026quot;+b\u0026quot;\\x0f\u0026quot;*15 def my_XOR(a, b): assert len(a) == len(b) return b''.join([long_to_bytes(a[i]^b[i]) for i in range(len(a))]) def proof_of_work(): rev = r.recvuntil(b\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(28).decode() rev = r.recvuntil(b\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(b'Give me XXXX \u0026gt; ') r.sendline(prefix.encode()) def decrypt(msg): newmsg = msg + b'\\x00'*(256+64-len(msg)) r.recvuntil(b'Please enter your cipher in hex \u0026gt; ') r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) def decrypt_(msg): newmsg = msg + b'\\x00'*(256-len(msg)) r.recvuntil(b'Please enter your cipher in hex \u0026gt; ') r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) proof_of_work() msg = b'\\x00'*16 decrypt(msg) c = b\u0026quot;\u0026quot; for i in range(50): t = decrypt(c)[i] c += long_to_bytes(t^plaintext[i]) decc = decrypt_(c) print(decc) res = r.recvline()+r.recvline() if b\u0026quot;Here is your flag\u0026quot; in res: print(r.recvline()) print(r.recvline()) r.close() return (True, len(decc)) r.close() return (False, len(decc)) ll = [] while True: ss = main() ll.append(ss[1]) if ss[0]: break print(len(ll), ll) Overheard 相当于一个 Oracle，给返回pow(msg, b, p)的高位，可以想办法利用 coppersmith 定理。先后发送 Alice 和 pow(Alice, 2, p)的值，然后得到x1，x2，那么在模 p 的多项式$f(x) = (x1 + a)^2 - x2 - b$ 的值为 0，所以解这个方程的 small roots 就可以得到被舍弃的值（小于 64-bit）。\nfrom pwn import remote from Crypto.Util.number import * import itertools r = remote('39.105.38.192', 30000) p = 62606792596600834911820789765744078048692259104005438531455193685836606544743 g = 5 r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;1\u0026quot;) Alice = int(r.recvline().decode().strip()) r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;2\u0026quot;) Bob = int(r.recvline().decode().strip()) r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;3\u0026quot;) r.sendlineafter(b\u0026quot;To Bob: \u0026quot;, str(Alice).encode()) x1 = int(r.recvline().decode().strip()) r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;3\u0026quot;) r.sendlineafter(b\u0026quot;To Bob: \u0026quot;, str(pow(Alice, 2, p)).encode()) x2 = int(r.recvline().decode().strip()) def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] PR.\u0026lt;a,b\u0026gt; = PolynomialRing(Zmod(p)) f = (x1 + a)**2 - x2 - b ans = small_roots(f, (2**64, 2**64), m=8) print(\u0026quot;ans =\u0026quot;, ans) r.sendlineafter(b'$ ', b'4') r.sendlineafter(b'secret: ', str(x1 + ans[0][0]).encode()) print(r.recvline().decode().strip()) r.close() ''' ans = [(275016199582168079, 3988784878785365375)] b'ByteCTF{0fcca5ab-c7dc-4b9a-83f0-b24d4d004c19}' ''' ","permalink":"https://slightwind.cn/posts/ctf/bytectf2021/","summary":"easyxor shift函数是个常见的移位异或操作，convert是对一个数字使用不同的 key 和 mask 进行 4 次移位异或，这个函数在已知 key 的情况下是可逆的。\nencrypt函数是对明文块进行两种模式（CBC和OFB）的块加密，块长度为 8，对于每一块的加密使用的就是上面的convert函数。\n首先通过密文的长度可以得知一共被分成了 6 块；前 3 块明文使用 OFB 模式，后三块明文使用 CBC 模式；keys 是一个长度为 4 的列表，列表中每个值的范围是(-32, 32)，$64^4$ 爆破也是可以接受的。\n读完题目代码之后可以想到其实我们已经知道第一块明文了，就是 flag 的格式ByteCTF{，而OFB模式实际上是加密的key，最终结果和明文块异或，所以第一个明文块异或第一个密文块就可以知道第一个 key 加密的结果，也就是cur_c = convert(last, k)的cur_c，这样就可以得到第二块的 last。\n现在对于第二块，已知 IV（last），未知 keys，已知明文是可显示字符，所以可以爆破 keys 了，把能解出可显示字符明文的 keys 都保留出来，发现有 4836 个 keys 是满足的，那么我们还要借助第三块再筛一次，最终只得到一组 keys。\nfrom itertools import product from tqdm import tqdm from Crypto.Util.number import bytes_to_long, long_to_bytes def check(s): return min([((i\u0026lt;129) and (i\u0026gt;31)) for i in s]) c = \u0026quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026quot; c_list = [int(c[i*16:i*16+16], 16) for i in range(len(c)//16)] known_m = bytes_to_long(b'ByteCTF{') range64 = list(range(-32, 33)) cur_c = known_m^c_list[0] print(cur_c) k_cnt = 0 for a,b,c,d in tqdm(product(range64, range64, range64, range64)): last = cur_c k = [a, b, c, d] try_cur_c = convert(last, k) m1 = long_to_bytes(try_cur_c ^ c_list[1]) if check(m1): # 只筛选这第一轮的话，4836个k是满足条件的，所以得筛第二轮 last = try_cur_c try_cur_c = convert(last, k) m2 = long_to_bytes(try_cur_c ^ c_list[2]) if check(m2): k_cnt += 1 try: print(m1.","title":"ByteCTF 2021 Crypto"},{"content":"Get shell 小米路由器后台管理页面是不给我们上传并且刷入新固件的，所以要先拿到 shell，ssh 连上路由器就可以往里面刷入新固件了。\n先正常启动路由器，并进入路由器后台管理页面，这时可以在浏览器的地址栏看到自己路由器的内网 IP，和自己的 stok，例如我的开头是：\nhttp://10.161.145.162/cgi-bin/luci/;stok=e9974e290dd74c4683328c5a5876308b/... 我的路由器 IP 是10.161.145.162，stok的值为e9974e290dd74c4683328c5a5876308b，现在把下面的链接替换成自己的，然后 Enter，浏览器返回0说明这一步可以了。\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B 然后下面这个链接也是一样的操作，同样应该返回0：\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20'12345678%5Cn12345678'%20%7C%20passwd%20root%3B 如果这两个链接都成功返回了0，那么就可以使用习惯的工具去 ssh 连接路由器了：\nssh root@「这里替换IP」 # passwd 12345678 不出意外，这边是可以连接到路由器的 shell 的，然后可以看到字符画显示的are you ok。\n上传并刷入固件 前面拿到了 shell，现在可以上传固件了，首先下载openwrt-RM2100-kernel1.bin和openwrt-RM2100-rootfs0.bin，然后 cd 进入这两个文件所在的目录，用 SCP 传到路由器上。\n# 把openwrt的固件通过SCP上传到路由器的/tmp目录下 scp openwrt-RM2100-kernel1.bin root@「这里替换IP」:/tmp scp openwrt-RM2100-rootfs0.bin root@「这里替换IP」:/tmp 然后 ssh 连接上路由器，开始刷入固件：\n# 进入/tmp目录下 cd /tmp mtd write openwrt-RM2100-kernel1.bin kernel1 nvram set uart_en=1 nvram set bootdelay=5 nvram set flag_try_sys1_failed=1 nvram commit mtd -r write openwrt-RM2100-rootfs0.bin rootfs0 等待写入完成，就可以重启路由器了，这个时候路由器的 Wi-Fi 名称变成了 OpenWrt，并且没有密码，可以直接连接，然后用 ssh 连接新的 IP：\n# 用新的IP来ssh连上去，刷完OpenWrt之后，内网IP也会改变 ssh root@192.168.1.1 # 连上之后可以看到：root@OpenWrt:~# 到这里，固件就刷入成功了。路由器管理地址为：192.168.1.1 用户名：root 密码：password\n如果现在的固件可以满足使用要求，那么就不需要接着操作了，但是我需要使用路由器上运行一个脚本来自动使用账号密码连接校园网，每当网络断开时再重新去连接，而当前的固件不支持curl命令，个人感觉 UI 也不够美观，所以我使用它来写入新的固件，这个固件支持curl，也更加美观。\n刷入新固件 由于最新编译 ROM 较大无法直接通过telnet刷入，所以刷完上面 ROM 后需要在路由器管理后台更新最新 OP 固件。\n先下载一下03.10-openwrt-ramips-mt7621-redmi-ac2100-squashfs-sysupgrade.bin固件。\n然后登陆192.168.1.1后台后点击「系统」-「备份/升级」-「刷写新固件（不保留配置）」-「上传op固件包」\n选择刚刚下载的 bin 文件进行安装，安装完成后，重启路由器，然后连接上路由器后台就可以了，这里同样要注意，刷入新固件后路由器的IP会改变，最好进电脑的 Wi-Fi 详情里面看一下，我的是变成了 192.168.2.1，ssh 和 web 后台密码都是password。\n现在就可以在路由器的后台进行一些自己需要的配置操作了。\n救砖：如果折腾的过程中出现了什么问题，可以使用官方的救砖工具MIWIFI Repair Tool，并刷入官方固件miwifi_rm2100_firmware_d6234_2.0.7.bin。\nMentioned files - - openwrt-RM2100-kernel1.bin 谷歌云盘 腾讯微云 openwrt-RM2100-rootfs0.bin 谷歌云盘 腾讯微云 03.10-openwrt-ramips-mt7621-redmi-ac2100-squashfs-sysupgrade.bin 谷歌云盘 腾讯微云 MIWIFI Repair Tool 谷歌云盘 腾讯微云 miwifi_rm2100_firmware_d6234_2.0.7.bin 谷歌云盘 腾讯微云 ","permalink":"https://slightwind.cn/posts/environment/install-openwrt-for-redmi-ac2100/","summary":"Get shell 小米路由器后台管理页面是不给我们上传并且刷入新固件的，所以要先拿到 shell，ssh 连上路由器就可以往里面刷入新固件了。\n先正常启动路由器，并进入路由器后台管理页面，这时可以在浏览器的地址栏看到自己路由器的内网 IP，和自己的 stok，例如我的开头是：\nhttp://10.161.145.162/cgi-bin/luci/;stok=e9974e290dd74c4683328c5a5876308b/... 我的路由器 IP 是10.161.145.162，stok的值为e9974e290dd74c4683328c5a5876308b，现在把下面的链接替换成自己的，然后 Enter，浏览器返回0说明这一步可以了。\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B 然后下面这个链接也是一样的操作，同样应该返回0：\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20'12345678%5Cn12345678'%20%7C%20passwd%20root%3B 如果这两个链接都成功返回了0，那么就可以使用习惯的工具去 ssh 连接路由器了：\nssh root@「这里替换IP」 # passwd 12345678 不出意外，这边是可以连接到路由器的 shell 的，然后可以看到字符画显示的are you ok。\n上传并刷入固件 前面拿到了 shell，现在可以上传固件了，首先下载openwrt-RM2100-kernel1.bin和openwrt-RM2100-rootfs0.bin，然后 cd 进入这两个文件所在的目录，用 SCP 传到路由器上。\n# 把openwrt的固件通过SCP上传到路由器的/tmp目录下 scp openwrt-RM2100-kernel1.bin root@「这里替换IP」:/tmp scp openwrt-RM2100-rootfs0.bin root@「这里替换IP」:/tmp 然后 ssh 连接上路由器，开始刷入固件：\n# 进入/tmp目录下 cd /tmp mtd write openwrt-RM2100-kernel1.bin kernel1 nvram set uart_en=1 nvram set bootdelay=5 nvram set flag_try_sys1_failed=1 nvram commit mtd -r write openwrt-RM2100-rootfs0.bin rootfs0 等待写入完成，就可以重启路由器了，这个时候路由器的 Wi-Fi 名称变成了 OpenWrt，并且没有密码，可以直接连接，然后用 ssh 连接新的 IP：","title":"Install OpenWrt for Redmi Router AC2100"},{"content":"Install conda 官网上没有直接给出M1 Mac版本的SageMath二进制安装文件，不过给出了使用conda安装Sage的方法，参考Install from conda-forge。\n所以如果自己的Mac上还没有安装conda的话，可以先安装一下，然后使用conda安装SageMath。\n首先下载Miniforge3-MacOSX-arm64.sh，cd进入Miniforge3-MacOSX-arm64.sh所在的目录。\nbash Miniforge3-MacOSX-arm64.sh 接着一路回车，直到确认条款：\nDo you accept the license terms? [yes|no] [no] \u0026gt;\u0026gt;\u0026gt; yes 然后编辑配置文件vim ~/.zshrc，在最下面加入如下内容：\npath=('/Users/「这里替换成Mac用户名」/miniforge3/bin' $path) export PATH :wq保存并退出，然后source ~/.zshrc，conda info应该就可以看到了，到这里conda安装完成。\n在终端输入下面这些，给conda换到清华源，这样在使用国内网络不走代理的情况下安装一些东西就更快了：\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes 然后输入conda config --show | grep https可以看到已经更新成功的上面的链接。\n如果是直接新开的终端，直接输入conda是没有反应的，需要先source ~/.zshrc一下。\nInstall SageMath conda config --append channels conda-forge conda config --set channel_priority strict conda create -n sage sage python=3.9 # Proceed ([y]/n)? y # 然后就开始下载安装了 这时输入conda activate sage，然后输入sage就可以看到sage启动了，也可以使用sage xxx.sage来执行一个sage脚本，这样就是安装完成了。\n注意每次都要先vim ~/.zshrc进入conda，然后conda activate sage进入sage。\nMentioned files - - Miniforge3-MacOSX-arm64.sh - 腾讯微云 ","permalink":"https://slightwind.cn/posts/crypto/install-sagemath-for-apple-silicon-m1/","summary":"Install conda 官网上没有直接给出M1 Mac版本的SageMath二进制安装文件，不过给出了使用conda安装Sage的方法，参考Install from conda-forge。\n所以如果自己的Mac上还没有安装conda的话，可以先安装一下，然后使用conda安装SageMath。\n首先下载Miniforge3-MacOSX-arm64.sh，cd进入Miniforge3-MacOSX-arm64.sh所在的目录。\nbash Miniforge3-MacOSX-arm64.sh 接着一路回车，直到确认条款：\nDo you accept the license terms? [yes|no] [no] \u0026gt;\u0026gt;\u0026gt; yes 然后编辑配置文件vim ~/.zshrc，在最下面加入如下内容：\npath=('/Users/「这里替换成Mac用户名」/miniforge3/bin' $path) export PATH :wq保存并退出，然后source ~/.zshrc，conda info应该就可以看到了，到这里conda安装完成。\n在终端输入下面这些，给conda换到清华源，这样在使用国内网络不走代理的情况下安装一些东西就更快了：\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes 然后输入conda config --show | grep https可以看到已经更新成功的上面的链接。","title":"Install SageMath for Apple Silicon M1"},{"content":"0xGame2020 是第一届 0xGame 比赛，时间持续一个月，面向零基础的新生。题目和 exp 可以在我的 GitHub 上找到：https://github.com/Am473ur/My-CTF-Challenge/tree/main/0xGame2020 ，这里记录一下出题人角度的 wp。\nWeek 1 Calendar 题目给了一张图片和一串逗号隔开的坐标信息，没看出来的话不难想到去百度一下“日历加密”，这题只是做了简单的修改。\nSAT1,THU1,MON3,MON2,WED3,SUN2,THU1,SUN4,FRI3,THU1,MON4,MON4,FRI4,THU3,SUN4,SUN2,TUE4,THU1,FRI1,MON3,MON2\n懒得百度的话，也不难看出前三个字母代表周一到周日，紧跟的数字范围是 1～4，所以他们代表两个坐标，列举出来并用a～z替换1～26，即可得到 flag。\neasyXor 做出这题只需要知道异或的逆运算还是异或，反过来跑一遍就拿到了 flag。\nexp:\ncipher=[72, 63, 38, 12, 8, 30, 30, 6, 82, 4, 84, 88, 92, 7, 79, 29, 8, 90, 85, 26, 25, 87, 80, 10, 20, 20, 9, 4, 80, 73, 31, 5, 82, 0, 1, 92, 0, 0, 94, 81, 4, 85, 27, 35] flag=\u0026quot;\u0026quot; cipher+=[ord(\u0026quot;^\u0026quot;)] for i in range(len(cipher)-1): flag = chr(cipher[len(cipher)-i-2]^cipher[len(cipher)-i-1])+flag cipher[len(cipher)-i-2]=ord(flag[0]) print(flag) # 0xGame{ec15a9eb-08b7-4c39-904d-27eed888f73f} 发现有的学弟跑完脚本手动补0，exp正确的话，是可以得到完整flag的。\nsupperAffine 这题其实就是普通的仿射加密，看起来是套了三层，但是一旦展开化简，仍然是 $Ax+B$ 的一次式。\n$$ \\begin{aligned} f(x)\u0026amp;=A_1(A_2(A_3\\cdot x+B_3)+B_2)+B_3\\\\ \u0026amp;=(A_1A_2A_3)\\cdot x+(A_1A_2B_3+A_1B_2+B_1)\\\\ \u0026amp;=A\\cdot x+B \\end{aligned} $$\n其中 $A = A_1A_2A_3,\\ B = A_1A_2B_3+A_1B_2+B_1.$\n并且过大的 $A$ 和 $B$ 都是没有意义的，可以等效为模数以内的数，所以解普通的仿射加密的脚本都可以直接解这一题。\nexp:\nfrom Crypto.Util.number import * from string import ascii_letters, digits table = ascii_letters+digits cipher = \u0026quot;t6b7Tn{2GByBZBB-aan2-JRWn-GnZB-Jyf7a722ffnZ}\u0026quot; MOD = len(table) def find_ab(): for a in range(MOD): for b in range(MOD): if (a*table.find(\u0026quot;0\u0026quot;)+b) % MOD == table.find(cipher[0]): if (a*table.find(\u0026quot;x\u0026quot;)+b) % MOD == table.find(cipher[1]): if (a*table.find(\u0026quot;G\u0026quot;)+b) % MOD == table.find(cipher[2]): if (a*table.find(\u0026quot;a\u0026quot;)+b) % MOD == table.find(cipher[3]): print(\u0026quot;a, b = {}, {}\u0026quot;.format(a,b)) return (a, b) flag = \u0026quot;\u0026quot; A, B = find_ab() for i in cipher: if i not in table: flag += i else: flag += table[inverse(A, MOD)*(table.find(i)-B) % MOD] print(flag) 0xGame{1b292822-33e1-46fe-be82-49ca3a11cce8}\nequationSet 这题是个简单的解方程组，可以发现给出的值有 $$ \\begin {aligned} n\u0026amp;= p\\cdot q\\cdot r\\\\ s\u0026amp;= p + q + r\\\\ t\u0026amp;= p\\cdot(q+r) \\end {aligned} $$\n我们需要求的是\n$$ \\phi(n)=(p-1)\\cdot (q-1)\\cdot (r-1) $$\n其中\n$$ p=GCD(n,t) $$\n所以\n$$ \\begin {aligned} \\phi(n) \u0026amp;= (p-1)\\cdot( q\\cdot r-(q+r)+1) \\\\ \u0026amp;= (p-1)\\cdot( (n-t)/p+1) \\end {aligned} $$\nexp:\nfrom Crypto.Util.number import * c = 216719040256186298397028655750064798850... n = 894056034566447301955142597300391580123... s = 296550633935119159669335323468002356547... t = 157435908314881832180551915807491465031... p = GCD(n, t) phi = (p-1)*((n-t)//p+1) d = inverse(65537, phi) m = pow(c, d, n) print(long_to_bytes(m)) 这题也可以使用sagemath直接解，甚至不需要简单的公式推导：\nvar('p q r') solve([p+q+r == s, p*q*r == n, p*q+p*r == t],[p,q,r]) 可以直接求出 3 个素数的值，然后进行解密。\nFibonacci 这题的考点是斐波那契数列对一个模数 n 取模，会出现循环节，求出循环周期这题就相当于解决了。\n这个周期就是皮萨诺周期（Pisano periods），先对 $n$ 进行素因数分解，然后求解每个素数幂的周期，最后通过中国剩余定理（Chinese remainder theorem）合并，一个素数幂 $p^n$ 的周期等于 $p^{n-1}$ 乘以 $p$ 的周期，所以需要求出每个素因数的周期。这里分为两种情况，如果 $5$ 是模 $p$ 的二次剩余，那么 $p$ 的周期是 $p-1$ 的一个因数；如果不是，那么周期为 $2(p+1)$ 的一个因数。$5$ 是否为模 $p$ 的二次剩余，可以通过勒让德（Legrend）符号来判断。\n不过这题的 $n$ 很小，直接爆破就可以很快得到它的周期。。。（而且还挺快的orz）\n这里给出通过定理求解的脚本（用C++写矩阵快速幂来实现的话会快很多）。\nfrom Crypto.Util.number import * from gmpy2 import next_prime def genFibonacci(): a = [1, 1] for i in range(2, 2**16): a.append(a[i-1]+a[i-2]) return a def Legrend(a, p): if a == 1: return 1 if p % a == 0: return 0 if a % 2 == 0: return Legrend(a // 2, p) * pow(-1, (pow(p, 2) - 1) // 8) return Legrend(p % a, a) * pow(-1, (a - 1)*(p - 1) // 4) def isPeriod(T, a): for t in range(T): p = t+T while p \u0026lt; len(a): if a[p] != a[t]: return False p += T return True def Factor_n(n): a = [] for i in range(2**3, 2**5): if (not isPrime(i)) or (n % i): continue a.append([i, 0]) n = n//i while n % i == 0: n = n//i a[-1][1] += 1 return a def Factor_x(x): a = [] for i in range(2, x): if x % i == 0: a.append(i) return a def solve(a): per = [] for i in range(len(a)): prime = a[i][0] if Legrend(5, prime) == 1: fac = Factor_x(prime-1) tmp = prime-1 else: fac = Factor_x(2*(prime+1)) tmp = 2*(prime+1) fib_mod = [(k % prime) for k in fib] for t in fac: if isPeriod(t, fib_mod): per.append(t*(prime**a[i][1])) break else: per.append(tmp*(prime**a[i][1])) LCM = per[0] for i in range(1, len(per)): LCM = (per[i]*LCM)//GCD(LCM, per[i]) return LCM r = 6799657976717333 n = 34969 c = 18230697428395162035214602694158399484881314... N = 18856119995376203055253776689360000192482523... fib = genFibonacci() a = Factor_n(n) T = solve(a) fib_mod = [(k % n) for k in fib] S = sum(fib_mod[:T])*(r//T)+sum(fib_mod[:r%T]) p = next_prime(S**16) q = N//p m=pow(c,inverse(65537,(p-1)*(q-1)),N) print(long_to_bytes(m)) Week 2 smallModulus 这题很简单，只是过一层 proof of work​ 然后用 CRT 就可以拿到 flag，是想让大家熟悉一下远程的题目，写个自动的脚本，但是这题可以 nc 连上去手动拿 8 组数据出来，然后本地计算出flag\u0026hellip;\u0026hellip;\n爆破 pow 可以用 pwntools 的 mbruteforce() 函数来多线程爆，速度相对快很多。\nfrom pwn import * import hashlib import string from functools import reduce from Crypto.Util.number import* from gmpy2 import invert HOST = \u0026quot;xx.xxx.xxx.xx\u0026quot; PORT = 10000 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) def CRT(a, m): Num = len(m) M = reduce(lambda x, y: x*y, m) Mi = [M//i for i in m] t = [invert(Mi[i], m[i]) for i in range(Num)] x = 0 for i in range(Num): x += a[i]*t[i]*Mi[i] return x % M def getData(): line = r.recvuntil(b\u0026quot;\u0026gt; \u0026quot;) r.sendline(b\u0026quot;1\u0026quot;) line = r.recvline().decode().strip() mod, res = int(line[9:25], 16), int(line[37:54], 16) return (mod, res) proof_of_work() m = [] a = [] for i in range(8): mod, res = getData() m.append(mod) a.append(res) flag = CRT(a, m) print(long_to_bytes(flag)) r.interactive() # 0xGame{3a8f45be-a0cf-457e-958e-b896056841d7} parityOracle RSA parity oracle 是一个经典的攻击，并且给出了 CTF Wiki 上相关部分的链接，我把模数改成了 4，理解一下就可以自己编写脚本解决这一题了。\n这是一个不断更新上下界来缩小范围逼近正确的明文值的过程，对不同余数下的上下界的更新需要分类讨论。\nfrom pwn import * from Crypto.Util.number import * HOST = \u0026quot;xx.xxx.xxx.xx\u0026quot; PORT = 10001 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce( f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) def getNum(c): r.sendline(b\u0026quot;1\u0026quot;) r.recvuntil(b\u0026quot;Your cipher (in hex): \u0026quot;) r.sendline(hex(c)[2:].encode()) return int(r.recvline().decode().strip()) proof_of_work() r.recvuntil(b\u0026quot;n = \u0026quot;) n = int(r.recvline().decode().strip()) r.recvuntil(b\u0026quot;c = \u0026quot;) c = int(r.recvline().decode().strip()) e = 65537 upper = n lower = 0 i = 1 while True: power = pow(4, i, n) new_c = (pow(power, e, n)*c) % n rev = getNum(new_c) if rev == 0: upper = (3*lower+upper)//4 elif rev == 1: temp = upper upper = (lower+upper)//2 lower = (3*lower+temp)//4 elif rev == 2: temp = upper upper = (lower+3*upper)//4 lower = (lower+temp)//2 else: lower = (lower+3*upper)//4 if (upper-lower) \u0026lt; 2: break i += 1 for i in range(100): if pow(lower+i,e,n)==c: print(long_to_bytes(lower+i)) break r.interactive() # 0xGame{a9abdec6-7b84-4443-afb8-ee4dada8bdca} Week 3 signinRSA 很简单的一题，发送密文，服务器会返回解密后的结果，只是不能发送 flag 的密文。\n没想到有两位学弟用 parityOracle 的脚本打。。。\n因为 $c\\cdot 2^e\\equiv m^e\\cdot 2^e\\equiv (2m)^e\\ mod\\ n$ 所以可以发送 $c\\cdot pow(2,e,n)$ 收到 2m，除 2 得到 flag。\n有位学弟想到发送 -c，得到返回 -m，tql\neasyRSA 这题是给了 $x=11\\cdot d + 7\\cdot (p-1)\\cdot (q-1)$ ，我们知道 $e\\cdot d\\equiv 1\\ mod\\ (p-1)\\cdot (q-1)$ ，所以存在 $r$ 使 $$ e\\cdot d= 1\\ +\\ r\\cdot(p-1)\\cdot (q-1) $$ 所以 $$ x\\cdot e=11\\cdot e\\cdot d +7\\cdot e\\cdot \\phi(n)\\\\ x\\cdot e=11\\cdot (1+r\\cdot \\phi (n)) +7\\cdot e\\cdot \\phi(n)\\\\ x\\cdot e-11=(11\\cdot r+7\\cdot e)\\cdot \\phi (n) $$ 枚举 $r$ 即可得到 $\\phi(n)$ .\nfrom Crypto.Util.number import * n = 15321211041844905603734344178124947... c = 14896093236493033914781929755936872... x = 26506090189848554080676908570070818... e = 65537 kphi = x*e-11 for r in range(e): k = 7*e+11*r if kphi % k: continue phi = kphi//k if len(bin(n-phi+1)[2:]) \u0026gt; 1025: continue print(long_to_bytes(pow(c, inverse(e, phi), n))) # 0xGame{cfac8284-3013-439b-8ff3-884decb642bb} paddingOracle 题目名称直接告诉了是 Padding Oracle Attack，学弟们也都学会并实现了这种攻击，网上资料也非常多，我就不详细写了（其实是因为懒）。\n这种攻击针对的是块加密的 CBC 模式，通过求得正确的中间值（Intermediary Value）并在最终和正确的向量异或得到明文。需要对密文分块从后往前破解，对于每一块，从最后一字节往前破解。\n对于一块需要破解的密文，需要先构造一个IV，并枚举IV的最后一字节，直到服务器告诉我们解密后的 padding 是正确的，将枚举到的这个字节的值和 padding 的值（\\x01）异或即可得到当前位置的中间值。然后更新IV的最后一字节（中间值最后一字节和\\x02异或）来保证枚举倒数第二字节的时候，倒数第一字节解密后的值是\\x02（这样爆破倒数第二字节的时候，只要服务器解密后倒数第二字节是\\x02就会 padding 正确）。\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from pwn import * HOST = \u0026quot;49.235.239.97\u0026quot; PORT = 10003 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce( f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) proof_of_work() r.recvuntil(b\u0026quot;iv : \u0026quot;) iv = [long_to_bytes(int(r.recvline().decode().strip(), 16))] r.recvuntil(b\u0026quot;crypttext : \u0026quot;) crypttext = long_to_bytes(int(r.recvline().decode().strip(), 16)) blocks = [crypttext[i*16:i*16+16] for i in range(len(crypttext)//16)] iv += blocks[:-1] flag = b\u0026quot;\u0026quot; for block in range(len(blocks)): mid_value = [] new_iv = bytearray(b\u0026quot;\\x00\u0026quot;*16) for i in range(16): for j in range(256): new_iv[15 - i] = j r.recvuntil(b\u0026quot;\u0026gt; \u0026quot;) r.sendline(b\u0026quot;1\u0026quot;) r.recvuntil(b\u0026quot;Your IV (in hex): \u0026quot;) r.sendline(new_iv.hex()) r.recvuntil(b\u0026quot;Your cipher (in hex): \u0026quot;) r.sendline(blocks[block].hex().encode()) data = r.recvline() if b\u0026quot;success\u0026quot; in data: ans = j ^ (i+1) break mid_value.append(ans) for m in range(15 - i, 16): new_iv[m] = (i+2) ^ mid_value[15 - m] find = \u0026quot;\u0026quot; for i in range(16): find += hex(iv[block][i] ^ mid_value[15 - i])[2:].rjust(2, '0') flag += long_to_bytes(int(find, 16)) print(flag) r.interactive() Week 4 littleTrick 逐字节构造服务器端的 flag，使服务器发送给我们的密文解密后只有一字节是我们未知的，所以我们只需要本地枚举一下这个字节，并在本地加密，本地的密文和服务器返回的密文一致的话，就说明爆破对了。\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from pwn import * HOST = \u0026quot;xx.xxx.xxx.xx\u0026quot; PORT = 10004 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) proof_of_work() r.recvuntil(b\u0026quot;n : \u0026quot;) n = int(r.recvline().decode().strip(), 16) e = 65537 flag=b\u0026quot;\u0026quot; for i in range(44): mask=b\u0026quot;1\u0026quot;*(44-i-1) print(mask) r.sendlineafter(b\u0026quot;\u0026gt; \u0026quot;, b\u0026quot;1\u0026quot;) r.sendlineafter(b\u0026quot;Your mask (in hex): \u0026quot;,hex(pow(bytes_to_long(mask),e,n))[2:].encode()) tar = int(r.recvline().decode().strip(), 16) for j in range(32,128): guess=flag+long_to_bytes(j)+mask if pow(bytes_to_long(guess),e,n)==tar: flag+=long_to_bytes(j) print(flag) break r.interactive() ElGamal 这题的考点是判断二次剩余，如果发现了y是二次剩余的话，那么只需要判断c1是否为二次剩余就可以了。\nfrom Crypto.Util.number import * y = 2101136318398982764494355697982735290351867853540128399809061806690701481465143258501856786165972388085070268979718711434744226290744692988395355120277617 g = 8401562798890834492298947403582806359769363301996138198850077614144023393945770711612546197987255078645962298286362268504959833530010137313108031112774451 p = 10946148224653120484646906462803901217745837751637974066354601688874051778651193811412739372059281847771491564589986518154039493312147458591216351424346123 datalist = [c.split(\u0026quot;, \u0026quot;) for c in open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;).read().split(\u0026quot;\\n\u0026quot;)[:-1]] flag = \u0026quot;\u0026quot;.join([\u0026quot;0\u0026quot; if pow(int(c[1], 16), (p-1)//2, p) == 1 else \u0026quot;1\u0026quot; for c in datalist]) print(long_to_bytes(int(flag,2))) 如果y不是二次剩余的话，就需要多进行一层判断。\n这题改自 CVE-2018-6594\nfrom Crypto.Util.number import * f = open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;).read().split(\u0026quot;\\n\u0026quot;)[:-1] datalist = [c.split(\u0026quot;, \u0026quot;) for c in f] y = 2101136318398982764494355697982735290351867853540128399809061806690701481465143258501856786165972388085070268979718711434744226290744692988395355120277617 g = 8401562798890834492298947403582806359769363301996138198850077614144023393945770711612546197987255078645962298286362268504959833530010137313108031112774451 p = 10946148224653120484646906462803901217745837751637974066354601688874051778651193811412739372059281847771491564589986518154039493312147458591216351424346123 flag = \u0026quot;\u0026quot; for c in datalist: output = -1 if (pow(y, (p-1)//2, p) == 1) or (pow(int(c[0], 16), (p-1)//2, p) == 1): if pow(int(c[1], 16), (p-1)//2, p) == 1: flag += \u0026quot;0\u0026quot; else: flag += \u0026quot;1\u0026quot; else: if pow(int(c[1], 16), (p-1)//2, p) == 1: flag += \u0026quot;1\u0026quot; else: flag += \u0026quot;0\u0026quot; flag = long_to_bytes(int(flag,2)) print(flag) ","permalink":"https://slightwind.cn/posts/ctf/0xgame-2020-crypto-problems/","summary":"0xGame2020 是第一届 0xGame 比赛，时间持续一个月，面向零基础的新生。题目和 exp 可以在我的 GitHub 上找到：https://github.com/Am473ur/My-CTF-Challenge/tree/main/0xGame2020 ，这里记录一下出题人角度的 wp。\nWeek 1 Calendar 题目给了一张图片和一串逗号隔开的坐标信息，没看出来的话不难想到去百度一下“日历加密”，这题只是做了简单的修改。\nSAT1,THU1,MON3,MON2,WED3,SUN2,THU1,SUN4,FRI3,THU1,MON4,MON4,FRI4,THU3,SUN4,SUN2,TUE4,THU1,FRI1,MON3,MON2\n懒得百度的话，也不难看出前三个字母代表周一到周日，紧跟的数字范围是 1～4，所以他们代表两个坐标，列举出来并用a～z替换1～26，即可得到 flag。\neasyXor 做出这题只需要知道异或的逆运算还是异或，反过来跑一遍就拿到了 flag。\nexp:\ncipher=[72, 63, 38, 12, 8, 30, 30, 6, 82, 4, 84, 88, 92, 7, 79, 29, 8, 90, 85, 26, 25, 87, 80, 10, 20, 20, 9, 4, 80, 73, 31, 5, 82, 0, 1, 92, 0, 0, 94, 81, 4, 85, 27, 35] flag=\u0026quot;\u0026quot; cipher+=[ord(\u0026quot;^\u0026quot;)] for i in range(len(cipher)-1): flag = chr(cipher[len(cipher)-i-2]^cipher[len(cipher)-i-1])+flag cipher[len(cipher)-i-2]=ord(flag[0]) print(flag) # 0xGame{ec15a9eb-08b7-4c39-904d-27eed888f73f} 发现有的学弟跑完脚本手动补0，exp正确的话，是可以得到完整flag的。","title":"0xGame 2020 Crypto Problems"},{"content":"Writeup for 强网杯 2020 强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered\n然后看到里面提到可以这样获取 $p$：\n$$ \\large gcd(m^{c_1}-Sig^e,N)=p $$\n这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。\nfrom Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n//p flag = \u0026quot;flag{\u0026quot; + sha1(long_to_bytes(p if p \u0026lt; q else q)).hexdigest() + \u0026quot;}\u0026quot; print(flag) # flag{601cb6f6d990ed5b89cf0de60508a95c07543793} bank proof_of_work:\nfrom hashlib import sha256 from string import digits, ascii_letters from pwn import * r = remote(\u0026quot;39.101.134.52\u0026quot;, \u0026quot;8005\u0026quot;) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXX+\u0026quot;) suffix = r.recv(17).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, digits + ascii_letters, 3, 'upto') r.recvuntil(\u0026quot;Give me XXX:\u0026quot;) r.sendline(prefix) def send_teamtoken(): r.recvuntil(\u0026quot;teamtoken:\u0026quot;) r.sendline(\u0026quot;icqc487d794f00cdb22409bd5ea7e736\u0026quot;) proof_of_work() send_teamtoken() r.interactive() 连上去过完 proof of work，输入一个字符串作为名字，会给出余额和菜单：\nyour cash:10 you can choose: transact, view records, provide a record, get flag, hint\n试了一下发现可以向某个商人交易，例如 Alice 1 向 Alice 支付，然后会通过 hint 里面的函数生成这次交易的记录，同时我们也可以给他发送一条记录来伪造一次交易。有了足够的余额（1000）就可以买 flag 了。\n但是，出题人好像没滤交易时的负数？然后\u0026hellip;.\n可以交易负金额可还行，就拿到了 flag。。。\nWeb dice2cry 题目描述：web+cry，输入team_token进入一个掷骰子的页面，在cookie可以看到encrypto_flag，public_n，public_e，应该是 RSA，然后每次掷骰子都会向abi.php get一次数据，abi.php也可以单独调用，相当于于一个随机返回 0～2 整数的 api，以 json 的形式返回值。然后有 js 来操作一下返回 1～6 的点数。\n然后可以在 http://106.14.66.189/abi.php.bak 拿到 abi.php 的源码：\n\u0026lt;?php session_start(); header(\u0026quot;Content-type:text/html;charset=utf-8\u0026quot;); $data = json_decode($json_string, true); $rand_number = isset($_POST['this_is.able']) ? $_POST['this_is.able'] : mt_ rand(); $n = gmp_init($data['n']); $d = gmp_init($data['d']); $c = gmp_init($rand_number); $m = gmp_powm($c,$d,$n); $v3 = gmp_init('3'); $r = gmp_mod($m,$v3); $result=(int)gmp_strval($r); $dice = array(\u0026quot;num\u0026quot;=\u0026gt;$result); $json_obj = json_encode($dice); echo $json_obj; ?\u0026gt; 如果没有 post 一个数字，$rand_number 就是随机的，否则就是 post 的那个数字，所以 $rand_number 是可控的。\n然后服务端会通过私钥 d 对 $rand_number 解密，并返回解密后模 3 的值，也就是一开始看到的 0～2 的“随机数”，所以这题显然是选择密文攻击，CTF wiki 上有关于 RSA parity oracle 原理的详细介绍，和这一题唯一的区别是 CTF wiki 上的是模 2。\n我们可以类比 CTF wiki 上的推理来对这题模三情况的推理，最终的思想是一样的，不断缩小上下界的范围逼近正确值。\nupper 和 lower 的初始值分别为 n 和 0，这是明文的范围。还要知道这一题的 n 模 3 得 2。\n第 $i$ 次，明文P的范围是：\n$$ \\frac { x N } { 3 ^ { i } } \\leq P \u0026lt; \\frac { x N + N } { 3 ^ { i } }.\\ \\ (\\ 1\\ ) $$\n第 $i+1$ 次，明文P的范围是：\n$$ \\frac { k N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { k N + N } { 3 ^ { i+1 } }.\\ \\ (\\ 2\\ ) $$\n对于不同的返回值（0～2），可以体现出 $k$ 模 3 后的特征（0～2）：\n$$ \\begin{cases} k=3y, \u0026amp;if\u0026amp;\\ k\\ \\equiv 0\\ (mod\\ 3),y\\in N^* \\\\ k=3y+1, \u0026amp;if\u0026amp;\\ k\\ \\equiv 1\\ (mod\\ 3),y\\in N^* \\\\ k=3y+2, \u0026amp;if\u0026amp;\\ k\\ \\equiv 2\\ (mod\\ 3),y\\in N^* \\end{cases} $$\n将不等式（1）分子分母同时乘 3，第 $i$ 次的：\n$$ \\frac { 3x N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3x N + 3N } { 3 ^ { i+1 } }.\\ \\ (\\ 3\\ ) $$\n如果返回 0，将 $k = 3y$ 带入 (2) 得：\n$$ \\frac { 3y N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3y N + N } { 3 ^ { i+1 } }.\\ \\ (\\ 4\\ ) $$\n由于P一定存在，所以（3）和（4）存在交集，所以 y = x，那么只需要更新上界“upper”：\nupper = (2*lower+upper)//3 如果返回 1，将 $k = 3y + 1$ 带入（2），\n$$ \\frac { 3y N+N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3y N + 2N } { 3 ^ { i+1 } }.\\ \\ (\\ 5\\ ) $$\n由于P一定存在，所以（3）和（5）存在交集，所以 $y = x$，那么需要同时更新上界和下界：\nupper = (lower+2*upper)//3; lower = (2*lower+upper)//3 如果返回 2，将 $k = 3y + 2$ 带入（2），\n$$ \\frac { 3y N +2N} { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3y N + 3N } { 3 ^ { i+1 } }.\\ \\ (\\ 6\\ ) $$\n由于P一定存在，所以（3）和（6）存在交集，所以 $y = x$，那么只需要更新下界“lower”：\nlower = (lower+2*upper)//3 这样每一次范围的更新都会缩小范围，最终逼近明文m。\nimport requests from Crypto.Util.number import* PHPSESSID = \u0026quot;jpa80o0gbpi4djabq80iopu7st\u0026quot; c = 47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274 n = 0x8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157 e = 0x10001 head = { 'User-Agent': \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\u0026quot; } cookies = {\u0026quot;PHPSESSID\u0026quot;: \u0026quot;jpa80o0gbpi4djabq80iopu7st\u0026quot;, \u0026quot;public_n\u0026quot;: \u0026quot;8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157\u0026quot;, \u0026quot;public_e\u0026quot;: \u0026quot;010001\u0026quot;, \u0026quot;encrypto_flag\u0026quot;: \u0026quot;47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274\u0026quot;} r = requests.post(\u0026quot;http://106.14.66.189/main.php\u0026quot;, cookies=cookies, headers=head) def getNum(new_c): r = requests.post(\u0026quot;http://106.14.66.189/abi.php\u0026quot;, data={'this[is.able': new_c}, cookies=cookies, headers=head) print(r.text) return int(r.text[7]) upper = n lower = 0 i = 1 while True: # n%3==2 power = pow(3, i, n) new_c = (pow(power, e, n)*c) % n # pow(3^{i}*m,e,n) rev = getNum(new_c) if rev == 0: # power*m mod n == 0 upper = (2*lower+upper)//3 elif rev == 1: # power*m mod n == (1 or 2) temp = upper upper = (lower+2*upper)//3 lower = (2*lower+temp)//3 else: lower = (lower+2*upper)//3 if (upper-lower) \u0026lt; 2: break i += 1 print(long_to_bytes(upper)) Crypto modestudy from Crypto.Util.number import * from string import digits, ascii_letters from binascii import unhexlify from hashlib import sha256 from pwn import * import os r = remote(\u0026quot;139.224.254.172\u0026quot;, \u0026quot;7777\u0026quot;) def proof_of_work(): # 多线程爆破 rev = r.recvuntil(\u0026quot;sha256(\u0026quot;) suffix = r.recvuntil(\u0026quot;+\u0026quot;)[:-1].decode() rev = r.recvuntil(\u0026quot;?=\u0026quot;) def f(x): hashresult = hashlib.sha256(suffix.encode()+x.encode()).digest() bits = ''.join(bin(j)[2:].zfill(8) for j in hashresult) return bits.startswith('0'*5) prefix = util.iters.mbruteforce(f, digits + ascii_letters, 8, 'upto') r.sendline(prefix) def challenge1(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;session=\u0026quot;) session = r.recv(16) r.recvuntil(\u0026quot;checksum=\u0026quot;) checksum = r.recv(64) r.recvuntil(\u0026quot;cookie:\u0026quot;) plain = \u0026quot;session={};admin=0\u0026quot;.format(session) bit = ((unhexlify(checksum)[15]) ^ ord('0') ^ ord('1')) checksum = checksum.decode() checksum_final = checksum[:30] + hex(bit)[2:] + checksum[32:] newcookie = \u0026quot;session={};admin=1;checksum={}\u0026quot;.format( session.decode(), checksum_final) r.sendline(newcookie) def challenge2(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) r.recvuntil(\u0026quot;sha256(iv)=\u0026quot;) sha_iv = r.recv(64).decode() r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.sendline(\u0026quot;A\u0026quot;*32) r.recvuntil(\u0026quot;[+] \u0026quot;) plain = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1] m0 = bytes.fromhex(plain[:32].decode()) m1 = bytes.fromhex(plain[32:].decode()) iv = long_to_bytes(bytes_to_long(m0) ^ bytes_to_long(m1) ^ bytes_to_long(b\u0026quot;A\u0026quot;*16)) r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) assert sha256(iv).hexdigest() == sha_iv r.sendline(iv.hex()) def challenge3(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;3\u0026quot;) r.recvuntil(\u0026quot;128bit_ecb_encrypt(cookie):\u0026quot;) cipher = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() cipher = bytearray.fromhex(cipher) for i in range(16): cipher[32 + i] = cipher[64 + i] r.sendline(cipher.hex()) def challenge4(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;4\u0026quot;) r.recvuntil(\u0026quot;sha256(secret)=\u0026quot;) sha_secret = r.recv(64).decode() secret = b\u0026quot;\u0026quot; for Byte in range(16): byte_len = (15 - (Byte % 16)) if ((Byte % 16) != 15) else 16 bound = ((byte_len + Byte + 1) // 16) * 32 r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;input(encode hex):\u0026quot;) r_ = os.urandom(byte_len) r.sendline(r_.hex()) r.recvuntil(\u0026quot;encrypted msg: \u0026quot;) C_ = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() print(\u0026quot;brute force {} byte\u0026quot;.format(Byte+1)) for i in range(256): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;input(encode hex):\u0026quot;) Pi = int((r_.hex()+secret.hex())[-30:]+long_to_bytes(i).hex(), 16) r.sendline(long_to_bytes(Pi).hex()) r.recvuntil(\u0026quot;encrypted msg: \u0026quot;) Ci = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() if Ci[:32] == C_[bound-32:bound]: secret += long_to_bytes(i) print(\u0026quot;Current secret: {}\u0026quot;.format(secret)) break r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) r.recvuntil(\u0026quot;secret(encode hex):\u0026quot;) r.sendline(secret.hex()) def challenge5(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;5\u0026quot;) r.recvuntil(\u0026quot;sha256(secret)=\u0026quot;) sha_secret = r.recv(64).decode() r.recvuntil(\u0026quot;(secret).encode(\\\u0026quot;hex\\\u0026quot;)=\u0026quot;) c = r.recv(32) secret = \u0026quot;\u0026quot; for i in range(8): part_c = c[i*4:i*4+4] guess = \u0026quot;\u0026quot; for j in range(0xffff): temp = \u0026quot;0\u0026quot;*(4-len(hex(j)[2:]))+hex(j)[2:] guess += temp if len(guess) == 1024: # 由于向服务端发送接收时间成本较高，所以一次发送1024bits加快爆破速度 r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;input(encode hex):\u0026quot;) r.sendline(guess) r.recvuntil(\u0026quot;encode(\\\u0026quot;hex\\\u0026quot;):\u0026quot;) temp_c = r.recv(1024) flag = False for k in range(256): if temp_c[k*4:k*4+4] == part_c: secret += guess[k*4:k*4+4] flag = True break if flag: break guess = \u0026quot;\u0026quot; print(\u0026quot;Current secret:\u0026quot;, secret) r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) r.recvuntil(\u0026quot;secret(encode hex):\u0026quot;) r.sendline(secret) def challenge6(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;6\u0026quot;) r.recvuntil(\u0026quot;iv+aes128_cbc(key,iv,padding(secret)):\u0026quot;) iv_cbc = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() iv = bytearray.fromhex(iv_cbc[:32]) cbc = bytearray.fromhex(iv_cbc[32:64]) mid = [] new_iv = bytearray(b'\\x00' * 16) count = 1 for i in range(16): for j in range(256): new_iv[15 - i] = j upload = new_iv + cbc r.sendline('1') r.recvuntil(\u0026quot;input your iv+c (encode hex):\u0026quot;) r.sendline(upload.hex()) search = r.recvuntil(\u0026quot;your choice:\u0026quot;) if b\u0026quot;success\u0026quot; in search: print(search) ans = j ^ count break count += 1 mid.append(ans) for m in range(15 - i, 16): new_iv[m] = count ^ mid[15 - m] find = \u0026quot;\u0026quot; for i in range(16): find += hex(iv[i] ^ mid[15 - i])[2:].rjust(2, '0') r.sendline('2') r.recvuntil(\u0026quot;secret(encode hex):\u0026quot;) r.sendline(find) proof_of_work() r.recvuntil(\u0026quot;teamtoken=\u0026quot;) r.sendline(\u0026quot;icqc487d794f00cdb22409bd5ea7e736\u0026quot;) challenge1() challenge2() challenge3() challenge4() challenge5() challenge6() r.interactive() # 这边再输入7得到flag # icqc487d794f00cdb22409bd5ea7e736 # flag{86ac04cc901a04462c55923eedf5affe} ","permalink":"https://slightwind.cn/posts/ctf/writeup-for-qwb-2020/","summary":"Writeup for 强网杯 2020 强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered\n然后看到里面提到可以这样获取 $p$：\n$$ \\large gcd(m^{c_1}-Sig^e,N)=p $$\n这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。\nfrom Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n//p flag = \u0026quot;flag{\u0026quot; + sha1(long_to_bytes(p if p \u0026lt; q else q)).","title":"Writeup for 强网杯 2020"},{"content":"Writeup for Crypto problems in WMCTF 2020 piece_of_cake 两个函数大概都是一个类似 RSA 的操作，加上一个加密算法，之前的一篇博客有介绍，\nAn Introduction to Mathematical Cryptography 书里称这个算法是 “a toy model of a real public key cryptosystem”。（bitlength 凑的刚刚好可以保证解密，很巧妙）\nmake_cake() 这边的 cake 很小（256bits）符合正常解密的条件，可以直接用高斯格基规约算法，然而 eat_cake() 这边的 cake 是比较大的（768bits）就会导致在取模的时候值容易发生改变，所以给它加上几个 g，并使用给出的 pow 来验证是否是正确的 cake。\n规约得到的密钥对 $(F, G)$ 是不一定等于原来的密钥对 $(f, g)$，但它们在解密过程是等价的，我们得到的密钥对 (F, G) 长度都是 768bits。\nexp 多跑几次就能得到 flag。\nfrom gmpy2 import iroot, sqrt, invert from pwn import remote from string import ascii_letters, digits from hashlib import sha256 r = remote('170.106.35.18', 8631) def proof_of_work(txt, Hash): for a in ascii_letters+digits: for b in ascii_letters+digits: for c in ascii_letters+digits: if sha256((a+b+c+txt).encode()).hexdigest() == Hash: return a+b+c def gaussian(v1, v2): while True: if sqrt(v2[0]**2+v2[1]**2) \u0026lt; sqrt(v1[0]**2+v1[1]**2): v1, v2 = v2, v1 m = int((v1[0]*v2[0]+v1[1]*v2[1])/(v1[0]**2+v1[1]**2)) if m == 0: return (v1, v2) v2 = [v2[0]-m*v1[0], v2[1]-m*v1[1]] r.recvuntil(\u0026quot;XXX+\u0026quot;) nonce = r.recv(17).decode() r.recvuntil(\u0026quot; == \u0026quot;) target = r.recv(64).decode() r.recvuntil(\u0026quot;\\nGive me XXX:\u0026quot;) w = proof_of_work(nonce, target) r.send(str(w)+\u0026quot;\\n\u0026quot;) r.recvuntil(\u0026quot;What's your choice?\\n\u0026quot;) r.send(\u0026quot;1\\n\u0026quot;) r.recvline() temp = r.recvline().strip().decode().split(\u0026quot; \u0026quot;) q, h, c = [int(i) for i in temp] N = int(r.recvline().strip().decode()) cip = int(r.recvline().strip().decode()) s1, s2 = gaussian([1, h], [0, q]) f, g = s1[0], s1[1] cake = (c*f % q) % g cake = invert(f, g)*cake % g for k in range(10000): if pow(cake, 0x10001, N) == cip: print(\u0026quot;cake is: \u0026quot;, cake) break cake += g r.send(str(cake)+\u0026quot;\\n\u0026quot;) print(r.recvline().strip().decode()) #WMCTF{Wh4t_A_pi3ce_of_CAKE!} babySum 密度接近 0.8 的子集和问题（Subset sum problem），BKZ-24 跑得比较慢好在成功率高一点。\nfrom json import load def check(sol, A): s = 0 for x, a in zip(sol, A): s += x*a return s k, n, d = 20, 120, 0.8 s, A = load(open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;)) N = 50 lat = [] for i, a in enumerate(A): lat.append([1*(j == i) for j in range(n)] + [N*a] + [N]) lat.append([0]*n + [N*s] + [k*N]) itr = 0 while True: itr += 1 print(itr) nums = lat[::] shuffle(nums) m = matrix(ZZ, nums) ml = m.BKZ(block_size=24) for i, row in enumerate(ml): if not (-1 \u0026lt;= min(row[:-1]) and max(row[:-1]) \u0026lt;= 1): continue for i in range(len(row)): if row[i] \u0026lt; 0: row[i] *= -1 temp_bool = (check(row, A) == s) if temp_bool == True: print(i, row) quit() #0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 到 check.py 里面运行输入得到 flag：WMCTF{83077532752999414286785898029842440}\nGame 对 AES 选择明文攻击，逐个字节爆破。\nCBC 模式的 AES 加密，块长度为 b，C0 是初始向量 IV，IV 是和服务器端同步的最新的加密向量。\nIV 始终和服务器端的 IV 同步，用来消除掉当前加密的一次异或，再用 C0 异或一下就构造出了 Step2 的加密结果的第一个 block。所以爆破一个 byte 最多会和服务器交互 256 次，不过平均下来约 128 次得到一个 byte。\n以 16bytes 块长度为例，让服务器把已知的 15bytes 的 r 和未知部分的前 1byte 拼起来加密，然后本地去枚举最后一个 byte 和 15bytes 拼起来发送到服务器加密，如果加密后的第一个块和在服务器端拼起来的那段是相等的，就说明猜对了。就多知道了一个 secret 的 byte，把它当作已知，再进行下一个 byte 的枚举。\nfrom pwn import remote from hashlib import sha256 from Crypto.Util.number import * import string import os r = remote('81.68.174.63', 16442) def proof_of_work(txt, Hash): S = string.ascii_letters+string.digits for a in S: for b in S: for c in S: for d in S: if sha256((a+b+c+d+txt).encode()).hexdigest() == Hash: print(a+b+c+d) return a+b+c+d def select_x(x): r.recvuntil(\u0026quot;3. exit\\n\u0026quot;) r.recvuntil(\u0026quot;\u0026gt;\u0026quot;) r.send(str(x)) r.recvuntil(\u0026quot;(in hex): \u0026quot;) r.recvuntil(\u0026quot;XXXX+\u0026quot;) nonce = r.recv(16).decode() r.recvuntil(\u0026quot; == \u0026quot;) target = r.recv(64).decode() print(\u0026quot;waiting....\u0026quot;) w = proof_of_work(nonce, target) r.send(str(w)) print(\u0026quot;----------proof of work is ok!----------\u0026quot;) r.recvuntil(\u0026quot;IV is: \u0026quot;) IV = r.recv(32).decode() # 16 bytes -\u0026gt; 32 hexlength print(\u0026quot;IV is: {}\u0026quot;.format(IV)) secret = b\u0026quot;\u0026quot; for Byte in range(48): byte_len = (15 - (Byte % 16)) if ((Byte % 16) != 15) else 16 bound = ((byte_len + Byte + 1) // 16) * 32 select_x(1) r_ = os.urandom(byte_len) r.send(r_.hex()) C_ = r.recvline().strip().decode() C0 = IV if bound==32 else C_[bound-64:bound-32] IV = C_[-32:] print(\u0026quot;brute force {} byte\u0026quot;.format(Byte+1)) for i in range(256): select_x(1) Pi = int(C0, 16) ^ int(IV, 16) ^ int((r_.hex()+secret.hex())[-30:]+long_to_bytes(i).hex(), 16) r.send(long_to_bytes(Pi).hex()) Ci = r.recvline().strip().decode() IV = Ci[-32:] if Ci[:32] == C_[bound-32:bound]: secret += long_to_bytes(i) print(\u0026quot;Current secret: {}\u0026quot;.format(secret)) break print(\u0026quot;secret is: {}\u0026quot;.format(secret)) select_x(2) r.send(secret.hex()) flag = r.recvline().strip().decode() print(flag) ","permalink":"https://slightwind.cn/posts/ctf/writeup-for-crypto-problems-in-wmctf-2020/","summary":"Writeup for Crypto problems in WMCTF 2020 piece_of_cake 两个函数大概都是一个类似 RSA 的操作，加上一个加密算法，之前的一篇博客有介绍，\nAn Introduction to Mathematical Cryptography 书里称这个算法是 “a toy model of a real public key cryptosystem”。（bitlength 凑的刚刚好可以保证解密，很巧妙）\nmake_cake() 这边的 cake 很小（256bits）符合正常解密的条件，可以直接用高斯格基规约算法，然而 eat_cake() 这边的 cake 是比较大的（768bits）就会导致在取模的时候值容易发生改变，所以给它加上几个 g，并使用给出的 pow 来验证是否是正确的 cake。\n规约得到的密钥对 $(F, G)$ 是不一定等于原来的密钥对 $(f, g)$，但它们在解密过程是等价的，我们得到的密钥对 (F, G) 长度都是 768bits。\nexp 多跑几次就能得到 flag。\nfrom gmpy2 import iroot, sqrt, invert from pwn import remote from string import ascii_letters, digits from hashlib import sha256 r = remote('170.","title":"Writeup for Crypto problems in WMCTF 2020"},{"content":"Writeup for Crypto problems in SCTF 2020 Crypto RSA 同一个解密指数用了三次加密同一段明文，这本书第129页介绍了 Common Private Exponent Attack：\nCRYPTANALYSIS OF RSA AND ITS VARIANTS\n这题的情况和里面的样例是一样的，可以直接套用这个格子然后LLL即可算出d：\nfrom binascii import hexlify, unhexlify e0 = 0x9a7dc3e0f2a3531035b18541df28b8407502c2101970862d19b107ea7dc37554e5ac620b3ce4be38e5d6fd6b1920aef9e017aa383e3c1dd8e7847dc7715832fa450d1b572cfe133c702c598ed022d40ad193608bcfeb9b9aebc910dd3257caa42e503764475b89bb99056822e21ba5723d9eee3196a6fca3debd1c7687fd310d n0 = 0xa98c363cf72b3bce39bae63a9d3d5ba0acaa7e81f9b1191ce20bb0b54a8c19216d20af640121c482e882c0772671280af9f42c764128a94104266dd65c0bcd93766e0f0ce119072302b7f3e5cc4b5cfece38e4124041a8f8dcbdb9193f35bede2c284e40f80398bf0ba0609229fa27faa2d51c552ff1ed911a6f6f220b7b6fed c0 = 0x57fcf94d27451fc35386e0f6eff53c6540ccff51862c992f4b59d0d49fa350493041c5be2f54a37f3afe81aa5e9a738461b3b709a4611a7289c83d769cb02f3c5d18e65d68f6fff1df0418c8a7351be1d7cce1a7514797c9bdc67d969224d783a5d004d67a5ef986d564ab1945e5c83a53d8d1dcb5e45323764a200e737b80c e1 = 0xbb31e6433057edfed88b6a37e4419a828d1575b2b9d04a5058cd912d5efb06b2f0c5c06c5d0dd35ebeda8afa8a9cc945c244c13fc501c76e720c2c04cab70c9f906c4a810defdd84c3a38507cdf79b4e4b0c7770cc3d2d862ea9bd5fe2469290d9d2a09c8164437e9d5b7b3a9c49d111e5caa9577f8ed1ef1916ec4cb71bbb8d n1 = 0xbcc2c4f4f51abb236b411f1f9d86d71133eb2d4ffe45a319b6ab6df1174b9ee619e696666702655b6c185735298cc008e9b7df842c480d3d42bb67228b6c7408a7afe68ab85ee1c80f43c8c52764c79ffdecc6e3a5ea76c1123affe9f02c649e5f5ca0a4082107ce4a2040e5756bf6a2b34757aefa5fb6fec6d7a9e86f0c8159 c1 = 0xacf91d2b6a300a60193485ef2e1127b5863c69da71ab9e7d71a3213e960a73e42f8e8031bf0ef20184ae0a259fd50260aacce06546af2f8bbef8a2f360c8f7511ad9c99d8715012ce0a4fa8dbba8c10d74f477156076bdfda80dc449eec3b45c7cd82802ecce7635e186d29744df04fcf812dc7e2d2f3c8cd751e4fcea43db1e e2 = 0x332f82f338c8b84524103d310d59fc541b66705948c57eaf972b26bb209a6ddde3d6930948a559ac1a3a26790cb1a133a90b999b164d4e22014b27660dad4e5639ffc19bcd2e4961c5b00b9116f49c3c02880bb3ad32972287442d6a86a9c86cd3981ee1084df4322edb9c5da39146e10de0586c8b5433a851d649a45c5a73cd n2 = 0xd0ad4d11576bb041ea2ce53f354dba362a93411a37f4a529e8b5eeae83a3437df6bd5e4e1f87a4d324a6ce2850f3568c929f5d5f73fef45bda03fa7bff00304a1eb833ce3535ee3552aa62b644f0d3c1679fe2c57b978c695f03e5b2d18d9b0821c7e0ca332f552b12e2b7109210d051bbe9d9b9e3cc3b16c81e77ebca65aca3 c2 = 0xc59078ae7cb454c970f272f595da71ae2b681156a1ce7112d9b96346f38bcdca87192ea39ac273851210e9f98f0d89f1bc657ce69ca14708cba8b319160a1f67b8cfc3643dc9b6a70769d8d64a9a3504d799f3d9afca7c7114880f4ccb5bef35738e660e4ede1c884f4a60f1f0e559fb754abd8e4b905ad3626a876bea43ec8e M = isqrt(max(n0, n1, n2)) M = 10704523536419069847275584063070587220303695362157261593514212717132031073368631333467085885236049291630529090309346493924305038011673707087598638071644281 B = matrix(ZZ, [ [M, e0, e1, e2], [0, -n0, 0, 0], [0, 0, -n1, 0], [0, 0, 0, -n2], ]) BL = B.LLL() temp = int(BL[0, 0]) if temp \u0026lt; 0: temp *= -1 d = int(temp//M) m = hex(pow(c2, d,n2))[2:] print(unhexlify(m)) print(d) #b'SCTF{673ff064da31c0d7aee56884b01a09}' #1235666648165896286568418878956456259719846117790808720561608081687435539909970845494445047046945948132187344353861 Lattice 这题是109维的NTRU加密，在An Introduction to Mathematical Cryptography书里有介绍使用格基规约攻击NTRU的算法，如图构建一个格子，然后进行约减，一开始用LLL，没有找到合适的约减基，然后用BKZ-24很容易找到了，可能由于格比较稀疏，尽管格子相当于是218维，测试了BKZ-32都可以在20秒之内规约完成，取约减后的最短向量，就得到了f\u0026rsquo; 和 g\u0026rsquo;（前n位是f\u0026rsquo;，后n位g\u0026rsquo;）。\n用得到的f\u0026rsquo;进行NTRU解密得到的明文应该是一个01串，在头部补合适数量的0变成全部可打印字符就是flag了。\nZx.\u0026lt;x\u0026gt; = ZZ[] n = 109 q = 2048 p = 3 pub_key = 510*x ^ 108 - 840*x ^ 107 - 926*x ^ 106 - 717*x ^ 105 - 374*x ^ 104 - 986*x ^ 103 + 488*x ^ 102 + 119*x ^ 101 - 247*x ^ 100 + 34*x ^ 99 + 751*x ^ 98 - 44*x ^ 97 - 257*x ^ 96 - 749*x ^ 95 + 648*x ^ 94 - 280*x ^ 93 - 585*x ^ 92 - 347*x ^ 91 + 357*x ^ 90 - 451*x ^ 89 - 15*x ^ 88 + 638*x ^ 87 - 624*x ^ 86 - 458*x ^ 85 + 216*x ^ 84 + 36*x ^ 83 - 199*x ^ 82 - 655*x ^ 81 + 258*x ^ 80 + 845*x ^ 79 + 490*x ^ 78 - 272*x ^ 77 + 279*x ^ 76 + 101*x ^ 75 - 580*x ^ 74 - 461*x ^ 73 - 614*x ^ 72 - 171*x ^ 71 - 1012*x ^ 70 + 71*x ^ 69 - 579*x ^ 68 + 290*x ^ 67 + 597*x ^ 66 + 841*x ^ 65 + 35*x ^ 64 - 545*x ^ 63 + 575*x ^ 62 - 665*x ^ 61 + 304*x ^ 60 - 900*x ^ 59 + 428*x ^ 58 - 992*x ^ 57 - 241*x ^ 56 + 953*x ^ 55 - 784*x ^ 54 - 730*x ^ 53 - 317*x ^ 52 + 108*x ^ 51 + 180*x ^ 50 - 881*x ^ 49 - 943*x ^ 48 + 413*x ^ 47 - 898*x ^ 46 + 453*x ^ 45 - 407*x ^ 44 + 153*x ^ 43 - 932*x ^ 42 + 262*x ^ 41 + 874*x ^ 40 - 7*x ^ 39 - 364*x ^ 38 + 98*x ^ 37 - 130*x ^ 36 + 942*x ^ 35 - 845*x ^ 34 - 890*x ^ 33 + 558*x ^ 32 - 791*x ^ 31 - 654*x ^ 30 - 733*x ^ 29 - 171 * x ^ 28 - 182*x ^ 27 + 644*x ^ 26 - 18*x ^ 25 + 776*x ^ 24 + 845*x ^ 23 - 675*x ^ 22 - 741*x ^ 21 - 352*x ^ 20 - 143*x ^ 19 - 351*x ^ 18 - 158*x ^ 17 + 671*x ^ 16 + 609*x ^ 15 - 34*x ^ 14 + 811*x ^ 13 - 674*x ^ 12 + 595*x ^ 11 - 1005*x ^ 10 + 855*x ^ 9 + 831*x ^ 8 + 768*x ^ 7 + 133*x ^ 6 - 436*x ^ 5 + 1016 * x ^ 4 + 403*x ^ 3 + 904*x ^ 2 + 874*x + 248 e = -453*x ^ 108 - 304*x ^ 107 - 380*x ^ 106 - 7*x ^ 105 - 657*x ^ 104 - 988*x ^ 103 + 219*x ^ 102 - 167*x ^ 101 - 473*x ^ 100 + 63*x ^ 99 - 60*x ^ 98 + 1014*x ^ 97 - 874*x ^ 96 - 846*x ^ 95 + 604*x ^ 94 - 649*x ^ 93 + 18*x ^ 92 - 458*x ^ 91 + 689*x ^ 90 + 80*x ^ 89 - 439*x ^ 88 + 968*x ^ 87 - 834*x ^ 86 - 967*x ^ 85 - 784*x ^ 84 + 496*x ^ 83 - 883*x ^ 82 + 971*x ^ 81 - 242*x ^ 80 + 956*x ^ 79 - 832*x ^ 78 - 587*x ^ 77 + 525*x ^ 76 + 87*x ^ 75 + 464*x ^ 74 + 661*x ^ 73 - 36*x ^ 72 - 14*x ^ 71 + 940*x ^ 70 - 16*x ^ 69 - 277*x ^ 68 + 899*x ^ 67 - 390*x ^ 66 + 441*x ^ 65 + 246*x ^ 64 + 267*x ^ 63 - 395*x ^ 62 + 185*x ^ 61 + 221*x ^ 60 + 466*x ^ 59 + 249*x ^ 58 + 813*x ^ 57 + 116*x ^ 56 - 100 * x ^ 55 + 109*x ^ 54 + 579*x ^ 53 + 151*x ^ 52 + 194*x ^ 51 + 364*x ^ 50 - 413*x ^ 49 + 614*x ^ 48 + 367*x ^ 47 + 758*x ^ 46 + 460*x ^ 45 + 162*x ^ 44 + 837*x ^ 43 + 903*x ^ 42 + 896*x ^ 41 - 747*x ^ 40 + 410*x ^ 39 - 928*x ^ 38 - 230*x ^ 37 + 465*x ^ 36 - 496*x ^ 35 - 568*x ^ 34 + 30*x ^ 33 - 158*x ^ 32 + 687*x ^ 31 - 284*x ^ 30 + 794*x ^ 29 - 606 * x ^ 28 + 705*x ^ 27 - 37*x ^ 26 + 926*x ^ 25 - 602*x ^ 24 - 442*x ^ 23 - 523*x ^ 22 - 260*x ^ 21 + 530*x ^ 20 - 796*x ^ 19 + 443*x ^ 18 + 902*x ^ 17 - 210*x ^ 16 + 926*x ^ 15 + 785*x ^ 14 + 440*x ^ 13 - 572*x ^ 12 - 268*x ^ 11 - 217*x ^ 10 + 26*x ^ 9 + 866*x ^ 8 + 19*x ^ 7 + 778*x ^ 6 + 923*x ^ 5 - 197 * x ^ 4 - 446*x ^ 3 - 202*x ^ 2 - 353*x - 852 pub_key_coeffs = pub_key.coefficients() def mul(f, g): return (f * g) % (x ^ n-1) def bal_mod(f, q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g) def inv_mod_prime(f, p): T = Zx.change_ring(Integers(p)).quotient(x ^ n-1) return Zx(lift(1 / T(f))) M_h = Matrix(n*2, n*2, 0) for i in range(n): M_h[i, i], M_h[n+i, n+i] = 1, q for j in range(n): M_h[i, n+j] = pub_key_coeffs[j] pub_key_coeffs.insert(0, pub_key_coeffs.pop()) M_r = M_h.BKZ(block_size=24) t = [i for i in M_r[0]] f, g = Zx(t[:n]), Zx(t[n:]) fp = inv_mod_prime(f, p) a = bal_mod(mul(f, e), q) m = bal_mod(mul(fp, a), p) for k in range(8): flag = k*\u0026quot;0\u0026quot;+\u0026quot;\u0026quot;.join([str(i) for i in m.list()]) flag += (8-len(flag) % 8)*\u0026quot;0\u0026quot; temp = \u0026quot;\u0026quot; for i in range(len(flag)//8): temp += chr(int(flag[i*8:i*8+8], 2)) print(temp) flag：SCTF{@#26f35b89d3#@}\nMisc Can you hear 用MMSSTV，可以直接看到flag。。。\nSCTF{f78fsd1423fvsa}\neasymisc 倒序补上文件头得到可以正常显示的图片（又是熟悉的这个男人），图片上有flag{that_is_not_right_man}。\nfrom binascii import hexlify,unhexlify data=hexlify(open(\u0026quot;galf_si_erehw.jpg\u0026quot;,\u0026quot;rb\u0026quot;).read()) open(\u0026quot;where_is_flag.jpg\u0026quot;,\u0026quot;wb\u0026quot;).write(unhexlify(data[::-1])) 然后winhex打开可以看到一堆字符串，提示用RC4解密密文 \u0026ldquo;xoBTuw36SfH4hicvCzFD9ESj\u0026rdquo;，密钥就是图片上花括号里的字符串，找网站在线解密就可以得到flag：SCTF{St@Y_@T_H0Me}\n","permalink":"https://slightwind.cn/posts/ctf/writeup-for-crypto-problems-in-sctf-2020/","summary":"Writeup for Crypto problems in SCTF 2020 Crypto RSA 同一个解密指数用了三次加密同一段明文，这本书第129页介绍了 Common Private Exponent Attack：\nCRYPTANALYSIS OF RSA AND ITS VARIANTS\n这题的情况和里面的样例是一样的，可以直接套用这个格子然后LLL即可算出d：\nfrom binascii import hexlify, unhexlify e0 = 0x9a7dc3e0f2a3531035b18541df28b8407502c2101970862d19b107ea7dc37554e5ac620b3ce4be38e5d6fd6b1920aef9e017aa383e3c1dd8e7847dc7715832fa450d1b572cfe133c702c598ed022d40ad193608bcfeb9b9aebc910dd3257caa42e503764475b89bb99056822e21ba5723d9eee3196a6fca3debd1c7687fd310d n0 = 0xa98c363cf72b3bce39bae63a9d3d5ba0acaa7e81f9b1191ce20bb0b54a8c19216d20af640121c482e882c0772671280af9f42c764128a94104266dd65c0bcd93766e0f0ce119072302b7f3e5cc4b5cfece38e4124041a8f8dcbdb9193f35bede2c284e40f80398bf0ba0609229fa27faa2d51c552ff1ed911a6f6f220b7b6fed c0 = 0x57fcf94d27451fc35386e0f6eff53c6540ccff51862c992f4b59d0d49fa350493041c5be2f54a37f3afe81aa5e9a738461b3b709a4611a7289c83d769cb02f3c5d18e65d68f6fff1df0418c8a7351be1d7cce1a7514797c9bdc67d969224d783a5d004d67a5ef986d564ab1945e5c83a53d8d1dcb5e45323764a200e737b80c e1 = 0xbb31e6433057edfed88b6a37e4419a828d1575b2b9d04a5058cd912d5efb06b2f0c5c06c5d0dd35ebeda8afa8a9cc945c244c13fc501c76e720c2c04cab70c9f906c4a810defdd84c3a38507cdf79b4e4b0c7770cc3d2d862ea9bd5fe2469290d9d2a09c8164437e9d5b7b3a9c49d111e5caa9577f8ed1ef1916ec4cb71bbb8d n1 = 0xbcc2c4f4f51abb236b411f1f9d86d71133eb2d4ffe45a319b6ab6df1174b9ee619e696666702655b6c185735298cc008e9b7df842c480d3d42bb67228b6c7408a7afe68ab85ee1c80f43c8c52764c79ffdecc6e3a5ea76c1123affe9f02c649e5f5ca0a4082107ce4a2040e5756bf6a2b34757aefa5fb6fec6d7a9e86f0c8159 c1 = 0xacf91d2b6a300a60193485ef2e1127b5863c69da71ab9e7d71a3213e960a73e42f8e8031bf0ef20184ae0a259fd50260aacce06546af2f8bbef8a2f360c8f7511ad9c99d8715012ce0a4fa8dbba8c10d74f477156076bdfda80dc449eec3b45c7cd82802ecce7635e186d29744df04fcf812dc7e2d2f3c8cd751e4fcea43db1e e2 = 0x332f82f338c8b84524103d310d59fc541b66705948c57eaf972b26bb209a6ddde3d6930948a559ac1a3a26790cb1a133a90b999b164d4e22014b27660dad4e5639ffc19bcd2e4961c5b00b9116f49c3c02880bb3ad32972287442d6a86a9c86cd3981ee1084df4322edb9c5da39146e10de0586c8b5433a851d649a45c5a73cd n2 = 0xd0ad4d11576bb041ea2ce53f354dba362a93411a37f4a529e8b5eeae83a3437df6bd5e4e1f87a4d324a6ce2850f3568c929f5d5f73fef45bda03fa7bff00304a1eb833ce3535ee3552aa62b644f0d3c1679fe2c57b978c695f03e5b2d18d9b0821c7e0ca332f552b12e2b7109210d051bbe9d9b9e3cc3b16c81e77ebca65aca3 c2 = 0xc59078ae7cb454c970f272f595da71ae2b681156a1ce7112d9b96346f38bcdca87192ea39ac273851210e9f98f0d89f1bc657ce69ca14708cba8b319160a1f67b8cfc3643dc9b6a70769d8d64a9a3504d799f3d9afca7c7114880f4ccb5bef35738e660e4ede1c884f4a60f1f0e559fb754abd8e4b905ad3626a876bea43ec8e M = isqrt(max(n0, n1, n2)) M = 10704523536419069847275584063070587220303695362157261593514212717132031073368631333467085885236049291630529090309346493924305038011673707087598638071644281 B = matrix(ZZ, [ [M, e0, e1, e2], [0, -n0, 0, 0], [0, 0, -n1, 0], [0, 0, 0, -n2], ]) BL = B.","title":"Writeup for Crypto problems in SCTF 2020"},{"content":"Writeup for Crypto problems in De1CTF 2020 NLFSR task.py\nfrom flag import a, b, c, d, flag assert flag == \u0026quot;De1CTF{\u0026quot; + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \u0026quot;}\u0026quot; assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6] ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i \u0026amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do def genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\u0026quot;data\u0026quot;, \u0026quot;w+\u0026quot;).write(s) genkey(128*1024) LFSR部分把r左移一位，m和r二进制值共同为1位数的奇偶决定空位补1或0。\n每次combine()会把4个LFSR进行一些运算，最终只会返回1bit值，通过这1bit的信息我们可以把ao，bo，co，do的状态分成两类：\ndef test(tar): for ao in [0, 1]: for bo in [0, 1]: for co in [0, 1]: for do in [0, 1]: if (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do == tar: print(\u0026quot;ao={},bo={},co={},do={}\u0026quot;.format(ao, bo, co, do)) test(0) combine()返回0时对应的8个状态：\nao=0,bo=0,co=0,do=0 ao=0,bo=0,co=1,do=1 ao=0,bo=1,co=0,do=0 ao=0,bo=1,co=0,do=1 ao=0,bo=1,co=1,do=0 ao=0,bo=1,co=1,do=1 ao=1,bo=0,co=0,do=0 ao=1,bo=0,co=1,do=1 combine()返回1时对应的8个状态：\nao=0,bo=0,co=0,do=1 ao=0,bo=0,co=1,do=0 ao=1,bo=0,co=0,do=1 ao=1,bo=0,co=1,do=0 ao=1,bo=1,co=0,do=0 ao=1,bo=1,co=0,do=1 ao=1,bo=1,co=1,do=0 ao=1,bo=1,co=1,do=1 CTF wiki上有一个类似的题:\nhttps://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/nfsr/\n可以看到这题也是有75%的概率combine()返回值和ao的值相等，可以从这里爆破a。\nma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) f=open(\u0026quot;data\u0026quot;,\u0026quot;r\u0026quot;) S=f.read() S=S[:100]#为了提高一点效率，可以先从小的开始尝试，找不到合适的就改一改 def bruteforce(): for a in range(2**18,2**19): a_tmp=a cnt=0 for i in S: a_tmp=lfsr(a_tmp,ma) if a_tmp\u0026amp;1==int(i): cnt+=1 if cnt/len(S)\u0026gt;0.7:#这里也是慢慢改着算的...会有多个输出，然后把概率提高到0.74-0.76，逐个验证一下 print(a) print(cnt/len(S)) bruteforce() 现在很容易得到了a的值363445，现在通过类似的方法可以枚举b，观察上面两组状态，可以看到有75%的概率 combine() 返回值和 ao, bo 的同或值（相同为真，相异为假）相等。\na = 363445 ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) f=open(\u0026quot;data\u0026quot;,\u0026quot;r\u0026quot;) S=f.read() S=S[:100]#为了提高一点效率，可以先从小的开始尝试，找不到合适的就改一改 def bruteforce(): for b in range(2**18,2**19): a_tmp,b_tmp=a,b cnt=0 for i in S: tmp=0 a_tmp=lfsr(a_tmp,ma) b_tmp=lfsr(b_tmp,mb) if (a_tmp\u0026amp;1)==(b_tmp\u0026amp;1):#同或关系 tmp=1 else: tmp=0 if tmp==int(i): cnt+=1 if cnt/len(S)\u0026gt;0.7:#这里也是慢慢改着算的...会有多个输出，然后把概率提高到0.74-0.76，逐个验证一下 print(b) print(cnt/len(S)) bruteforce() 改一改就可以用来枚举 b 了，从输出中逐个验证，得到 494934。\na 和 b 都知道了，c 和 d 比较小可以直接爆破了，一共刚好也是 2^19bit。\na = 363445 b = 494934 ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) f=open(\u0026quot;data\u0026quot;,\u0026quot;r\u0026quot;) S=f.read() S=S[:100]#为了提高一点效率，可以先从小的开始尝试，找不到合适的就改一改 def bruteforce(): global a,b for c in range(4096, 8192): for d in range(32, 64): cnt=0 a_tmp,b_tmp,c_tmp,d_tmp=a,b,c,d for i in S: a_tmp = lfsr(a_tmp, ma) b_tmp = lfsr(b_tmp, mb) c_tmp = lfsr(c_tmp, mc) d_tmp = lfsr(d_tmp, md) [ao, bo, co, do] = [t \u0026amp; 1 for t in [a_tmp, b_tmp, c_tmp, d_tmp]] if int(i)==(bo*ao) ^ (bo*co) ^ (bo*do) ^ co ^ do: cnt+=1 if cnt/len(S)==1:#这里可以要求的很严格了，当然要100%满足 print(c) print(d) return bruteforce() 得到 d=4406，c=63。\na = 363445, b = 494934, c = 4406, d = 63 转换hex拼接得到flag：De1CTF{58bb578d5611363f}\neasyRSA task.py\nfrom Crypto.Util.number import * import gmpy2 import random from FLAG import flag def genE(lcm,limit): while True: r = random.randint(limit,limit*0x1000000000001) d = gmpy2.next_prime(r) e = gmpy2.invert(d,lcm) if isPrime(e): break return e p = getStrongPrime(1024) q = getStrongPrime(1024) n = p*q lcm = gmpy2.lcm(p-1,q-1) limit = gmpy2.iroot(n,3)[0] e1,d1 = genE(lcm,limit) e2,d2 = genE(lcm,limit) phi = (p-1)*(q-1) d1 = gmpy2.invert(e1,phi) d2 = gmpy2.invert(e2,phi) e = [e1,e2] plain = bytes_to_long(flag) cipher = pow(plain,e[random.getrandbits(1)],n) print('N:' + str(n)) print('e1:' + str(e1)) print('e2:' + str(e2)) print('cipher:' + str(cipher)) D^3CTF有一道和这题类似的题目，wp也很详细\u0026hellip;\u0026hellip;\nhttps://gist.github.com/LurkNoi/dfe86ed4d16776242251318b380336e7\n构造好的矩阵竟然可以直接拿来用，直接LLL就可以解出来d1，d2\u0026hellip;.\n由于我们不知道 genE() 中 d 的具体的 bit_length，在 d 的范围数量级内进行枚举。\nexp.sage:\nn= 24402191928494981635640497435944050736451453218629774561432653700273120014058697415669445779441226800209154604159648942665855233706977525093135734838825433023506185915211877990448599462290859092875150657461517275171867229282791419867655722945527203477335565212992510088077874648530075739380783193891617730212062455173395228143660241234491822044677453330325054451661281530021397747260054593565182679642519767415355255125571875708238139022404975788807868905750857687120708529622235978672838872361435045431974203089535736573597127746452000608771150171882058819685487644883286497700966396731658307013308396226751130001733 e1= 4046316324291866910571514561657995962295158364702933460389468827072872865293920814266515228710438970257021065064390281148950759462687498079736672906875128944198140931482449741147988959788282715310307170986783402655196296704611285447752149956531303574680859541910243014672391229934386132475024308686852032924357952489090295552491467702140263159982675018932692576847952002081478475199969962357685826609238653859264698996411770860260854720047710943051229985596674736079206428312934943752164281391573970043088475625727793169708939179742630253381871307298938827042259481077482527690653141867639100647971209354276568204913 e2= 1089598671818931285487024526159841107695197822929259299424340503971498264804485187657064861422396497630013501691517290648230470308986030853450089582165362228856724965735826515693970375662407779866271304787454416740708203748591727184057428330386039766700161610534430469912754092586892162446358263283169799095729696407424696871657157280716343681857661748656695962441400433284766608408307217925949587261052855826382885300521822004968209647136722394587701720895365101311180886403748262958990917684186947245463537312582719347101291391169800490817330947249069884756058179616748856032431769837992142653355261794817345492723 m1 = n^(1/2) m1 = int(m1) def GCD(a,b): if a%b == 0: return b else: return GCD(b,a%b) def autoflag(t): m2= n^(1+t) m2 = int(m2) print(t) B2 = matrix([[1,-n, 0, n**2], [0,e1,-e1,-e1*n], [0, 0, e2,-e2*n], [0, 0, 0,e1*e2]]) D2 = matrix([[n, 0, 0,0], [0,m1, 0,0], [0, 0,m2,0], [0, 0, 0,1]]) M = B2*D2 # k1k2, k2d1, k1d2, d1d2 for vec in M.LLL()[:1]: b1,b2,b3,b4 = vec x2 = Matrix([[b1,b2,b3,b4]])*M.inverse() a,b,c,d = x2[0] print(GCD(b,d)) print(GCD(c,d)) print(\u0026quot;DONE\u0026quot;) t=0.3334 while t\u0026lt;0.3570:#0.3334-0.3569 t+=0.0001 autoflag(t) #0.3550 #13055886542241324849606848300654111050213895018931668525112390666717463659828011236495055020349316934910897599568907550458905937640534150366439142917379092077356477487038001707677114834324987975339711919914028174834026692 #10524758552977623950522576266095598971604066598976786723316565384341562423375977453510267182029447059155214674557556041512997808420285719007717780425013978916702926738382048840861185251222579340831080549153967201958081132 exp.py\nfrom Crypto.Util.number import * n= 24402191928494981635640497435944050736451453218629774561432653700273120014058697415669445779441226800209154604159648942665855233706977525093135734838825433023506185915211877990448599462290859092875150657461517275171867229282791419867655722945527203477335565212992510088077874648530075739380783193891617730212062455173395228143660241234491822044677453330325054451661281530021397747260054593565182679642519767415355255125571875708238139022404975788807868905750857687120708529622235978672838872361435045431974203089535736573597127746452000608771150171882058819685487644883286497700966396731658307013308396226751130001733 e1= 4046316324291866910571514561657995962295158364702933460389468827072872865293920814266515228710438970257021065064390281148950759462687498079736672906875128944198140931482449741147988959788282715310307170986783402655196296704611285447752149956531303574680859541910243014672391229934386132475024308686852032924357952489090295552491467702140263159982675018932692576847952002081478475199969962357685826609238653859264698996411770860260854720047710943051229985596674736079206428312934943752164281391573970043088475625727793169708939179742630253381871307298938827042259481077482527690653141867639100647971209354276568204913 e2= 1089598671818931285487024526159841107695197822929259299424340503971498264804485187657064861422396497630013501691517290648230470308986030853450089582165362228856724965735826515693970375662407779866271304787454416740708203748591727184057428330386039766700161610534430469912754092586892162446358263283169799095729696407424696871657157280716343681857661748656695962441400433284766608408307217925949587261052855826382885300521822004968209647136722394587701720895365101311180886403748262958990917684186947245463537312582719347101291391169800490817330947249069884756058179616748856032431769837992142653355261794817345492723 c= 5089249888618459947548074759524589606478578815336059949176718157024022678024841758856813241335191315643869492784030633661717346809979076682611760035885176766380484743187692409876479000444892361744552075578050587677106211969169204446554196613453202059517114911102484740265052582801216204900709316109336061861758409342194372241877343837978525533125320239702501424169171652846761028157198499078668564324989313965631396082388643288419557330802071756151476264735731881236024649655623821974147680672733406877428067299706347289297950375309050765330625591315867546015398294367460744885903257153104507066970239487158506328863 d1=13055886542241324849606848300654111050213895018931668525112390666717463659828011236495055020349316934910897599568907550458905937640534150366439142917379092077356477487038001707677114834324987975339711919914028174834026692 d2=10524758552977623950522576266095598971604066598976786723316565384341562423375977453510267182029447059155214674557556041512997808420285719007717780425013978916702926738382048840861185251222579340831080549153967201958081132 d1=d1//4 d2=d2//4 m=pow(c,d1,n) print(long_to_bytes(m)) flag：De1CTF{4ef5e5b2-c169-47e2-b90e-9421c56f2f5e}\n感觉自己菜爆了\u0026hellip;自闭比赛，做的时间最长的一题ECDH最终还是没弄出来，一直感觉是Invalid Curve Attack，因为服务器端没有检测发送的点是否在开始的那条椭圆曲线上。赛后发现，是因为自己在选取 bi 的时候，n%p==0 没有加上 ==0 \u0026hellip;\u0026hellip; 不过作为入队考核题，最终还是做出来了顺利进队。\nECDH 拿来代码可以看到我们可以向服务器发送一个点 Gi (Exchange)，然后可以为我们加密一段 msg (Encrypt)，返回给我们 secret*Gi 合并 x y 后与 msg 异或的结果，我们收到这个结果再与 msg 异或一下然后分离 x y 就可以得到点 secret*Gi 了。我们的目的是得到并向服务器发送 secret 的值，就能得到 flag 啦。\n简化一下：发送点 Gi，得到点 secret*Gi，计算 secret 并发送，得到 flag。 $$ E:y^2=x^3+Ax+B $$\n注意到计算 secret*Gi 的 mul() 和 add() 函数并没有用到椭圆曲线 $E$ 的参数 B，也没有检查 Gi 是否为 E(A,B,q) 上的点。所以我们可以构造 E'(A,Bi,q)，然后发送曲线 $E\u0026rsquo;$ 上的点 Gi，所以程序在计算 secret*Gi 的时候，它以为是在E上计算，其实被骗了，是在 $E\u0026rsquo;$ 上计算。发送多组Gi最终可以得到足够的数据通过剩余定理合并，得到secret，这种攻击就是 Invalid Curve Attack。\nInvalid Curve Attack Local Preparation\n随机选取 Bi，并计算此时的 $E\u0026rsquo;$ 的阶 $n$，判断$n$是否能被一个小素数 qi 整除，如果可以就保留 Bi，qi。 在 $E\u0026rsquo;$ 上找一个随机点 $H$ ,并计算 $Gi=(n\u0026rsquo;/q)H$ ，检查 Gi 是否为无穷远点就可以了，是的话重新选这个随机点 $H$ ，不是就把这个 Gi 保存。 这样就得到了一组 (bi, qi, Gi)，不断重复一二两步，直到所有的 qi 之积大于 $q^2$ 就退出循环。 Online Attack：\n发送点 Gi ，得到程序返回的 secret*Gi 在 $(0,qi)$ 范围内枚举 ti ，使其满足 ti*Gi == secret*Gi ，计算 $t_i^2\\ mod\\ q_i$，这时有 $secret^2 = t_i^2\\ mod\\ q_i$。 重复上面两步，发送完所有的 Gi，保存到了所有的 $t_i^2\\ mod\\ q_i$。然后用剩余定理合并所有的 $t_i^2$，得到 $t^2$ 也就是 $secret^2$，开平方根就得到了 secret。 Writeup 在计算参数列表 Bi，qi，Gi 的时候，要注意到程序最多只能和我们交互 90 次，交互两次才能完成发送Gi和加密msg，所以 qi 的个数需要小于 45 ，最好给 qi 定一个不太小的下限（我的是5000），以保证 qi 个数较少。我先生成一个 5000 之后1000 个素数的列表作为 qi 可选的空间。\n本地计算参数列表的脚本：\nfrom random import randint from gmpy2 import sqrt,invert,mpz sieve_base=[5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249] q = 0xdd7860f2c4afe6d96059766ddd2b52f7bb1ab0fce779a36f723d50339ab25bbd a = 0x4cee8d95bb3f64db7d53b078ba3a904557425e2a6d91c5dfbf4c564a3f3619fa zero = (0,0) F=FiniteField(q) def f(b,x): return (pow(x,3,q) + a*x + b) % q def add(p1,p2): if p1 == zero: return p2 if p2 == zero: return p1 (p1x,p1y),(p2x,p2y) = p1,p2 if p1x == p2x and (p1y != p2y or p1y == 0): return zero if p1x == p2x:#p1y == p2y and p1y != 0 and p2y != 0 tmp = (3 * p1x * p1x + a) * invert(mpz(2 * p1y) , mpz(q)) % q else: tmp = (p2y - p1y) * invert(mpz(p2x - p1x) , mpz(q)) % q x = (tmp * tmp - p1x - p2x) % q y = (tmp * (p1x - x) - p1y) % q return (int(x),int(y)) def mul(n,p): r = zero tmp = p while 0 \u0026lt; n: if n \u0026amp; 1 == 1: r = add(r,tmp) n, tmp = n \u0026gt;\u0026gt; 1, add(tmp,tmp) return r def Offline_Precomputations(): prime_list = [sieve_base[i] for i in range(1000)] Gi_list = [] qlist = [] bi_list=[] qi_product = 1 bi=1 while(qi_product \u0026lt; q*q): bi += 1 E=EllipticCurve(F,[a,bi]) n = E.order() print(n) find_a_small_factor = False for i in range(1000): if n % prime_list[i]==0 and prime_list[i] not in qlist: print(\u0026quot;find a small factor\u0026quot;) find_a_small_factor = True qi_product *= prime_list[i] qlist.append(prime_list[i]) bi_list.append(bi) print(qlist) break if not find_a_small_factor: continue H=E.random_point() inf=H-H while True: G = H*int(n/qlist[-1]) if G==inf: H=E.random_point() else: break print(\u0026quot;find!\u0026quot;) print(G) Gi_list.append((G[0],G[1])) print(bi_list) print(qlist) print(Gi_list) Offline_Precomputations() 上面的脚本大约5分钟就可以算完。输出的三个参数列表存在一个文件里：\nbi = [4, 9, 26, 28, 30, 32, 34, 40, 41, 48, 73, 86, 111, 112, 117, 119, 129, 132, 136, 141, 161, 165, 174, 188, 197, 203, 206, 213, 214, 220, 238, 242, 275, 276, 279, 291, 299, 303, 322, 336] qi = [5657, 10903, 8191, 12157, 6073, 9241, 10687, 12893, 6719, 13859, 8117, 10301, 13099, 5527, 8737, 10631, 5107, 5693, 6079, 10657, 5927, 6113, 7873, 6217, 11047, 12113, 5147, 9103, 11057, 5923, 7027, 5717, 10501, 13063, 9127, 10133, 5477, 5471, 13421, 13759] Gi = [(30872500276756167396951474090124654304794923360667192467226675667448229681665, 83322930424192373524322173116603156345074046542792982303484797472143217961368), (14142904415645449119907336377416481926864703912427562730055735074219145549101, 63849575435191102844140385926897263301061935266189659881317580955016050734189), (40969882994648530081916876655161985963830665410329660538461272172469167125728, 64454878682771462004362411962366300840173052580225189911399858039534581888077), (82877418346404951750675480072867011998991569892157974398985334984663117854149, 50978626336645847463851041692845664756477024069940277266625847972958761358368), (24746817534136625356292362813181235589280973302944023820185154275643462413727, 35639977980669594960678433763010741945515185245445353404428172737631739386899), (47282371694648556570679118847655449358963795004556531118348527180031145177969, 59966019181805023632948187657492552643801632478184881090936975601106229146410), (60712030606261917519568264199639402100574447377118122922524413101203741263120, 17176385919318377183171082088625527451825035445063657268915215986521393888340), (9027327243716998211781862199426408307326022952644379162790068878797188141818, 61009803152391976811447442545097299173436840401745624638955569832237555829473), (92251054066253126334428165182631564129665870611725669183888213682798259095972, 37074010565672199367874176622919563060597398699989235438216793443482295287409), (69695373440573629766708856342663276081186838699125800152765630981947711052121, 48178899944132882283599919400524668308064902957209651369122200378268323952425), (75102389801455858956597493216399156984694788514035038175249758211883103626870, 3412785211107654591249094160052537680385541044296766274185340746624483729733), (59866676681443934667114838077713240838957123181519735125754606765849866097347, 8805439985411086835249824924575402161831279521146603579645222384004542285519), (12347621918708465606908238516379113916518065052190877557445387463476295403583, 51928978269977560591638042857241338407310718393549367181739959706805873995534), (73062544334117217418276419902996007214091231775581805844308159628155628211807, 55784571416852533002117425486589483198762732580845853891284112905769938188897), (44682682941088257636486520064393268330678693434401068570127680280728944744998, 28173971913162137009249858457142752453546282574869173219057002120131181452593), (34242130021719570117253003762778941164580411253476500654240946260487756864086, 26766153725875538986947107451673755197819092915585191972024061524601120879860), (90422336812399003145559066044427724490604468992899648595340676974027580958703, 80165372718141463422545565405008761999799501548366301938489635724657401745713), (85140176786053085584193314208172740416786705738102554549989875569197541552264, 75358833217208468040762514687496665850414066877171064073115458896807483076615), (94771825545395933071508776706118073614882175454078396622630715974723704155151, 4745535117825351976526807256991485492783614974043324040684972741775042815990), (100171525035097286097545492976792764465735962531594898393076116754456861358755, 53705979238119204251739160477914836172776252121476309657209714496275276427389), (29971095349578324382901593694826617004225871191689145192858680308549101683404, 57184898779794807742616054554045038792327449405632903218800390085959225225204), (55407687548794482628601357728242040226311193190028208583744883161144062368296, 33314617302527601701593772443278423878871997724393245022228170147527022751718), (32239990110815338831999530368651186051237902011177167660513454938097407801162, 671602395501769727771718955063041871367596087541253612345325738676335116280), (3917571690569088369262203391165226228446787670578414099634000210229258526360, 70634026931612954431222806160218359603337677957192750882837663783030579509624), (2207035926055248213529107319579032297141765794563906833591403890711440160113, 31331709971636821775115781873059884810730455527131288709744391474355953219901), (3932808658713491006509410084406394244966049429248145722157725209819345215434, 85142630046436265508647141294265284061206772024019380851950823942517231823894), (1539521617181156915158018487872776183950574207896802451837845170244377427387, 24449866531527118897857255763228849849561887485160194129175253493403448504125), (75002212857098569438403863439809398015781294312789119873167994247755527333762, 87002220226810953045826905675716400420036092226734517178134089426254171587715), (92010592279557832306039829536051295550204502236267688784472039931587463456035, 58613481301723072528738357273612194677387937582367011948647990512041392950153), (83393344736952817655018385178901587930844106489134650611100773558042073140443, 30300689939783331476278918304361371781367897595104621620522420376841330066554), (91078061094403429716572485362499716404082941862048489035495641570495237378110, 40971255337503044023637629176353045221129744187378119183810433410253577683959), (16985546008320601827759048065524362704024280157173465715933238635277424622056, 22696940558362620242678088324333793057494067258280802605002237508630082994109), (19170284381687584388622601167478242887418206491615217123996130596733428386742, 75748545718743128162585628787582641365201763301552227607403853384807587009859), (26473683045754776494164819126676658456171602164787921730420301045177016736609, 4281911904902758858355404226807051591134777088628269518372910631801533181905), (53676622464735659552656571188215866927322104668956095743777971851020661674358, 32274152263769486066368214670965452735712224610879606790658391470777079972556), (17029079575716446729702735874302371314145352046618367406530611486482710572360, 69357146029376150656652047840232370865246341002948175613826165204918209020338), (34727300648324783340958409739006112355711035230437824170066703947960201976886, 1587307801581137361413368586082506549606770098958439500002828849164565562848), (20877893922423278084054972379788392567821904480521987253174872716560062157784, 6715702336736936301726721938396211844295333186474291987353293376813588111160), (31562274556840802328980745172266502601827082447947556734372585420455740249090, 34305476342176933832701449433075719459820433000960976107182392312648682867355), (19690328408555852060974020099573760475212244087504943265526342735564565974214, 85979847994448727599368990309145050030837733437134982952836810810966647646533)] 有了参数列表就可以干服务器上的程序了：\nimport string from LIST import qi, Gi from pwn import remote from hashlib import sha256 from gmpy2 import invert, iroot from functools import reduce msg = \u0026quot;80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026quot; q = 0xdd7860f2c4afe6d96059766ddd2b52f7bb1ab0fce779a36f723d50339ab25bbd a = 0x4cee8d95bb3f64db7d53b078ba3a904557425e2a6d91c5dfbf4c564a3f3619fa b = 0x56cbc73d8d2ad00e22f12b930d1d685136357d692fa705dae25c66bee23157b8 zero = (0, 0) def proof_of_work(txt, Hash): S = string.ascii_letters+string.digits for a in S: for b in S: for c in S: for d in S: if sha256((a+b+c+d+txt).encode()).hexdigest() == Hash: print(a+b+c+d) return a+b+c+d def add(p1, p2): if p1 == zero: return p2 if p2 == zero: return p1 (p1x, p1y), (p2x, p2y) = p1, p2 if p1x == p2x and (p1y != p2y or p1y == 0): return zero if p1x == p2x: # p1y == p2y and p1y != 0 and p2y != 0 tmp = (3 * p1x * p1x + a) * invert(2 * p1y, q) % q else: tmp = (p2y - p1y) * invert(p2x - p1x, q) % q x = (tmp * tmp - p1x - p2x) % q y = (tmp * (p1x - x) - p1y) % q return (int(x), int(y)) def mul(n, p): r = zero tmp = p while 0 \u0026lt; n: if n \u0026amp; 1 == 1: r = add(r, tmp) n, tmp = n \u0026gt;\u0026gt; 1, add(tmp, tmp) return r def CRT(m, a): Num = len(m) M = reduce(lambda x, y: x*y, m) Mi = [M//i for i in m] t = [invert(Mi[i], m[i]) for i in range(Num)] x = 0 for i in range(Num): x += a[i]*t[i]*Mi[i] return x % M def stringToPoint(p): i = 0 while p[i] != ',': i += 1 return (int(p[1:i]), int(p[i+1:-1])) def exchange(xi, yi): tmp = r.recvline() print(tmp) tmp = r.recvline() print(tmp) r.send(str(xi)+\u0026quot;\\n\u0026quot;) print(xi) tmp = r.recvline() print(tmp) r.send(str(yi)+\u0026quot;\\n\u0026quot;) print(yi) tmp = r.recvline() print(tmp) tmp = r.recvline() print(tmp) def encrypt(msg): tmp = r.recvline() print(tmp) r.send(str(msg)+'\\n') tmp=r.recvline() print(tmp) res = int(r.recvline().strip().decode(),16) print(res) res ^= int(msg,16) print(\u0026quot;res =\u0026quot;, hex(res)) tmp = r.recvline() print(tmp) return res def keysToPoint(res): res = bin(res)[2:] y = int(res[-256:], 2) x = int(res, 2)\u0026gt;\u0026gt;256 return (x, y) def getPoint(xi, yi, msg): r.send(\u0026quot;Exchange\\n\u0026quot;) exchange(xi, yi) r.send(\u0026quot;Encrypt\\n\u0026quot;) res = encrypt(msg) return keysToPoint(res) # proof_of_work r = remote('134.175.225.42', 8848) r.recvuntil(\u0026quot;XXXX+\u0026quot;) nonce = r.recv(16).decode() r.recvuntil(\u0026quot; == \u0026quot;) target = r.recv(64).decode() w = proof_of_work(nonce, target) r.send(str(w)) print(\u0026quot;----------proof of work is ok!----------\u0026quot;) # Start_work r.recvuntil(\u0026quot;q: \u0026quot;) q = int(r.recvline().strip().decode()) r.recvuntil(\u0026quot;a: \u0026quot;) a = int(r.recvline().strip().decode()) r.recvuntil(\u0026quot;b: \u0026quot;) b = int(r.recvline().strip().decode()) r.recvuntil(\u0026quot;P: \u0026quot;) P = stringToPoint(r.recvline().strip().decode()) r.recvuntil(\u0026quot;Q: \u0026quot;) Q = stringToPoint(r.recvline().strip().decode()) print(\u0026quot;q :\u0026quot;, q, \u0026quot;\\na :\u0026quot;, hex(a), \u0026quot;\\nb :\u0026quot;, hex(b), \u0026quot;\\nP :\u0026quot;, P, \u0026quot;\\nQ :\u0026quot;, Q) exchange(1, 1) qlen = len(Gi) t = [] for i in range(len(qi)): print(\u0026quot;--------------------{}th\u0026quot;.format(i)) X=getPoint(Gi[i][0],Gi[i][1],msg) ti=0 for j in range(qi[i]): if mul(j,(Gi[i][0],Gi[i][1]))==X: ti=j t.append((ti*ti)%qi[i]) break print(\u0026quot;ti :\u0026quot;,ti) print(t) ans = CRT(qi, t) secret = iroot(ans, 2)[0] print(secret) if mul(secret,P)==Q: print(\u0026quot;checked\u0026quot;) r.send(\u0026quot;Backdoor\\n\u0026quot;) tmp = r.recvline() print(tmp) r.send(str(secret)+\u0026quot;\\n\u0026quot;) temp1 = r.recvline() print(temp1) temp2 = r.recvline() print(temp2) ","permalink":"https://slightwind.cn/posts/ctf/writeup-for-crypto-problems-in-de1ctf-2020/","summary":"Writeup for Crypto problems in De1CTF 2020 NLFSR task.py\nfrom flag import a, b, c, d, flag assert flag == \u0026quot;De1CTF{\u0026quot; + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \u0026quot;}\u0026quot; assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6] ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i \u0026amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do def genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\u0026quot;data\u0026quot;, \u0026quot;w+\u0026quot;).","title":"Writeup for Crypto problems in De1CTF 2020"},{"content":"\u0026ldquo;not_RSA\u0026rdquo; in DASCTF 看了大佬的博客才知道是 Paillier cryptosystem，wtcl\u0026hellip; 不过还是记录一下自己推导的解题过程\n直接使用现成的 Paillier cryptosystem 解密算法解决这题非常容易，分解 n 然后直接套 decrypt 函数就解开了\u0026hellip;\n题目：\nfrom Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inverse from secret import flag,p,q from sympy import isprime,nextprime import random m=bytes_to_long(flag) n=p*q g=n+1 r=random.randint(1,n) c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n) print('c=',c) print('n=',n) 主要加密过程是： $$ \\begin{aligned} c\u0026amp;\\equiv(g^m \\ mod \\ n^2)(r^n \\ mod \\ n^2) \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv g^m r^n \\ \u0026amp;(mod \\ n^2) \\end{aligned} $$\n其中有 $$ \\begin{aligned} g^m\u0026amp;\\equiv (n+1)^m \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv C_m^0 n^0 + C_m^1 n^1 +C_m^2n^2+\u0026hellip;+C_m^mn^m \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv C_m^0 n^0 + C_m^1 n^1 \\ \u0026amp;(mod \\ n^2)\\\\ \u0026amp;\\equiv 1 + mn \\ \u0026amp;(mod \\ n^2) \\end{aligned} $$ 所以得到$c\\equiv g^m r^n\\equiv (1 + mn)r^n \\ (mod \\ n^2)$\n现在就要想办法消除掉 $r^n$ 的影响，不难发现 $r^n\\ mod\\ n = c\\ mod\\ n$。\n所以我们需要由 $r^n\\ mod\\ n$ 得到 $r$ 的值或者 $r^n\\ mod\\ n^2$的值，才可以对 $r^n$ 在模 $n^2$ 下求逆元。这里我这个菜鸡想了好久\u0026hellip;最终想到将 $r^n\\ mod\\ n$ 分别对 $n$ 的两个因数 $p,q$ 取模，然后再用中国剩余定理（CRT）合并，从而得到 $r$。\n然后我们只需要计算 $r^n\\ mod\\ n^2$ 的逆元并与 $c$ 相乘，就得到 $(1+mn)\\ mod\\ n^2$，也就得到了 $m$。\nfrom Crypto.Util.number import long_to_bytes, inverse from functools import reduce c = 29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549 n = 6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093 p = 80006336965345725157774618059504992841841040207998249416678435780577798937819 q = 80006336965345725157774618059504992841841040207998249416678435780577798937447 g = n+1 phi = (p-1)*(q-1) rn = c % n x1 = rn % p d1 = inverse(q, p-1) r1 = pow(x1, d1, p) x2 = rn % q d2 = inverse(p, q-1) r2 = pow(x2, d2, q) def CRT(m, a): Num = len(m) M = reduce(lambda x, y: x*y, m) Mi = [M//i for i in m] t = [inverse(Mi[i], m[i]) for i in range(Num)] x = 0 for i in range(Num): x += a[i]*t[i]*Mi[i] return x % M r = CRT([p, q], [r1, r2]) R = pow(r, n, n*n) R_inv = inverse(R, n*n) mn = (c*R_inv) % (n*n) m = (mn-1)//n print(long_to_bytes(m)) Paillier Crytposystem 选取素数 $p, q$，计算 $n=p\\cdot q$，$\\lambda =lcm(p-1,q-1)$，选取 $g\\in\\Z_{n^2}^*$满足 $g$ 的阶是 $n$ 的倍数。\n其中公钥为：$n, g$，私钥为：$p, q,\\lambda$。\n加密时明文 $m\u0026lt;n$，选取随机的 $r \\in \\Z_n^*$，计算出密文 $c=g^m r^n \\ mod \\ n^2$。\n解密时的密文 $c\u0026lt;n^2$，明文 $m=\\cfrac{L(c^\\lambda\\ mod\\ n^2)}{L(g^\\lambda\\ mod\\ n^2)}\\ (mod\\ n)$，其中 $L(u)=\\cfrac{u-1}{n}$。\n在选取合适的 $g$ 的时候，需要判断 $g$ 的阶是否为 $n$ 的倍数，等价于判断 $GCD(L(g^\\lambda\\ mod\\ n^2),n)=1$。\nfrom Crypto.Util.number import* from gmpy2 import lcm class Paillier(): def __init__(self): pass def encrypt(self, m): p, q = getPrime(512), getPrime(512) n = p*q self.n = n assert m \u0026lt; n Lcm = lcm(p-1, q-1) g = getRandomRange(1, n*n) while GCD(self.L(pow(g, Lcm, n*n)), n) != 1: g = getRandomRange(1, n*n) r = getRandomRange(1, n) return (pow(g, m, n*n)*pow(r, n, n*n)) % (n*n), p, q, g def decrypt(self, c, p, q, g): n = p*q assert c \u0026lt; n*n Lcm = lcm(p-1, q-1) self.n = n self.d = inverse((p-1)*(q-1), n) m_c = self.L(pow(c, Lcm, n*n)) m_g = self.L(pow(g, Lcm, n*n)) m = m_c*inverse(m_g, n) % n return m def L(self, u): return (u-1)//self.n m = bytes_to_long(b'flag{1234567890}') P = Paillier() c, p, q, g = P.encrypt(m) M = P.decrypt(c, p, q, g) print(long_to_bytes(M)) # b'flag{1234567890}' 使用 Paillier 解密就可以直接解这一题。\nexp:\nfrom Crypto.Util.number import long_to_bytes,inverse from gmpy2 import lcm c = 29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549 n = 6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093 p = 80006336965345725157774618059504992841841040207998249416678435780577798937819 q = 80006336965345725157774618059504992841841040207998249416678435780577798937447 g = n+1 phi = (p-1)*(q-1) def decrypt(c, p, q, g): n = p*q Lcm = lcm(p-1, q-1) m_c = (pow(c, Lcm, n*n)-1)//n m_g = (pow(g, Lcm, n*n)-1)//n m = m_c*inverse(m_g, n) % n return m m=decrypt(c, p, q, g) print(long_to_bytes(m)) #b'flag{5785203dbe6e8fd8bdbab860f5718155}' ","permalink":"https://slightwind.cn/posts/ctf/learn-paillier-crytposystem-from-not_rsa-in-dasctf/","summary":"\u0026ldquo;not_RSA\u0026rdquo; in DASCTF 看了大佬的博客才知道是 Paillier cryptosystem，wtcl\u0026hellip; 不过还是记录一下自己推导的解题过程\n直接使用现成的 Paillier cryptosystem 解密算法解决这题非常容易，分解 n 然后直接套 decrypt 函数就解开了\u0026hellip;\n题目：\nfrom Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inverse from secret import flag,p,q from sympy import isprime,nextprime import random m=bytes_to_long(flag) n=p*q g=n+1 r=random.randint(1,n) c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n) print('c=',c) print('n=',n) 主要加密过程是： $$ \\begin{aligned} c\u0026amp;\\equiv(g^m \\ mod \\ n^2)(r^n \\ mod \\ n^2) \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv g^m r^n \\ \u0026amp;(mod \\ n^2) \\end{aligned} $$\n其中有 $$ \\begin{aligned} g^m\u0026amp;\\equiv (n+1)^m \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv C_m^0 n^0 + C_m^1 n^1 +C_m^2n^2+\u0026hellip;+C_m^mn^m \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv C_m^0 n^0 + C_m^1 n^1 \\ \u0026amp;(mod \\ n^2)\\\\ \u0026amp;\\equiv 1 + mn \\ \u0026amp;(mod \\ n^2) \\end{aligned} $$ 所以得到$c\\equiv g^m r^n\\equiv (1 + mn)r^n \\ (mod \\ n^2)$","title":"Learn Paillier crytposystem from \"not_RSA\" in DASCTF"},{"content":"Notes for $An\\ Introduction\\ to\\ Mathematical\\ Cryptography$\n“A toy model of a real public key cryptosystem” 这里以 An Introduction to Mathematical Cryptography 书中的一个简单的加密模型为例，简单介绍一下通过高斯格基规约算法（Gaussian Lattice Reduction）解决二维的格上的寻找最短向量问题。\n最近在书中看到这个，刚好 西电新生赛@Mini L-CTF 有两个题目刚好是用这个模型实现的，当做例题整个 writeup。\ntask.py\nfrom Crypto.Util.number import bytes_to_long, getPrime, inverse from gmpy2 import iroot q = getPrime(1024) f = getPrime(511) g = getPrime(511) while g \u0026lt; iroot(q//4, 2)[0] or g \u0026gt; iroot(q//2, 2)[0]: g = getPrime(511) f_inv_q = inverse(f, q) h = f_inv_q*g % q m = bytes_to_long(b'flag') # flag is base**(flag) r = getPrime(510) e = (r*h+m) % q print(f) print(g) print(q) print(e) ''' f = 4685394431238242086047454699939574117865082734421802876855769683954689809016908045500281898911462887906190042764753834184270447603004244910544167081517863 g = 5326402554595682620065287001809742915798424911036766723537742672943459577709829465021452623299712724999868094408519004699993233519540500859134358256211397 q = 172620634756442326936446284386446310176482010539257694929884002472846127607264743380697653537447369089693337723649017402105400257863085638725058903969478143249108126132543502414741890867122949021941524916405444824353100158506448429871964258931750339247018885114052623963451658829116065142400435131369957050799 e = 130055004464808383851466991915980644718382040848563991873041960765504627910537316320531719771695727709826775790697704799143461018934672453482988811575574961674813001940313918329737944758875566038617074550624823884742484696611063406222986507537981571075140436761436815079809518206635499600341038593553079293254 ''' 其中私钥为 ( f , g ) ，公钥为 ( q , h ) ，这个已经给了私钥，所以解密过程非常简单。\n$$ e \\equiv rh+m \\equiv \\frac{rg}{f}+m \\ (mod \\ q) $$\n两边同时乘 $f$: $$ \\tag{1}ef \\equiv rg+mf \\ (mod \\ q) $$\n这时注意到 $g$ 的范围是$\\sqrt{\\frac{q}{4}} \u0026lt; g \u0026lt; \\sqrt{\\frac{q}{2}}$，所以： $$ rg+fm\u0026lt; \\sqrt{\\frac{q}{2}}\\sqrt{\\frac{q}{2}}+\\sqrt{\\frac{q}{2}}\\sqrt{\\frac{q}{4}}\u0026lt; q $$\n那么同余式 $(1)$，可以直接看做等式：\n$$ \\tag{2}ef = rg+mf $$\n接下来只需计算：\n$$ (ef)f^{-1}\\equiv (rg+mf)f^{-1} \\equiv rgf^{-1}+mff^{-1} \\equiv mff^{-1}\\equiv m \\ (mod\\ g) $$\n就得到明文了。\nfrom Crypto.Util.number import long_to_bytes,inverse f = 4685394431238242086047454699939574117865082734421802876855769683954689809016908045500281898911462887906190042764753834184270447603004244910544167081517863 g = 5326402554595682620065287001809742915798424911036766723537742672943459577709829465021452623299712724999868094408519004699993233519540500859134358256211397 q = 172620634756442326936446284386446310176482010539257694929884002472846127607264743380697653537447369089693337723649017402105400257863085638725058903969478143249108126132543502414741890867122949021941524916405444824353100158506448429871964258931750339247018885114052623963451658829116065142400435131369957050799 e = 130055004464808383851466991915980644718382040848563991873041960765504627910537316320531719771695727709826775790697704799143461018934672453482988811575574961674813001940313918329737944758875566038617074550624823884742484696611063406222986507537981571075140436761436815079809518206635499600341038593553079293254 m = (e*f % q) % g m *= inverse(f, g) print(long_to_bytes(m % g)) # y0u_ar3_s0_f@st 从公钥得到私钥 上面只是介绍了这个简单的加密模型，如果要破解它，就要从公钥 $(q,h)$ 计算出私钥 $(f,g)$ ，其中 $h=g/f$，并且 $g$ 和 $f$ 都是在 $\\sqrt{q}$ 的数量级。\n所以可以找到符合条件的 $(F,G)$ 就可以解密了，所以构建向量： $$ F(1,h)-R(0,q)=(F,G) $$ 其中$v_1=(1,h),\\ v_2=(0,q)$，所以短向量 $(F,G)$ 在格$L={a_1v_1,a_2v_2}$ 中。\n现在问题就被转化成二维的格的最短向量问题，由于是二维的格，可以用高斯格基规约算法。\nfrom gmpy2 import iroot, sqrt from Crypto.Util.number import * q = 126982824744410328945797087760338772632266265605499464155168564006938381164343998332297867219509875837758518332737386292044402913405044815273140449332476472286262639891581209911570020757347401235079120185293696746139599783586620242086604902725583996821566303642800016358224555557587702599076109172899781757727 h = 31497596336552470100084187834926304075869321337353584228754801815485197854209104578876574798202880445492465226847681886628987815101276129299179423009194336979092146458547058477361338454307308727787100367492619524471399054846173175096003547542362283035506046981301967777510149938655352986115892410982908002343 e = 81425203325802096867547935279460713507554656326547202848965764201702208123530941439525435560101593619326780304160780819803407105746324025686271927329740552019112604285594877520543558401049557343346169993751022158349472011774064975266164948244263318723437203684336095564838792724505516573209588002889586264735 def gaussian(v1, v2): while True: if sqrt(v2[0]**2+v2[1]**2) \u0026lt; sqrt(v1[0]**2+v1[1]**2): v1, v2 = v2, v1 m = int((v1[0]*v2[0]+v1[1]*v2[1])/(v1[0]**2+v1[1]**2)) if m == 0: return (v1, v2) v2 = [v2[0]-m*v1[0], v2[1]-m*v1[1]] s1, s2 = gaussian([1, h], [0, q]) f, g = s1[0], s1[1] m = (e*f % q) % g m *= inverse(f, g) print(long_to_bytes(m % g)) # l1Ii5n0tea5y ","permalink":"https://slightwind.cn/posts/crypto/find-short-vectors-in-two-dimensional-lattices/","summary":"Notes for $An\\ Introduction\\ to\\ Mathematical\\ Cryptography$\n“A toy model of a real public key cryptosystem” 这里以 An Introduction to Mathematical Cryptography 书中的一个简单的加密模型为例，简单介绍一下通过高斯格基规约算法（Gaussian Lattice Reduction）解决二维的格上的寻找最短向量问题。\n最近在书中看到这个，刚好 西电新生赛@Mini L-CTF 有两个题目刚好是用这个模型实现的，当做例题整个 writeup。\ntask.py\nfrom Crypto.Util.number import bytes_to_long, getPrime, inverse from gmpy2 import iroot q = getPrime(1024) f = getPrime(511) g = getPrime(511) while g \u0026lt; iroot(q//4, 2)[0] or g \u0026gt; iroot(q//2, 2)[0]: g = getPrime(511) f_inv_q = inverse(f, q) h = f_inv_q*g % q m = bytes_to_long(b'flag') # flag is base**(flag) r = getPrime(510) e = (r*h+m) % q print(f) print(g) print(q) print(e) ''' f = 4685394431238242086047454699939574117865082734421802876855769683954689809016908045500281898911462887906190042764753834184270447603004244910544167081517863 g = 5326402554595682620065287001809742915798424911036766723537742672943459577709829465021452623299712724999868094408519004699993233519540500859134358256211397 q = 172620634756442326936446284386446310176482010539257694929884002472846127607264743380697653537447369089693337723649017402105400257863085638725058903969478143249108126132543502414741890867122949021941524916405444824353100158506448429871964258931750339247018885114052623963451658829116065142400435131369957050799 e = 130055004464808383851466991915980644718382040848563991873041960765504627910537316320531719771695727709826775790697704799143461018934672453482988811575574961674813001940313918329737944758875566038617074550624823884742484696611063406222986507537981571075140436761436815079809518206635499600341038593553079293254 ''' 其中私钥为 ( f , g ) ，公钥为 ( q , h ) ，这个已经给了私钥，所以解密过程非常简单。","title":"Find short vectors in two-dimensional lattices"},{"content":"模数两两互素时 from Crypto.Util.number import inverse from functools import reduce def crt(a, m): '''Return a solution to a Chinese Remainder Theorem problem. ''' M = reduce(lambda x, y: x*y, m) Mi = [M//i for i in m] t = [inverse(Mi[i], m[i]) for i in range(len(m))] x = sum([a[i]*t[i]*Mi[i] for i in range(len(m))]) return x % M 不满足模数两两互素时 这种情况有最小解 $x$ 满足条件，很多博客也讲的很详细，但是没找到 Python 写的\u0026hellip;\n与 $m$ 互素时一样，$m$ 不互素时显然也会有无限个解 $X = k \\cdot M + x$ ，但是 $m$ 之间不互素时，在模 $M$ 的意义下也可能会有多个解。\n$x$ 为最小解，$m_1 , m_2 , \\dots , m_n$ 的最小公倍数为 $L$ ，$X \u0026lt; M$ ，易知 $X = x + k \\cdot L$ ，枚举 $k$ 就可以了。\nfrom Crypto.Util.number import GCD, inverse from functools import reduce def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def crt_minial(a, m): '''Return the minial solution to a Chinese Remainder Theorem problem. ''' assert len(a) == len(m), f\u0026quot;length of {a} is not equal to {b}\u0026quot; m1, a1, lcm = m[0], a[0], m[0] for i in range(1, len(m)): c = a[i]-a1 g, k, _ = egcd(m1, m[i]) lcm = lcm*m[i]//GCD(lcm, m[i]) assert c % g == 0, 'No Answer!' t = m[i]//g a1 += m1*(((c//g*k) % t + t) % t) m1 = m[i]//g*m1 return a1 ","permalink":"https://slightwind.cn/posts/crypto/chinese-remainder-theorem/","summary":"模数两两互素时 from Crypto.Util.number import inverse from functools import reduce def crt(a, m): '''Return a solution to a Chinese Remainder Theorem problem. ''' M = reduce(lambda x, y: x*y, m) Mi = [M//i for i in m] t = [inverse(Mi[i], m[i]) for i in range(len(m))] x = sum([a[i]*t[i]*Mi[i] for i in range(len(m))]) return x % M 不满足模数两两互素时 这种情况有最小解 $x$ 满足条件，很多博客也讲的很详细，但是没找到 Python 写的\u0026hellip;\n与 $m$ 互素时一样，$m$ 不互素时显然也会有无限个解 $X = k \\cdot M + x$ ，但是 $m$ 之间不互素时，在模 $M$ 的意义下也可能会有多个解。","title":"Chinese Remainder Theorem"},{"content":"HGAME 2020 week1 writeup Web Cosmos 的博客 看提示去 GitHub 上找这个网站的源代码，搜索 Cosmos Hgame 就可以找到，点开 3 commits，点开 new file 就可以看到： aGdhbWV7ZzF0X2xlQGtfMXNfZGFuZ2VyMHVzXyEhISF9 base64 解码得到 flag。 hgame{g1t_le@k_1s_danger0us_!!!}\nCrypto InfantRSA 题目：\np = 681782737450022065655472455411; q = 675274897132088253519831953441; e = 13; c = pow(m,e,p*q) = 275698465082361070145173688411496311542172902608559859019841 exp：\np = 681782737450022065655472455411 q = 675274897132088253519831953441 e = 13 c = 275698465082361070145173688411496311542172902608559859019841 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % m d=modinv(e,(p-1)*(q-1)) m=pow(c,d,p*q) print(hex(m)) Affine 题目:\nimport gmpy2 from secret import A, B, flag assert flag.startswith('hgame{') and flag.endswith('}') TABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM' MOD = len(TABLE) cipher = '' for b in flag: i = TABLE.find(b) if i == -1: cipher += b else: ii = (A*i + B) % MOD cipher += TABLE[ii] print(cipher) # A8I5z{xr1A_J7ha_vG_TpH410} 仿射加密解密，（$A^{-1}$为 A 对 MOD 的逆元）。 c=(A*x+B) % MOD m=$A^{-1}A$−1(x−B) % MOD 可以看出想解密要知道 A 和 B ，我们已知 “hgame{” 被加密成了 “A8I5z{” ，我们只需要取前两个字符就可以枚举出 A 和 B 了，从 12 变到46（ h 变成 A ），从 11 变到 33（ g 变成 8 ），模数 MOD 为 TABLE 的长度 62。 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ for(int i=0;i\u0026lt;62;i++) for(int j=0;j\u0026lt;62;j++) if(((i*12+j)%62==46)\u0026amp;\u0026amp;((i*11+j)%62==33)\u0026amp;\u0026amp;((i*7+j)%62==43)){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;' '\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; break; } return 0; } 得到 A 和 B 的值 13 14 就可以解密了。 import gmpy2 TABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM' cipher='A8I5z{xr1A_J7ha_vG_TpH410}' def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % m MOD = len(TABLE) A=13 B=14 C=modinv(A , MOD) flag = '' for b in cipher: i = TABLE.find(b) if i == -1: flag += b else: ii = C*(i - B) % MOD flag += TABLE[ii] print(flag) # hgame{M4th_u5Ed_iN_cRYpt0} not_One-time 题目：\nimport os import random import string import binascii import base64 from secret import flag assert flag.startswith(b'hgame{') and flag.endswith(b'hgame{') flag_len = len(flag) def xor(s1, s2): #assert len(s1)==len(s2) return bytes(map((lambda x: x[0] ^ x[1]), zip(s1, s2))) random.seed(os.urandom(8)) keystream = ''.join( [random.choice(string.ascii_letters+string.digits) for _ in range(flag_len)]) keystream = keystream.encode() print(base64.b64encode(xor(flag, keystream)).decode()) 这题可以 nc 连接服务器，所以可以得到很多的 flag 密文，而且已知flag以 ‘hgame{’ 开始以 ‘}’ 结束。\n加密脚本就是用 flag 和随机等长字符串异或运算然后输出base64编码后的结果，一开始在网上各种找资料，流加密多次密钥攻击，发现都是这样:\n如果攻击者可以拿到 A、B 的密文 E(A)、E(B) ，以及攻击者自己的明文 B，就可以在无需知道密钥的情况下计算出 A 的明文： A = E(A) xor E(B) xor B\n在 GitHub 上也可以找到 many-time-pad-attack 的脚本，也是需要有一段自己的字符串让脚本加密一次才能推出其他的明文。而这题显然不可以上传一个字符串让服务器上的脚本把 flag 和自己的字符串异或一下再发给自己…\n然而想到一个集合内的字符相互异或的结果也是一个很有限的集合，反过来如果知道一个异或的结果，我们就可以大概知道这个结果可能是哪些字符异或出来的，称这些字符组成的集合为A，那么以此类推（多次nc下来一些密文）得到集合B，C，D…然后取这些集合的交集就可以极大地缩小这个位置可能的字符集合。 exp：\nimport gmpy2 import base64 yb=[ 'XC8JIVMTKws0JmU/d0p6eEgAGAE/TGd+NkF0JUZ0W1YGGX8fXHsdXygPFA==', 'OikNXwJPCn8hBgQHDRI1Bmt+MVErax9eJhw9Ky0VdS4+AXIjQ0UoRigARA==', 'XxIJXlYiGgU6G2lfDV4JYWxCUgkQZxRyDzRwHiExcjNqLwsIb11hYQhTSQ==', 'JQ0vBRQyInETGEBXclMCARBCVAgGGmpiHR52NDwIZSw1PkVuWAQZUHUOGw==', 'DFUxIgJDIVE9BmJZLRMCWxRdIyIkfEtHKksgIUExZFAZElIeVWY2dTspJQ==', 'HxE1IxUtI1EaO3ZbA0YbCxZcKyo9eWkUOyY/KUIlWREvU0ptfWQXfyoDMA==', 'DiwqBi9IFAQdAF8nPRp9ZFBbLCFXZx5OLzofJjN0ZTMyDFUsQAQ2Ww4wDA==', 'ACQiXyQRNEY/EglaH2gedU17EDALRRJASQgzEwERXAs9EgIXbGQTYQgfEw==', 'DFUMPCsaAHwPG1wAARofRkoAL1Qcf1N/BCNwVyEkAgc6U3E3FAQZfBItPA==', 'OzQmBxcIQn4vRkM9JBIrYGdiMAEueWpWRhwCMEIuZi44Lmc0SUc4fy0jFw==', 'IwQ0LAsCEXs3MgI6PkkLSWxcCV8cSk9BFxsNDSUXAVURLQM6SgYqcgwDFg==', 'DxMDBF1MHlg9NEY+dn4gA0VeCy4RRBdDCQh2EzJ0UCNtG0YYXF9pexo0LA==', 'JAwZOiMYNHEBGAFYH1osfENeNTILax9jDQIsKjt1WAUcHFQLY3E8VnUyBQ==', 'LgYVKD8UFl0mOFxZLmE+QUx0KAQySFBHHRh2ViY6Sj45XHc3ZwU+cBYpLQ==', 'BS8gOVUBHlxBC3s5DH5/Q21CFB4Wen8eTxE9UDYXfwgGD0krXQc0bi0wMA==', 'LDYzOAQQJ1xBCQkkLWA1UnQFMRcXV2IVJgsmCzQTWyAHWlgdfmQ6YjkNDg==', 'IBUKJjATJ0URJn89EEkeShUCJgU8SxNcEz0zPjcacTEeKkE1an0kdwUvPw==', 'XjMmARAXJ1U8G18CDkAKW35UMiw3QxVRRkV3AgRxAR4+OH4pSUIRUnoQHA==', 'PxMSIw40F0YmCwgeDUc0dBZxGS4Rd0x/SiUxFBAtZw9qKQQpYAc6ZxAXTg==', 'MDMMDyABOGE6EnUWF0Z1ZhBsKCwjRmoWPwEJLEwzZVIMPV44eQQaWDozKQ==', 'Xj8kNzYqAlAeR3YtKXIfWlxmUgZSWkJtHzYmHgI5Bg4IW2ocZmIxBHoXEA==', 'IBUXDCI1BnctHQQ9dn0MVkxsFSgEXXx+CSYCUSYpRjU6DUpgWVodDAEGGw==', 'DREYGQszP0oaEXAkN1k3QkteBVAWaktiOyQWVxg0AxVvI3cRHWYUWCsyMg==', 'LDMwG1cqIH0iKUQIE30hf2B7UjIffhRKS0M1Hiw0XC49CQYSZE8jX3JXMA==', 'IAYiWA8XAF4mHGNXPVI6B21NLwIcVVRLN0ZwNwc2fCAMGX8yZGAcDSQnMA==', 'Lhc0ClAUG0IiOFYaM2x8dXRtUTBRdFNCESscUTY3VwsvJGAwFQ0bXSs2TA==', 'CgQEDzdLAVBNGkgiHXI8RRJNEC0UW0BzJiYDVQEWazIcJXQ/HnA0RToGRQ==', 'JFEQJDI/IQYCK1QaKWwfWFRSNA5WeBdfCEoENh5yfAcLKGMcH3EnWC5QFw==', 'PwgjIRcTBkMiRnY3Ek4EZ3RWBjYfHGJQLDwxLQwvSzwtHn0oamY4AhEKOQ==', 'HBNTCi0UOFAQNAEHFEUcUVBjDSxXRE0WNgd8IB0Nawc3DlE1R2YYAw8DNw==', 'ETNQDikdF2cdNnokDEk+BRRABDUNHkwWLCEuIxIJYTcZIUkSe1scYjsnJw==', 'CjZSKiYBF0E+GGI4KRo+BhV6VjMtW2pvTwA2J0Z1ZiNpAVQTW3wFeikmDA==', 'CwMRI1Q3AnoPHn9ZDWAaRWd2MxQKWxV8J0MHAD0NajYvG1QVWw0UXXUoSQ==', 'Wi4RJSkoCnYNRHMUME8eC0B5EQxWdx50LSQJDUZ7YzQaGXApYG0XTiJdCw==', 'CiMrOQIjEFIPIgQ3MGAiZncAOzAURUxNFEQmMiUrXgg7LEQTY0QCci4nKg==', 'KlcRVS8sCFAFOgQkA3EoV0EGBhAEfBd3KyoDHUU1ai8rJkRqTFMkQjIBHg==', 'WQs0DFVNAnU2NWc2cRp0RF5MWD4IYGcQEEcQJT8NXxIdWFc2TGUGcywyJQ==', 'KywDNRIaRFdFRF4NEX0jXWthIB0jTFxKHwd3Dk0OZzMpOEYPZ0ApXzY9Cw==', 'HDRRGR0XJ34DQ1kaA058W2JiDi8IQXVHBhohMD02eyUwKF0eGmQUbgxSTQ==', 'WR0tLjBCCFYGJ3otF18eelZ0NQ0NW0NANQciEBwLSTc1O3oATH8eXSQ8Jw==', 'PAI4IVcDM1oBRAUHd0YMa1FgCSYMYU1fMTEmEgJ7fxQoUkcURncVWAYVNg==', 'Jy0tNyxPRwUyQWleP0B0XUViVgMHTlBWL0QWKTg7YlMFLWoYR2Elc3sHKg==', 'DQoWFyEwCEUzJl0IcF4dYUh5Vh4/FWpzECM2ABx2Rg4UWWsMekYBTnQKCw==', 'AFUvJTwYJn0nAHcACnIoYHV5DRYIZHNNOUAMPgAgClVpH3pqZFJoBjsdHA==', 'XwJXKyZOM2I0R3ctEUYISmtwAyYpGVxSLCYTIwAnYFYwG1wQf19gTStUSw==', 'WT8CXQ8fQGsyEl49CV8DBEZ9WTcwbm50TDEwIj06QTRuIXttYF0RVhRWDg==', 'OgovCQo1H1IlOEc6cmp1akNfLQU2ZkpiC0txDAMZYQgUIUoTXnsWfBMDOQ==', 'OSILWjw6CngZBAkdDmYcakFnWBAcYhB/TwAKAAEGYBAYB1VvTHAjbnYiRQ==', 'GTVQN1UdEHkSJX0cKUgefFBUIiggQ0VEJAIADQYaZFZoMnQMV3QzYgVUOQ==', 'GAEvXVM3JAAiGgcLAF44YmEDNSohYxBgCUE/XD4FRCEUI2kNXFhjQnRROg==', 'ORQKLiEhBUs4S2AicEgmdFJSNC9Ud2xWOxovXTB2dlMSUwZte1xmBAQ0Tg==', 'P1BTOV0tFFsXNVMYNUc6ARJ/MAokG3FRDhofHiQyUAc0CGEXQ2QfVxc3BQ==', 'JhMZHgE0B0sSEH0EMEMXR3FnMgEiSmdtRkd2AwYwXAJuXH0QGwQEQ3AiEw==', 'DVMGKREaEwU+OEEqDGB5QktCNxQtSlNSBCE2FT8xAhRoDWsdSWYIWjQOFA==' ] for i in range(0, 54): yb[i] = base64.b64decode(yb[i]).decode() yb[i] = bytes(yb[i], encoding='utf-8') # KeySpace里面可以加其他的字符 KeySpace = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890{}-' leng = len(KeySpace) def maybe(Hex): ans = '' for i in range(0, leng): for j in range(i, leng): x = KeySpace[i] ^ KeySpace[j] if x == Hex: ans += chr(KeySpace[i])+chr(KeySpace[j]) return ans def PublicChr(aa, bb): anss = '' laa = len(aa) lbb = len(bb) for i in range(0, laa): for j in range(0, lbb): if aa[i] == bb[j]: if anss.find(aa[i]) == -1: anss += aa[i] return anss for i in range(0, 43): Ans = PublicChr(maybe(yb[0][i]), maybe(yb[1][i])) for j in range(0, 54): Ans = PublicChr(maybe(yb[j][i]), Ans) print(Ans) hgame{r3us1nG+M3$5age-\u0026amp;\u0026amp;~rEduC3d_k3Y-5P4Ce}\nReorder 这题只有 nc 连接，随便输入会发现顺序被打乱后输出，最后输出打乱后的 flag ，所以只要按顺序输入字母数字然后看是怎样被打乱的，就说明 flag 也被用同样的方法打乱了，直接复原即可。\nhgame{jU$t+5ImpL3_PeRmuTATi0n!!}\nMisc 欢迎参加HGame！ 来来来，签个到吧～ Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t 注：若解题得到的是无hgame{}字样的 flag 花括号内内容，请手动添加hgame{}后提交。 【Notice】解出来的字母均为大写\nbase64 解码，然后摩斯电码解码。 hgame{W3LC0METO2020HGAM3}\n壁纸 binwalk 提取出来个加密过的 zip，然后两秒爆破数字出密码 76953815 。 Unicode 转中文。 hgame{Do_y0u_KnOW_uNiC0d3?}\n克苏鲁神话 题目解压出一个 Bacon.txt，一个 Novel.zip。 zip 爆破使用明文攻击（Plain-text），明文文件选择加密后的 Bacon.zip 。得到可以直接解压的 Novel.zip 。 解压Novel.zip发现加密的doc文件。Bacon.txt里的大小写转换为B和A，然后培根解密。 AABABABABBAAAAAAABBAAABBBABAAAAAABBAAABBAABAAABBABABAAAABBABAAABBABBBAAAABA\n解密后：FLAGHIDDENINDOC\ndoc 里一篇文章，看不到 flag ，Word：「选项」-「显示」-「隐藏文字」。拉到文章底部看到 flag 。 hgame{Y0u_h@Ve_F0Und_mY_S3cReT}\n签到题ProPlus Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y h jnsxf qjFjf jnb rg fiyykwtbsnkm tm xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn. JRFVJYFZVRUAGMAI Three fences first, Five Caesar next. English sentense first, zip password next.\n按提示分别操作两段字符串，栅栏三个一组解密后，凯撒移位5个，上面的会变成一段话，下面的是密码：EAVMUBAQHQMVEPDT。 解压看到里面的 txt 内容是一堆 ook ，网站在线解码 ，然后 base32 ，接着 base64 。 base64 解出来的明文会乱码，只能查看16进制，开头是89 50 4e 47，png 的文件头，复制。 winHex：「文件」-「新建」-「1Bytes」-「确定」-「Ctrl+V 粘贴」- 选择「Ascii Hex」然后删去开头的“00”，然后另存为 xxx.png。 得到二维码，扫了就出 flag。 hgame{3Nc0dInG_@lL_iN_0Ne!}\n","permalink":"https://slightwind.cn/posts/ctf/hgame-2020-week1-writeup/","summary":"HGAME 2020 week1 writeup Web Cosmos 的博客 看提示去 GitHub 上找这个网站的源代码，搜索 Cosmos Hgame 就可以找到，点开 3 commits，点开 new file 就可以看到： aGdhbWV7ZzF0X2xlQGtfMXNfZGFuZ2VyMHVzXyEhISF9 base64 解码得到 flag。 hgame{g1t_le@k_1s_danger0us_!!!}\nCrypto InfantRSA 题目：\np = 681782737450022065655472455411; q = 675274897132088253519831953441; e = 13; c = pow(m,e,p*q) = 275698465082361070145173688411496311542172902608559859019841 exp：\np = 681782737450022065655472455411 q = 675274897132088253519831953441 e = 13 c = 275698465082361070145173688411496311542172902608559859019841 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g !","title":"HGAME 2020 week1 writeup"},{"content":"Experience 2023.7 ~ : Software Development Engineer @Huawei\n2022.7 ~ 2022.9: Software Development Intern @Huawei\n2022.5 ~ 2022.7: Security Research Intern @Sangfor\n2021.7 ~ 2021.9: Security Research Intern @DBAPP Security\nEducation 2019.8 ~ 2023.6: Information Security @NJUPT\nContact Email: slightwindsec@gmail.com\nEmail: cy@njupt.edu.cn\n","permalink":"https://slightwind.cn/about/","summary":"Experience 2023.7 ~ : Software Development Engineer @Huawei\n2022.7 ~ 2022.9: Software Development Intern @Huawei\n2022.5 ~ 2022.7: Security Research Intern @Sangfor\n2021.7 ~ 2021.9: Security Research Intern @DBAPP Security\nEducation 2019.8 ~ 2023.6: Information Security @NJUPT\nContact Email: slightwindsec@gmail.com\nEmail: cy@njupt.edu.cn","title":"About"},{"content":"","permalink":"https://slightwind.cn/categories/","summary":"categories","title":"Categories"}]