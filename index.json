[{"content":"定点和浮点中的“点”指的是小数点，定点数在比特位的定义上确定了小数点的位置，而浮点数使用更复杂的表示方式，导致小数点在若干个比特位上没有直接体现，所以称它是浮点。\n定点数 1. \u0026ldquo;定点\u0026quot;表示的整数 4-bit无符号整数可以用下面这种方式来表示：\n整数不存在小数点，也可以说我们默认小数点固定在整数的末尾，所以整数的表示也可以看作是“定点”。\n2. 定点表示的小数 使用7位二进制，前4位表示整数部分，后3位表示小数部分，可以这样表示：\n$$ \\begin{array}{c:c:c:c|c:c:c} 2^3 \u0026amp; 2^2 \u0026amp; 2^1 \u0026amp; 2^0 \u0026amp; 2^{-1} \u0026amp; 2^{-2} \u0026amp; 2^{-3} \\end{array} $$\n小数点固定在第4、第5个比特之间，分别计算每个位置的值并求和即可得到这段二进制表示的小数值：\n可以表示的范围是 $[0.0, 15.875]$，表示的数之间的最小间隔是 $0.125$，并且间隔是均匀的。\n定点数的特点：\n定点数和整数的表示很接近，计算也像整数一样简单高效； 几乎可以重用为整数运算设计的硬件； 表示的数值间隔均匀，但是整体范围较小。 浮点数 为了方便理解，我们还是从最简单的无符号整数开始，逐步定义出浮点数。\n4-bit可以表示出集合 $A=\\{i|0\\leq i \\leq 15, i\\in \\Z\\}$，如果把它们看作 $2$ 的指数，就可以表示出数值更大的集合 $B=\\{2^i|i\\in A\\}$，但是数据变得非常稀疏，并且是距离0越远越稀疏。\n前 $4$ 位二进制可以称为指数（Exponent），简写为 $E$；为了表示小数，我们再加入 $3$ 位尾数（Mantissa），简写为 $M$，尾数部分和之前的计算方式相同：\n$$ \\begin{array}{c:c:c} 2^{-1} \u0026amp; 2^{-2} \u0026amp; 2^{-3} \\end{array} $$\n例如：尾数101可以计算得到 $\\bold{1}\\times 0.5+\\bold{0}\\times 0.25+\\bold{1}\\times 0.125=0.625$\n将指数部分的值与尾数部分的值相乘得到十进制的结果：\n发现这样会导致出现重复的表示，比如 $2\\times 0.25 = 4\\times 0.125 = 0.5$，我们可以在全部的尾数前都加入一个隐式前导位（implicit leading bit），（除保留的特殊值 $0$ 以外）前导位永远为 $1$，我们不用花费一个比特位来存储它，所以它是“隐式”的。隐式前导位使尾数的范围从 $[0, 1)$ 变成了 $[1, 2)$，在区间 $[1, 2)$ 内就不存在 $2$ 倍、$4$ 倍这样的关系了。\n但这又引入了新的问题，指数部分 $E \\geq 0$，$2^E \\geq 1$，与 $M\\in [1, 2)$ 相乘也只能得到大于等于 $1$ 的结果，区间 $[0, 1)$ 内的值无法表示。\n这时，我们可以引入指数偏差（Exponent bias）$bias$ 来得到有符号的指数 $E - bias$，当 $bias=7$ 时，就可以得到 $$ 2^{E-bias} \\in \\{2^{-7}, 2^{-6}, 2^{-5}, 2^{-4}, 2^{-3}, 2^{-2}, 2^{-1}, 2^{0}, 2^{1}, 2^{2}, 2^{3}\\} $$\n另外，我们还需要保留一些特殊值，例如 $0$、$NaN$ 以及 $INF$。 $$ \\begin{align} 0 \u0026amp;= 0000.000_2 \\\\ NaN \u0026amp;= 1111.111_2 \\end{align} $$\n这时我们的 7 位无符号浮点数能够表示的最小非 $0$ 值为\n$$ 0000.001_2 = 2^{-7} \\times (1.0 + 2^{-3}) = 0.0087890625 $$\n我们希望 $0$ 到最小非 $0$ 值之间的下溢空隙尽可能的小，就可以在计算过程中更少出现算术下溢（比如两个很接近的浮点数相减，出现下溢可能导致除 $0$ 风险），我们可以约定当 $E = 0$ 时，隐式前导位为 $0$，$E \\neq 0$ 时，隐式前导位为 $1$：\n$E = 0$ 且 $M = 0$ 时，即 $0000.000$ 作为 $0$ 保留 $E = 0$ 且 $M \\neq 0$ 时，约定隐式前导位为 $0$，这种浮点数用于填充最小正规数与 $0$ 之间的空隙，被称为次正规数（Subnormal number） $E \\neq 0$ 时，约定隐式前导位为 $1$，这种浮点数被称为正规数（Normal number） 由于我们可以通过 $E$ 是否为 $0$ 来约定隐式前导位是否为 $0$，所以仍不需要单独用 $1$ 比特来存储前导位。\n在 $E = 0$ 时，令隐式前导位也为 $0$，就可以表示出更小的非零值（称这种特殊场景为次正规数）\n$$ 0000.001_2 = 2^{-7} \\times 2^{-3} = 0.0009765625 $$\n次正规数使我们的 7 位浮点数可以表示的最小非 $0$ 值从 $0.0087890625$ 缩小到了 $0.0009765625$，如下图所示，相比正规数（以红色表示），使用次正规数（蓝色）可以扩展表示的范围：\n最后，为了表示负数，可以在前面增加 1 位符号位，符号位为 1 时表示负数，这样就完成了比较完整的 8 位浮点数定义，我们来总结一下：\n使用 $S.E.M$ 的格式来定义这个 8 位的浮点数：\nSign：使用 1 bit 来表示符号，值为 1 时表示负数； Exponent：使用 4 bits 来表示指数； Mantissa：使用 3 bits 来表示尾数。 正规数（$E\\neq 0$ 时）： $$ value = (-1)^{sign} \\times 2^{(E-7)} \\times \\Bigg(1 + \\sum_{i=1}^{3}b_{3-i}2^{-i} \\Bigg) $$\n次正规数（$E=0, M\\neq 0$ 时）： $$ value = (-1)^{sign} \\times 2^{(E-7)} \\times \\Bigg(0 + \\sum_{i=1}^{3}b_{3-i}2^{-i} \\Bigg) $$\n特殊值： $0 = 0000.000_2$ $NaN = 1111.111_2$ 常见的浮点类型 前面已经介绍了一些概念，比如：尾数、隐式前导位、次正规数等，这些概念普遍存在于实际应用的常见浮点类型。\n","permalink":"https://slightwind.cn/posts/modelquantization/fixed-point-and-float-point/","summary":"定点和浮点中的“点”指的是小数点，定点数在比特位的定义上确定了小数点的位置，而浮点数使用更复杂的表示方式，导致小数点在若干个比特位上没有直接体现，所以称它是浮点。\n定点数 1. \u0026ldquo;定点\u0026quot;表示的整数 4-bit无符号整数可以用下面这种方式来表示：\n整数不存在小数点，也可以说我们默认小数点固定在整数的末尾，所以整数的表示也可以看作是“定点”。\n2. 定点表示的小数 使用7位二进制，前4位表示整数部分，后3位表示小数部分，可以这样表示：\n$$ \\begin{array}{c:c:c:c|c:c:c} 2^3 \u0026amp; 2^2 \u0026amp; 2^1 \u0026amp; 2^0 \u0026amp; 2^{-1} \u0026amp; 2^{-2} \u0026amp; 2^{-3} \\end{array} $$\n小数点固定在第4、第5个比特之间，分别计算每个位置的值并求和即可得到这段二进制表示的小数值：\n可以表示的范围是 $[0.0, 15.875]$，表示的数之间的最小间隔是 $0.125$，并且间隔是均匀的。\n定点数的特点：\n定点数和整数的表示很接近，计算也像整数一样简单高效； 几乎可以重用为整数运算设计的硬件； 表示的数值间隔均匀，但是整体范围较小。 浮点数 为了方便理解，我们还是从最简单的无符号整数开始，逐步定义出浮点数。\n4-bit可以表示出集合 $A=\\{i|0\\leq i \\leq 15, i\\in \\Z\\}$，如果把它们看作 $2$ 的指数，就可以表示出数值更大的集合 $B=\\{2^i|i\\in A\\}$，但是数据变得非常稀疏，并且是距离0越远越稀疏。\n前 $4$ 位二进制可以称为指数（Exponent），简写为 $E$；为了表示小数，我们再加入 $3$ 位尾数（Mantissa），简写为 $M$，尾数部分和之前的计算方式相同：\n$$ \\begin{array}{c:c:c} 2^{-1} \u0026amp; 2^{-2} \u0026amp; 2^{-3} \\end{array} $$\n例如：尾数101可以计算得到 $\\bold{1}\\times 0.5+\\bold{0}\\times 0.25+\\bold{1}\\times 0.125=0.625$\n将指数部分的值与尾数部分的值相乘得到十进制的结果：","title":"定点数和浮点数"},{"content":"Mistral-7B\u0026rsquo;s performance on 5-shot MMLU 如果对测试细节不感兴趣，只需要看下面给出的汇总表格即可。\nOverview 量化/非量化版本的 Mistral-7B-v0.1 模型在 5-shot MMLU 上的表现：\nQuant Type Compute Dtype Double Quant Group Size Avg (%) Total Time (s) BF16 BF16 N/A N/A $61.00$ $312.79$ INT8 BF16\u0026amp;INT8 N/A N/A $60.87$ $614.43$ FP4 FP16 False 64 $59.37$ $347.00$ FP4 FP16 True 64 $59.17$ $353.22$ FP4 FP32 False 64 $59.50$ $1061.27$ NF4 FP16 False 64 $59.04$ $361.19$ NF4 FP16 False 128 $58.78$ $352.65$ AWQ-q4 FP16 N/A 128 $59.76$ $377.72$ GPTQ-q4 FP16 N/A 128 $59.30$ $251.72$ 5-shot C-Eval：\nQuant Type Compute Dtype Double Quant Group Size Avg (%) Total Time (s) BF16 BF16 N/A N/A $47.47$ - INT8 BF16\u0026amp;INT8 N/A N/A $48.29$ $683.67$ FP4 FP16 False 64 $46.21$ $292.20$ FP4 FP16 True 64 $46.21$ $292.51$ FP4 FP32 False 64 $46.21$ $874.55$ NF4 FP16 False 64 $45.76$ $299.82$ NF4 FP16 False 128 $44.13$ $298.83$ AWQ-q4 FP16 N/A 128 $46.35$ $345.56$ GPTQ-q4 FP16 N/A 128 $45.98$ $214.87$ 同时，也简单记录了量化对模型推理速度的影响：\nQuant Type Compute Dtype Batch Size Input (tokens) Output (tokens) First Token (ms) Non-first Token (ms) BF16 BF16 1 128 128 $38.5$ $22.0$ BF16 BF16 8 128 128 $242$ $25.9$ INT8 BF16\u0026amp;INT8 1 128 128 $193$ $88.6$ INT8 BF16\u0026amp;INT8 8 128 128 $403$ $101$ NF4 FP16 1 128 128 $69.3$ $15.2$ NF4 FP16 8 128 128 $270$ $56.8$ 4-bit 当 batch size 为 1 时，会使用性能更好的 gemv 算子，速度较快。\nBF16 Inference Mistral-7B 是一个很强的 7B 开源模型，在 Mistral 官网和论文中声称可以在 5-shot MMLU 上达到 60.1% 的准确率，首先下载官方的模型权重文件（Mistral-7B-v0.1）并直接在原精度（BF16）上进行推理，尝试复现出官方的准确率。\nllmtask 这里使用 llmtask 来进行下游任务测试，非常方便快捷，只需要\npip install llmtask==0.0.2 即可完成安装，可以直接测试模型在 C-Eval 和 MMLU 数据集上的表现。\n示例代码：\nimport random from llmtask import TaskGenerator choices = (\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;D\u0026quot;) TG = TaskGenerator(\u0026quot;mmlu\u0026quot;, max_shot=4) for task in TG: TG.feedback(random.choice(choices)) print(TG.summary()) 测试 Mistral-7B 原精度推理脚本：\nimport time import torch from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig from llmtask import TaskGenerator def log(msg): with open(\u0026quot;mmlu_5shot_bf16.log\u0026quot;, \u0026quot;a\u0026quot;) as f: f.write(f\u0026quot;{msg}\\n\u0026quot;) device = \u0026quot;cuda\u0026quot; model = AutoModelForCausalLM.from_pretrained(\u0026quot;/path/to/Mistral-7B-v0.1\u0026quot;, torch_dtype=torch.bfloat16).to(device) tokenizer = AutoTokenizer.from_pretrained(\u0026quot;/path/to/Mistral-7B-v0.1\u0026quot;) cnt = 0 TG = TaskGenerator(\u0026quot;mmlu\u0026quot;, max_shot=5) for task in TG: model_inputs = tokenizer([task], return_tensors=\u0026quot;pt\u0026quot;).to(device) input_tokens = len(model_inputs['input_ids'][0]) t0 = time.time() generated_ids = model.generate(**model_inputs, max_new_tokens=1, pad_token_id=tokenizer.eos_token_id) ans = tokenizer.batch_decode([generated_ids[0][input_tokens:]])[0] log(f\u0026quot;[{cnt:5}] [{(time.time() - t0):5.3f} s] =\u0026gt; ans:{ans}\u0026quot;) cnt += 1 TG.feedback(ans) log(TG.summary()) torch.cuda.empty_cache() 测试结果如下（每次只推理一个 Token 作为模型选择的答案，很快就可以测试完成）：\nPrecision Avg (%) STEM (%) Social Science (%) Humanities (%) Other (%) Total Time (s) BF16 $61.00$ $50.46$ $75.07$ $53.47$ $68.16$ $312.79$ 平均每道题耗时 $204$ms，最后的测试结果还算比较接近官方的结果，以此作为 baseline 和量化后的模型权重对比推理下游任务准确率的损失情况。\n8-bit/4-bit Quantization 量化使用 transformers 内置的 bitsandbytes 提供的LLM.int8()作为8-bit量化算法（threshold=6.0），4-bit量化包含两种4-bit的数据类型FP4和NF4，以及torch.float32和torch.float16两种计算类型，接下来分别对这些场景进行测试。\n8-bit 进行8-bit推理只需要修改加载权重的这一行即可：\n虽然官方已经不推荐这样做了，但是这里不需要在BitsAndBytesConfig配置额外的参数，可以直接这样使用默认参数。\nmodel = AutoModelForCausalLM.from_pretrained(\u0026quot;/path/to/Mistral-7B-v0.1\u0026quot;, load_in_8bit=True) 8-bit量化后平均每道题耗时 $401$ms，测试结果如下：\nPrecision Avg (%) STEM (%) Social Science (%) Humanities (%) Other (%) Total Time (s) INT8 $60.87$ $51.09$ $73.59$ $52.89$ $69.29$ $614.43$ 4-bit 通过BitsAndBytesConfig来配置量化类型（FP4/NF4）测试脚本：\nimport time import torch from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig from llmtask import TaskGenerator def log(msg): with open(\u0026quot;mmlu_5shot_fp4_fp16.log\u0026quot;, \u0026quot;a\u0026quot;) as f: f.write(f\u0026quot;{msg}\\n\u0026quot;) device = \u0026quot;cuda\u0026quot; bnb_config = BitsAndBytesConfig( load_in_4bit=True, bnb_4bit_compute_dtype=torch.float16, bnb_4bit_quant_type=\u0026quot;fp4\u0026quot;, bnb_4bit_use_double_quant=False, bnb_4bit_quant_storage=torch.uint8 ) model = AutoModelForCausalLM.from_pretrained(\u0026quot;/path/to/Mistral-7B-v0.1\u0026quot;, quantization_config=bnb_config) tokenizer = AutoTokenizer.from_pretrained(\u0026quot;/path/to/Mistral-7B-v0.1\u0026quot;) TG = TaskGenerator(\u0026quot;mmlu\u0026quot;, max_shot=5) cnt = 0 for task in TG: model_inputs = tokenizer([task], return_tensors=\u0026quot;pt\u0026quot;).to(device) input_tokens = len(model_inputs['input_ids'][0]) t0 = time.time() generated_ids = model.generate(**model_inputs, max_new_tokens=1, pad_token_id=tokenizer.eos_token_id) ans = tokenizer.batch_decode([generated_ids[0][input_tokens:]])[0] log(f\u0026quot;[{cnt:5}] [{(time.time() - t0):5.3f} s] =\u0026gt; ans:{ans}\u0026quot;) cnt += 1 TG.feedback(ans) log(TG.summary()) torch.cuda.empty_cache() 下面是改变其中某个参数后在 MMLU 数据集上的准确率，可以看出即使是4-bit对准确率影响都没有很大，首 Token 性能还可以接近原精度，还节省了大量的空间。\nQuant Type Compute Dtype Double Quant Avg (%) Total Time (s) FP4 FP16 False $59.37$ $347.00$ FP4 FP16 True $59.17$ $353.22$ FP4 FP32 False $59.50$ $1061.27$ NF4 FP16 False $59.04$ $361.19$ 在对显卡进行清灰并更换导热硅脂后，我重新测试了FP4-FP16-False 和 FP4-FP16-True 这两组，分别只需要 $340.66$s 和 $343.25$s 就完成了推理，相比之前分别快了 $6.34$s 和 $9.97$s。\nVersions Python Packages Version torch 2.2.1 transformers 4.39.1 bitsandbytes 0.43.0 accelerate 0.28.0 llmtask 0.0.2 ","permalink":"https://slightwind.cn/posts/modelquantization/quantization-impact-on-model-accuracy/","summary":"Mistral-7B\u0026rsquo;s performance on 5-shot MMLU 如果对测试细节不感兴趣，只需要看下面给出的汇总表格即可。\nOverview 量化/非量化版本的 Mistral-7B-v0.1 模型在 5-shot MMLU 上的表现：\nQuant Type Compute Dtype Double Quant Group Size Avg (%) Total Time (s) BF16 BF16 N/A N/A $61.00$ $312.79$ INT8 BF16\u0026amp;INT8 N/A N/A $60.87$ $614.43$ FP4 FP16 False 64 $59.37$ $347.00$ FP4 FP16 True 64 $59.17$ $353.22$ FP4 FP32 False 64 $59.50$ $1061.27$ NF4 FP16 False 64 $59.04$ $361.19$ NF4 FP16 False 128 $58.78$ $352.65$ AWQ-q4 FP16 N/A 128 $59.","title":"Quantization Impact on Model Accuracy"},{"content":"由于参与了一个在 PLC 和上位机之间建立加密信道的项目，需要在PLC的Win7-32bit系统中安装OpenSSL和GmSSL，因为PLC硬盘太小，所以我实际上是在虚拟机里面进行的编译。\nOpenSSL 一开始是打算编译一下的，下载了OpenSSL的源码，OpenSSL的Configure是依赖Perl的。然后下载安装了Strawberry Perl for win32，然后发现会出现各种报错，一番搜索了解到需要安装ActivePerl：\nInstall ActivePerl and remove Stawberry Perl as it is not compatible with openssl.\n但是ActivePerl的官网只提供64bit的版本，安装32bit版本的ActivePerl需要支付$912/yr：\nThe site states: \u0026ldquo;if you need 32-bit or other older/legacy versions, they are available through our new ActiveState Platform by subscribing to at least Team Tier. See pricing here.\u0026rdquo;\n这就很难搞，只能去下载安装现成的二进制文件：http://slproweb.com/products/Win32OpenSSL.html\nGmSSL GmSSL官方的编译与安装教程虽然字数不多但是很有帮助，编译过程比较顺利。\n虽然也提及要用ActivePerl，但是我在对Configure进行了一点简单修改之后，用Strawberry Perl也可以成功运行perl Configure VC-WIN32。\n直接运行perl Configure VC-WIN32会遇到报错：\u0026quot;glob\u0026quot; is not exported by the File::Glob module。\n分别在Configure和test/build.info两个文件中，把：\nuse if $^O ne \u0026quot;VMS\u0026quot;, 'File::Glob' =\u0026gt; qw/glob/; 修改为：\nuse if $^O ne \u0026quot;VMS\u0026quot;, 'File::Glob' =\u0026gt; qw/:glob/; 就可以了，接下来如果不是在Visual Studio中直接make，会报错缺少stddef.h，这时需要启动VS中的CMD来进行编译，我的版本是VS Community 2017，需要手动配置一下VS的命令行环境。\n在Visual Studio中配置命令行环境 可以参考https://blog.csdn.net/u013553529/article/details/77417058\n工具(T) -\u0026gt; 外部工具(E)... -\u0026gt; 添加(A) -\u0026gt;\n标题: Terminal 自定义，设置好会显示在工具(T)下拉框中 命令: C:\\Windows\\System32\\cmd.exe cmd.exe的绝对路径 参数: /k \u0026quot;C:\\Program Files\\Microsoft Visual Studio\\2017\\Common7\\Tools\\VsDevCmd.bat\u0026quot; 英文引号中是VsDevCmd.bat的绝对路径 初始目录: $(ProjectDir) 自定义，打开cmd时的初始目录 -\u0026gt; 确定\n配置完成之后，就可以通过工具(T)-\u0026gt;Terminal来打开cmd，这时再进入GmSSL的目录下就可以make了，遇到了新的报错：无法解析的外部符号 EVP_get_ciphernames，这个问题在https://github.com/guanzhi/GmSSL/issues/1037 有提到解决方法，定位到EVP_get_ciphernames和EVP_get_digestnames，并把它们注释掉即可。\n/* char *EVP_get_ciphernames(int aliases); char *EVP_get_digestnames(int aliases); */ 现在就可以畅通无阻的make、make install了。\n配置环境变量 命令行调用gmssl环境变量：\n右键计算机-\u0026gt;属性-\u0026gt;高级系统设置-\u0026gt;环境变量-\u0026gt;系统变量Path-\u0026gt;编辑-\u0026gt;添加C:\\Program Files\\GmSSL\\bin;-\u0026gt;确定-\u0026gt;确定-\u0026gt;确定\ngcc/g++编译环境变量：\n变量 值 备注 PATH C:\\Program Files\\GmSSL\\bin; 命令行可执行文件 LIBRARY_PATH C:\\Program Files\\GmSSL\\lib; 编译时调用的lib C_INCLUDE_PATH C:\\Program Files\\GmSSL\\include; C程序#include\u0026lt;\u0026gt; CPLUS_INCLUDE_PATH C:\\Program Files\\GmSSL\\include; C++程序#include\u0026lt;\u0026gt; 编译时参数-lcrypto一直不能用，结果在C:\\Program Files\\GmSSL\\lib中把libcrypto.lib重命名为crypto.lib后成功解决，可以正常编译包含gmssl的c/cpp程序。\n","permalink":"https://slightwind.cn/posts/environment/install-openssl-and-gmssl-on-win32/","summary":"由于参与了一个在 PLC 和上位机之间建立加密信道的项目，需要在PLC的Win7-32bit系统中安装OpenSSL和GmSSL，因为PLC硬盘太小，所以我实际上是在虚拟机里面进行的编译。\nOpenSSL 一开始是打算编译一下的，下载了OpenSSL的源码，OpenSSL的Configure是依赖Perl的。然后下载安装了Strawberry Perl for win32，然后发现会出现各种报错，一番搜索了解到需要安装ActivePerl：\nInstall ActivePerl and remove Stawberry Perl as it is not compatible with openssl.\n但是ActivePerl的官网只提供64bit的版本，安装32bit版本的ActivePerl需要支付$912/yr：\nThe site states: \u0026ldquo;if you need 32-bit or other older/legacy versions, they are available through our new ActiveState Platform by subscribing to at least Team Tier. See pricing here.\u0026rdquo;\n这就很难搞，只能去下载安装现成的二进制文件：http://slproweb.com/products/Win32OpenSSL.html\nGmSSL GmSSL官方的编译与安装教程虽然字数不多但是很有帮助，编译过程比较顺利。\n虽然也提及要用ActivePerl，但是我在对Configure进行了一点简单修改之后，用Strawberry Perl也可以成功运行perl Configure VC-WIN32。\n直接运行perl Configure VC-WIN32会遇到报错：\u0026quot;glob\u0026quot; is not exported by the File::Glob module。\n分别在Configure和test/build.info两个文件中，把：\nuse if $^O ne \u0026quot;VMS\u0026quot;, 'File::Glob' =\u0026gt; qw/glob/; 修改为：","title":"Install OpenSSL and GmSSL on Win32"},{"content":"树莓派是个一直听说，但是一直没玩过的东西，所以在今年年初搞了一块折腾了一段时间。在上面起了一些服务，确实很好玩。在上面搭建了私有网盘、Minecraft、SageMath 还有几个密码学题目。这篇博客记录了我折腾树莓派的经历～\n解决公网IP问题 我想在公网连接到家里的树莓派，访问到上面的服务，所以需要有公网IP或者使用 frp 内网穿透。当然如果不需要让树莓派暴露在公网下，就不需要搞公网 IP 了。\n静态公网IP 如果有角度可以搞到企业专线，那还是很香的，不仅拥有运营商分配的静态公网 IP，还有上下行相等的大带宽，当然费用也很高，也需要注册的企业资质。所以我是搞不到静态的公网 IP。\n动态公网IP 没有静态的，可以退而求其次搞动态的，跟运营商交涉一下是可以得到动态的公网 IP 的，虽然是上下行不对等的家庭带宽，但是作为服务器来说绰绰有余，已经远超很多便宜的云服务器了。\n第一次我直接跟人工客服打电话申请要一个静态公网IP被拒绝了；然后第二天我又一次联系了人工客服，询问能不能申请动态的公网IP（可以说装摄像头要用到，不能说在家里搭建服务器），结果很快就回电通知我已经给了动态的公网IP，还算顺利～\nDynamic DNS 后面使用发现，我们这边的动态的公网IP大约2～3天变动一次，这就可以通过 Dynamic DNS（DDNS） 将动态的IP解析到固定的域名，就能通过固定的域名访问到服务器了。\nDDNS需要服务端和本地各运行一个服务：本地的树莓派或路由器上运行一个服务，每隔一段时间（几分钟）就获取一下自己的公网IP，判断一下有没有发生改变，如果发生改变就将新的 IP 发送给服务端，服务端得到新的 IP，就重新将域名解析到新的IP，所以是动态DNS。\nDDNS的服务端只提供域名的动态解析服务，所以服务端的带宽对访问树莓派的速度没有影响（但是可能会影响到延时？实际使用没有明显感觉到）\nDDNS服务：\n直接使用一些网站（oray.com/3322.org/Dyndns.com/No-ip.com）免费提供的DDNS服务，但是他们给的域名都是比较杂乱的三级域名，需要再把自己租的阿里云/腾讯云域名CNAME解析到这个三级域名。花生壳（oray.com）可以免费使用；而No-ip.com免费版需要每30天登录上去手动续约。 使用自己的vps运行脚本为树莓派提供DDNS服务，由于需要通过脚本进行域名解析，所以需要在vps上安装对应的SDK，然后开发对应的脚本，可以直接将自己的阿里云/腾讯云域名解析到家里的公网IP。 我现在是选择使用花生壳（oray.com）的DDNS服务，只需要注册即可得到一个三级域名，通过控制台-\u0026gt;域名-\u0026gt;壳域名来查看。我的路由器是小米 4A，可以在后台设置DDNS，选择“花生壳”并输入账号密码域名和检查 IP 的时间间隔即可。路由器不支持的话就需要在树莓派上运行一个脚本来发送新的IP。\n也有很多树莓派玩家通过每次变动IP时，让树莓派将新IP发送给自己的邮箱，使自己总是可以知道最新的IP地址。\nfrp内网穿透 如果也申请不到动态 IP，那就只能用 frp 做内网穿透了，需要借助一台有公网 IP 的 vps，流量也都需要经过这台 vps，所以享受不到家庭宽带的低价大带宽了。\n测试上下行带宽 可以在 speedtest.cn 测试下行带宽和上行带宽（最好直接连网线测）。\n从公网访问树莓派下载文件需要的是家里的上行带宽，而家庭宽带的上行都是很低的，只能去升级下行带宽，上行才能对应的提升一点。。。。所以如果感觉带宽不太够还是要去升级一下宽带的。\n我家的联通宽带就不太行，一开始是100M下行，20M上行，实测大约下行90~100M，上行20~40M。于是换了500M下行，50M上行的宽带，实测大约下行450～550M，上行60～70M。\n组装树莓派和安装Ubuntu 我的是树莓派 4B。启动树莓派还需要有 5V 3A 的电源和一张 TF 卡。\n各版本树莓派的对照表：https://shumeipai.nxez.com/wp-content/uploads/2017/03/raspberrypi-version-compare-4b.png\n然后就是愉快的组装环节，树莓派 PCB 边缘是有毛糙的，最好用砂纸磨光滑再装到壳子里。 写入Ubuntu镜像 树莓派支持安装很多种系统，我选择的是 Ubuntu Server 20.04.2 LTS 64-bit，可以在这里下载：https://ubuntu.com/download/raspberry-pi，先把镜像下载到本地，把 TF 卡插到读卡器里，再把读卡器插在这台电脑上。\n电脑上需要安装 balenaEtcher 来为 TF 卡写入 Ubuntu 镜像，balenaEtcher 支持 MacOS/Windows/Linux，可以在官网下载：https://www.balena.io/etcher/\n写入镜像过程很简单，跟着点就可以，下图这样就是写入成功了。 写入完成后不需要手动推出磁盘（TF 卡读卡器），可以直接拔掉，然后将 TF 卡插入树莓派即可。\n树莓派的 Wi-Fi 网卡性能较弱，而搭 NAS 比较需要速度，所以我直接给树莓派插上了网线。这时就可以直接通电了，树莓派会自动开机。\n内网SSH连接树莓派 现在就可以用电脑连接 Wi-Fi 并进入无线路由器的后台，应该可以看到连接路由器的所有设备的内网 IP 地址和MAC 地址，等待几分钟可以看到一个设备的名称是ubuntu，接入方式是网线连接，那么这个就是树莓派了。可以通过 ssh ubuntu@内网IP来连接树莓派，默认密码是ubuntu。\n公网SSH连接树莓派 接着可以设置一下路由器，为了防止树莓派的内网IP发生改变，需要在路由器后台，高级设置-\u0026gt;DHCP静态IP分配 把树莓派的MAC地址和当前的内网IP地址绑定起来。然后为了让公网对路由器的访问都转向树莓派，高级设置-\u0026gt;端口转发-\u0026gt;开启DMZ，把DMZ这边的IP地址设置为树莓派的内网IP地址。这样设置完成之后，就可以通过 ssh ubuntu@公网IP 来远程控制树莓派了，公网IP地址可以通过访问 http://testipv6.com/来查看。\n较为遗憾的是运营商一般会屏蔽掉80端口和443端口。。。所以如果在树莓派上起服务，只能通过端口访问，这个问题可以通过在一台有公网IP并且开着80端口的vps上配置Nginx反向代理来解决，不过这样的话流量还是要走vps，所以为了快速的下载上传文件，只能通过加着端口这种方法来访问了，不过好在最终速度理想。\n初始配置 在同一文件夹下备份默认的源：\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 编辑 /etc/apt/sources.list 并替换成下面的内容：（sudo vim /etc/apt/sources.list）\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse 然后更新：\nsudo apt update sudo apt upgrade 安装KodExplorer 私有云有很多种选择：seafile、nextcloud、KodExplorer 等，我使用的是 KodExplorer（可道云），比较美观并且可以创建低权限用户支持预览的格式也很多。\nKodExplorer 官网链接：https://kodcloud.com/，官网的文档很详细。\n为树莓派安装好 lamp 环境，然后将 KodExplorer 的文件夹放到 web 目录下即可，开放好对应的端口之后，我们就可以通过http://[域名]/[目录名]来访问到 KodExplorer 了。\n不过要注意的是，服务要开在其他开放了的端口（80，443 会被运营商屏蔽）。\n优化上传和下载的速度，可以按照这个方法操作一下：https://teddysun.com/489.html，速度提升非常明显。\n挂载硬盘 安装好 KodExplorer 之后，就可以上传下载文件了，不过是存到 TF 卡里的，作为 NAS 当然需要给树莓派外挂硬盘，树莓派上有两个 USB 3.0 接口和两个 USB 2.0 接口，可以在这里挂上移动硬盘或者是硬盘加硬盘盒。\n我使用的方法是给树莓派的 USB 3.0 接口插了一个硬盘盒，可以自己选择需要大小的硬盘放在硬盘盒里，缺点是硬盘需要 12v 的供电，而树莓派的 USB 3.0 仅有 5v，所以需要给硬盘盒外接一个 12v 电源，不是很优雅，但硬盘的容量选择很多。\n首先为了让树莓派支持ExFat和NTFS格式的硬盘，需要安装下面两个依赖：\nsudo apt-get install exfat-fuse sudo apt-get install ntfs-3g 然后就可以挂载硬盘了，插上硬盘之后可以 sudo fdisk -l 来查看到自己的硬盘，然后 df -h 查看已经挂载的磁盘，这时这里是没有自己的硬盘的。\nsudo mkdir /www/wwwroot/[站点名称]/nas sudo mount /dev/sda1 /www/wwwroot/[站点名称]/nas [站点名称]换成自己的站点名称。\n就可以通过 df -h 查看到已经挂载到这个目录的硬盘了，加载内核模块modprobe fuse，然后设置开机自动挂载，先 sudo vim /etc/fstab，然后在底部添加这一行：\n/dev/sda1 /www/wwwroot/[站点名称]/nas ntfs-3g defaults,nofail,noexec,umask=0000 0 0 安装SageMath 只需要一行命令，就可以在树莓派上安装好 SageMath 了，也可以很方便的为 SageMath 里的 Python 环境安装第三方包。\nsudo apt-get install sagemath --fix-missing sage -python3 -m pip install pycryptodome 用 sage exp.sage 来直接运行 sage 脚本。\n散热风扇改造 店家送的风扇只能直接连接树莓派的供电引脚，然后满转运行，我觉得这样很不优雅，至少应该像机箱的风扇一样，可以随着当前CPU温度改变转速，温度不太高的时候完全可以停下，可以尽可能的减小噪声，所以我开始动手改装了树莓派的风扇。\n在寻找合适的树莓派风扇的过程中，偶然发现一种很强劲的小风扇：悬浮轴承、18128RPM、5V、直径 3CM，这也太适合树莓派了，就选择它了。\n然后是写脚本来控制转速，要利用到树莓派可玩性最高的东西——GPIO，可以用 Python 写脚本，并且 GPIO 支持 PWM 输出，通过调节占空比来调节转速。\nimport RPi.GPIO as GPIO import os import time # Configuration PWM_BOARD_IN1 = 8 # BOARD pin used to drive PWM fan PWM_BOARD_IN2 = 10 # BOARD pin (keep it LOW except want the fan to reverse) WAIT_TIME = 1 # [s] Time to wait between each refresh PWM_FREQ = 25000 # [Hz] 25kHz for PWM control MIN_TEMP = 35 MAX_TEMP = 65 FAN_LOW = 5 FAN_HIGH = 100 TEMP_COEFFICIENT = float(FAN_HIGH - FAN_LOW)/float(MAX_TEMP - MIN_TEMP) def setFanSpeed(speed): fan.start(speed) def getCpuTemperature(): res = os.popen('cat /sys/class/thermal/thermal_zone0/temp').readline() return float(res)/1000 def handleFanSpeed(temperature): fanSpeed = round(FAN_LOW + (round(max(0, temperature-MIN_TEMP)) * TEMP_COEFFICIENT), 3) setFanSpeed(fanSpeed) with open(\u0026quot;fan_speed\u0026quot;, \u0026quot;w\u0026quot;) as f: f.write(str(fanSpeed)) try: GPIO.setwarnings(False) GPIO.setmode(GPIO.BOARD) out_list = [PWM_BOARD_IN1, PWM_BOARD_IN2] GPIO.setup(out_list, GPIO.OUT) GPIO.output(out_list, GPIO.LOW) fan = GPIO.PWM(out_list[0], PWM_FREQ) while True: handleFanSpeed(getCpuTemperature()) time.sleep(WAIT_TIME) except KeyboardInterrupt: setFanSpeed(50) 为了方便实时监控到树派的转速，脚本会一直吧速度写进fan_speed文件里，供另外一个程序获取。\n开发树莓派资源监控页面 资源监控这边希望可以看到树莓派的公网 IP、CPU 温度、CPU 的资源占用情况，ROM/RAM 的资源占用情况，风扇的转速。\n风扇的转速写在了文件里，并且实时更新，所以这边去获取一下即可。\n. ├── assets │ ├── css ├── images │ ├── js │ └── vendors ├── fan_control │ ├── fan_control.py │ └── fan_speed ├── pi_dashboard.py └── templates ├── assets │ ├── css │ ├── images │ ├── js │ └── vendors └── index.html 后端使用flask，前端用的是mazer组件库。\nfrom flask import Flask, render_template import os import re import requests app = Flask(__name__,template_folder='templates',static_folder=\u0026quot;assets\u0026quot;) def get_cpu_temperature(): try: res = os.popen('cat /sys/class/thermal/thermal_zone0/temp').readline() temp = float(res)/1000 return temp except: return \u0026quot;Error\u0026quot; def get_cpu_info(): try: res = os.popen(\u0026quot;top -bn1 1 | grep Cpu\u0026quot;).read() us = [float(i[:-3].strip(\u0026quot; \u0026quot;)) for i in re.findall(r\u0026quot;[0-9. ]*us\u0026quot;, res)] sy = [float(i[:-3].strip(\u0026quot; \u0026quot;)) for i in re.findall(r\u0026quot;[0-9. ]*sy\u0026quot;, res)] cpu_used = [round(x[0]+x[1], 1) for x in zip(us, sy)] assert len(cpu_used)==4 return cpu_used except: return [\u0026quot;Error\u0026quot; for _ in range(4)] def get_rom_info(Filesystem): '''return list: [Size, Used, Avail, Use%]''' try: res = os.popen(\u0026quot;df -h\u0026quot;).read() card_data = re.findall(Filesystem+\u0026quot;[0-9. KMG%]*\u0026quot;, res)[0].split()[1:] card_data = [i[:-1] if (i[-1]==\u0026quot;G\u0026quot; or i[-1]==\u0026quot;%\u0026quot;) else i for i in card_data] assert len(card_data)==4 return card_data except: return [\u0026quot;Error\u0026quot; for _ in range(4)] def get_public_ip(): try: res = requests.get(\u0026quot;http://members.3322.org/dyndns/getip\u0026quot;) return res.text.strip() except: return \u0026quot;Error\u0026quot; def get_intranet_ip(): try: res = os.popen(\u0026quot;hostname -i\u0026quot;).read().split(\u0026quot; \u0026quot;)[0] return res except: return \u0026quot;Error\u0026quot; def get_ram_info(): try: res = os.popen('free').read() ram_info = re.findall(\u0026quot;Mem:[0-9 ]*\u0026quot;, res)[0].split()[1:3] return [str(int(i)//1024) for i in ram_info] except: return [\u0026quot;Error\u0026quot; for _ in range(2)] def get_fan_speed(): try: with open(\u0026quot;fan_control/fan_speed\u0026quot;, \u0026quot;r\u0026quot;) as f: fan_speed = f.read() return fan_speed except: return \u0026quot;Error\u0026quot; @app.route('/') def dashboard_page(): context = { \u0026quot;cpu_used\u0026quot;:get_cpu_info(), \u0026quot;cpu_temp\u0026quot;:get_cpu_temperature(), \u0026quot;fan_speed\u0026quot;:get_fan_speed(), \u0026quot;ip_adress\u0026quot;:{\u0026quot;intranet\u0026quot;:get_intranet_ip(),\u0026quot;public\u0026quot;:get_public_ip()}, \u0026quot;ram\u0026quot;:get_ram_info(), \u0026quot;rom\u0026quot;:get_rom_info(\u0026quot;/dev/mmcblk0p2\u0026quot;), \u0026quot;external_storage\u0026quot;:get_rom_info(\u0026quot;/dev/sda1\u0026quot;) } return render_template('index.html', **context) if __name__ == '__main__': app.run(\u0026quot;0.0.0.0\u0026quot;, 82) # nohup gunicorn -w 4 -b 0.0.0.0:82 pi_dashboard:app \u0026amp; 感觉对我来说，树莓派是个比较有意思的玩具，折腾了一段时间学到了一些杂七杂八的东西，算是填补了一直以来对树莓派的好奇心。\n用树莓派跑了一些脚本，虽然可以 24h 稳定运行，但是性能差点意思，还有一些服务由于各种原因导致在树莓派上兼容不是很好。\n为了更强的性能、更稳定的运行一些服务，我后面又装了一台裸金属服务器～然后把树莓派挂咸鱼出掉了，由于树莓派在涨价，运行了半年的树莓派竟然没赔，理财产品了属于是。\n","permalink":"https://slightwind.cn/posts/environment/raspberrypi4b/","summary":"树莓派是个一直听说，但是一直没玩过的东西，所以在今年年初搞了一块折腾了一段时间。在上面起了一些服务，确实很好玩。在上面搭建了私有网盘、Minecraft、SageMath 还有几个密码学题目。这篇博客记录了我折腾树莓派的经历～\n解决公网IP问题 我想在公网连接到家里的树莓派，访问到上面的服务，所以需要有公网IP或者使用 frp 内网穿透。当然如果不需要让树莓派暴露在公网下，就不需要搞公网 IP 了。\n静态公网IP 如果有角度可以搞到企业专线，那还是很香的，不仅拥有运营商分配的静态公网 IP，还有上下行相等的大带宽，当然费用也很高，也需要注册的企业资质。所以我是搞不到静态的公网 IP。\n动态公网IP 没有静态的，可以退而求其次搞动态的，跟运营商交涉一下是可以得到动态的公网 IP 的，虽然是上下行不对等的家庭带宽，但是作为服务器来说绰绰有余，已经远超很多便宜的云服务器了。\n第一次我直接跟人工客服打电话申请要一个静态公网IP被拒绝了；然后第二天我又一次联系了人工客服，询问能不能申请动态的公网IP（可以说装摄像头要用到，不能说在家里搭建服务器），结果很快就回电通知我已经给了动态的公网IP，还算顺利～\nDynamic DNS 后面使用发现，我们这边的动态的公网IP大约2～3天变动一次，这就可以通过 Dynamic DNS（DDNS） 将动态的IP解析到固定的域名，就能通过固定的域名访问到服务器了。\nDDNS需要服务端和本地各运行一个服务：本地的树莓派或路由器上运行一个服务，每隔一段时间（几分钟）就获取一下自己的公网IP，判断一下有没有发生改变，如果发生改变就将新的 IP 发送给服务端，服务端得到新的 IP，就重新将域名解析到新的IP，所以是动态DNS。\nDDNS的服务端只提供域名的动态解析服务，所以服务端的带宽对访问树莓派的速度没有影响（但是可能会影响到延时？实际使用没有明显感觉到）\nDDNS服务：\n直接使用一些网站（oray.com/3322.org/Dyndns.com/No-ip.com）免费提供的DDNS服务，但是他们给的域名都是比较杂乱的三级域名，需要再把自己租的阿里云/腾讯云域名CNAME解析到这个三级域名。花生壳（oray.com）可以免费使用；而No-ip.com免费版需要每30天登录上去手动续约。 使用自己的vps运行脚本为树莓派提供DDNS服务，由于需要通过脚本进行域名解析，所以需要在vps上安装对应的SDK，然后开发对应的脚本，可以直接将自己的阿里云/腾讯云域名解析到家里的公网IP。 我现在是选择使用花生壳（oray.com）的DDNS服务，只需要注册即可得到一个三级域名，通过控制台-\u0026gt;域名-\u0026gt;壳域名来查看。我的路由器是小米 4A，可以在后台设置DDNS，选择“花生壳”并输入账号密码域名和检查 IP 的时间间隔即可。路由器不支持的话就需要在树莓派上运行一个脚本来发送新的IP。\n也有很多树莓派玩家通过每次变动IP时，让树莓派将新IP发送给自己的邮箱，使自己总是可以知道最新的IP地址。\nfrp内网穿透 如果也申请不到动态 IP，那就只能用 frp 做内网穿透了，需要借助一台有公网 IP 的 vps，流量也都需要经过这台 vps，所以享受不到家庭宽带的低价大带宽了。\n测试上下行带宽 可以在 speedtest.cn 测试下行带宽和上行带宽（最好直接连网线测）。\n从公网访问树莓派下载文件需要的是家里的上行带宽，而家庭宽带的上行都是很低的，只能去升级下行带宽，上行才能对应的提升一点。。。。所以如果感觉带宽不太够还是要去升级一下宽带的。\n我家的联通宽带就不太行，一开始是100M下行，20M上行，实测大约下行90~100M，上行20~40M。于是换了500M下行，50M上行的宽带，实测大约下行450～550M，上行60～70M。\n组装树莓派和安装Ubuntu 我的是树莓派 4B。启动树莓派还需要有 5V 3A 的电源和一张 TF 卡。\n各版本树莓派的对照表：https://shumeipai.nxez.com/wp-content/uploads/2017/03/raspberrypi-version-compare-4b.png\n然后就是愉快的组装环节，树莓派 PCB 边缘是有毛糙的，最好用砂纸磨光滑再装到壳子里。 写入Ubuntu镜像 树莓派支持安装很多种系统，我选择的是 Ubuntu Server 20.04.2 LTS 64-bit，可以在这里下载：https://ubuntu.com/download/raspberry-pi，先把镜像下载到本地，把 TF 卡插到读卡器里，再把读卡器插在这台电脑上。","title":"使用树莓派4B作为一台服务器"},{"content":"hxb 2021 crypto signin $n1/n2$ 的连分数展开是对 $q1/q2$ 的一个逼近，所以枚举连分数中的每一项，就可以得到 $q1, q2$ 了，分解之后正常进行 RSA 解密得到 flag。\nfrom Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime pk = (1150398070565459492080597718626032792435556703413923483458704675295997646493249759818468321328556510074044954676615760446708253531839417036997811506222349194302791943489195718713797322878586379546657275419261647635859989280700191441312691274285176619391539387875252135478424580680264554294179123254566796890998243909286508189826458854346825493157697201495100628216832191035903848391447704849808577310612723700318670466035077202673373956324725108350230357879374234418393233, 1242678737076048096780023147702514112272319497423818488193557934695583793070332178723043194823444815153743889740338870676093799728875725651036060313223096288606947708155579060628807516053981975820338028456770109640111153719903207363617099371353910243497871090334898522942934052035102902892149792570965804205461900841595290667647854346905445201396273291648968142608158533514391348407631818144116768794595226974831093526512117505486679153727123796834305088741279455621586989) c1, c2 = (361624030197288323178211941746074961985876772079713896964822566468795093475887773853629454653096485450671233584616088768705417987527877166166213574572987732852155320225332020636386698169212072312758052524652761304795529199864805108000796457423822443871436659548626629448170698048984709740274043050729249408577243328282313593461300703078854044587993248807613713896590402657788194264718603549894361488507629356532718775278399264279359256975688280723740017979438505001819438, 33322989148902718763644384246610630825314206644879155585369541624158380990667828419255828083639294898100922608833810585530801931417726134558845725168047585271855248605561256531342703212030641555260907310067120102069499927711242804407691706542428236208695153618955781372741765233319988193384708525251620506966304554054884590718068210659709406626033891748214407992041364462525367373648910810036622684929049996166651416565651803952838857960054689875755131784246099270581394) n1, n2 = pk e = 0x10001 def getRoot(x, n): high = 1 while high ** n \u0026lt;= x: high *= 2 low = high // 2 while low \u0026lt; high: mid = (low + high) // 2 if low \u0026lt; mid and mid**n \u0026lt; x: low = mid elif high \u0026gt; mid and mid**n \u0026gt; x: high = mid else: return mid return mid + 1 # https://github.com/pablocelayes/rsa-wiener-attack def rational_to_contfrac(x, y): a = x // y pquotients = [a] while a * y != x: x, y = y, x - a*y a = x // y pquotients.append(a) return pquotients def convergents_from_contfrac(frac): convs = [] for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0:i])) return convs def contfrac_to_rational(frac): if len(frac) == 0: return (0, 1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num return (num, denom) frac = rational_to_contfrac(n1, n2) convergents = convergents_from_contfrac(frac) p1, p2 = None, None for (P1, P2) in convergents: gcd1, gcd2 = GCD(P1, n1), GCD(P2, n2) p1 = gcd1 if (gcd1.bit_length() \u0026lt;= 128 and isPrime(gcd1)) else p1 p2 = gcd2 if (gcd2.bit_length() \u0026lt;= 128 and isPrime(gcd2)) else p2 print(f\u0026quot;[+]p1: {p1}\u0026quot;) print(f\u0026quot;[+]p2: {p2}\u0026quot;) q1, q2 = getRoot(n1 // p1, 4), getRoot(n2 // p2, 4) phi1 = (p1 - 1) * (q1 - 1) * q1**3 phi2 = (p2 - 1) * (q2 - 1) * q2**3 m1 = pow(c1, inverse(e, phi1), n1) m2 = pow(c2, inverse(e, phi2), n2) flag = (long_to_bytes(m1) + long_to_bytes(m2)).decode() print(f\u0026quot;[~]flag: {flag}\u0026quot;) ''' [+]p1: 181856133933383097933223133658050179553 [+]p2: 196443958511498599913330690975430421229 [~]flag: flag{8ef333ac-21a7-11ec-80f1-00155d83f114} ''' fastOT Python 的random的内部是MT19937 伪随机数生成器，虽然生成的随机数周期很大，但是内部状态（state）很少，仅仅有 624 个，每个值都是 32bit 的。\n这题给了足够的交互次数，题目中选项 1 里生成的m列表刚好是 8 个 32bit 的随机数，所以如果每次都能得到m列表，那么只需要交互 $624/8=78$ 次就可以得到全部的内部状态了，然后就能回推前面的随机数了。primate_key就是在前面生成的随机数。\n为了得到m，需要对发送的内容构造一下，我们期望返回的结果也就是解密的结果对我们来说是已知的，服务端会对我们的消息分别用 $d_1, d_2$ 进行解密，所以发送的消息可以是 $c = m^{e_1\\cdot e_2} \\bmod n$，$m$ 可以是任意的已知明文，这样 $d_1$ 解密后的是 $c_2 = m^{e_2} \\bmod n$，$d_2$ 解密后的是 $c_1 = m^{e_1} \\bmod n$，$c_2, c_1$ 都是已知的，那么只需要异或一下就能得到m列表了。\n有了所有的内部状态，也同样可以预测后面的值，每次的cur_rand都可以预测出来了，那么就可以解密得到flag。\nfrom hashlib import sha256 from Crypto.Util.number import * from Crypto.Cipher import AES from tqdm import tqdm from pwn import * r = remote(\u0026quot;127.0.0.1\u0026quot;, \u0026quot;9999\u0026quot;) e1, e2 = 65537, 92431 msg = 1175078221 def unshift(value, key, mask=None, nbits=32, direction=\u0026quot;right\u0026quot;): maxn = (1 \u0026lt;\u0026lt; nbits) - 1 if not mask: mask = (1 \u0026lt;\u0026lt; (nbits + 1)) - 1 i = 0 if direction == 'right': while i * key \u0026lt; nbits: part_mask = ((maxn \u0026lt;\u0026lt; (nbits - key)) \u0026amp; maxn) \u0026gt;\u0026gt; (i * key) value ^= ((value \u0026amp; part_mask) \u0026gt;\u0026gt; key) \u0026amp; mask i += 1 return value elif direction == 'left': while i * key \u0026lt; nbits: part_mask = ((maxn \u0026gt;\u0026gt; (nbits - key)) \u0026amp; maxn) \u0026lt;\u0026lt; (i * key) value ^= ((value \u0026amp; part_mask) \u0026lt;\u0026lt; key) \u0026amp; mask i += 1 return value else: raise ValueError(\u0026quot;Invalid direction: %s, direction must be 'left' or 'right'.\u0026quot; % direction) def getState(number): number = unshift(number, 18, direction=\u0026quot;right\u0026quot;) number = unshift(number, 15, mask=0xefc60000, direction=\u0026quot;left\u0026quot;) number = unshift(number, 7, mask=0x9d2c5680, direction=\u0026quot;left\u0026quot;) number = unshift(number, 11, direction=\u0026quot;right\u0026quot;) return number def backtrace(numbers): assert(len(numbers) == 624) state = [] for number in numbers: state.append(getState(number)) return state def getOldStates(states): for i in range(3, -1, -1): tmp = states[i + 624] ^ states[i + 397] if tmp \u0026amp; 0x80000000 == 0x80000000: tmp ^= 0x9908b0df res = (tmp \u0026amp; 0x40000000) \u0026lt;\u0026lt; 1 tmp = states[i - 1 + 624] ^ states[i + 396] if tmp \u0026amp; 0x80000000 == 0x80000000: tmp ^= 0x9908b0df res |= 1 res |= (tmp \u0026amp; 0x3fffffff) \u0026lt;\u0026lt; 1 states[i] = res def add(x, y): assert y.bit_length() \u0026gt;= 128 return (x + y) ^ (x \u0026gt;\u0026gt; 53) def get_m(message): m0_list, m1_list = [], [] m0, m1 = int(message[0]) ^ pow(msg, e2, n), int(message[1]) ^ pow(msg, e1, n) for _ in range(4): m0_list.append(m0 \u0026amp; ((1 \u0026lt;\u0026lt; 32) - 1)) m0 \u0026gt;\u0026gt;= 32 m1_list.append(m1 \u0026amp; ((1 \u0026lt;\u0026lt; 32) - 1)) m1 \u0026gt;\u0026gt;= 32 m0_list.reverse() m1_list.reverse() return m0_list + m1_list def choice_1(): r.sendlineafter(b'choice\u0026gt;', b'1') r.sendlineafter(b\u0026quot;\\n\u0026quot;, hex(pow(msg, e1 * e2, n))[2:].encode()) r.recvuntil(b\u0026quot;Your message is (\u0026quot;) message = r.recvline().decode().strip()[:-2].split(\u0026quot;L, \u0026quot;) return get_m(message) def choice_2(): r.sendlineafter(b'choice\u0026gt;', b'2') r.sendlineafter(b\u0026quot;\\n\u0026quot;, hex(pow(msg, e1, n))[2:].encode()) r.recvuntil(b\u0026quot;Your cipher is: \u0026quot;) return r.recvline().decode().strip() def get_datalist(): datalist = [] for _ in tqdm(range(78)): datalist += choice_1() assert len(datalist) == 624 return datalist r.recvuntil(b\u0026quot;Your pubkey is: \u0026quot;) n = int(r.recvline().decode().strip().replace('L', '')[2:], 16) print(f\u0026quot;[+] n: {n}\u0026quot;) datalist = get_datalist() states = [0] * 4 + backtrace(datalist) getOldStates(states) random.setstate(tuple([3, tuple(states[:624] + [0]), None])) primate_key = random.getrandbits(128) print(f\u0026quot;[+] primate_key: {primate_key}\u0026quot;) for _ in range(624): random.getrandbits(32) c = choice_2() print(f\u0026quot;[+] cipher is: {c}\u0026quot;) t = (pow(pow(msg, e1, n), e1, n), pow(pow(msg, e1, n), e2, n)) cur_rand = random.getrandbits(128) cur_k = t[cur_rand \u0026amp; 1] ^ cur_rand key = sha256(long_to_bytes(add(primate_key, cur_k))).digest()[:16] aes = AES.new(key, AES.MODE_ECB) flag = aes.decrypt(bytes.fromhex(c)).decode() r.close() print(f\u0026quot;[~] flag: {flag}\u0026quot;) hxb 2020 crypto 古典美++ 在 https://www.guballa.de/vigenere-solver 上解密，得到 key 是orderby。\nfrom hashlib import md5 print(md5(b\u0026quot;ORDERBY\u0026quot;).hexdigest()) 得到flag：c82bbc1ac4ab644c0aa81980ed2eb25b\n简单的密码3 only admin can get flag Menu: 1) login 2) edit 3) flag 交互一下可以发现能修改iv，并且发送的用户名会和name:一起拼起来并加密，结合only admin can get flag可以猜测，如果解密后是name:admin就可以得到 flag 了，直接登陆 admin 也是不行的，只能通过修改iv来改变解密结果。\n这里只需要观察解密过程最左侧的一块即可，密文经过key的解密后，异或iv，得到明文。\n如果我们设置的用户名为1234567890，我们可以用name:1234567890异或当前的iv，得到key解密后的中间量，然后异或我们期望的明文name:admin即可。\nnewiv = iv ^ \u0026quot;name:1234567890\u0026quot; ^ \u0026quot;name:admin\u0026quot; from Crypto.Util.number import * iv = \u0026quot;\u0026quot; iv = bytes.fromhex(iv) def xor(x, y): return b''.join([long_to_bytes(x[i] ^ y[i]) for i in range(len(x))]) def pad(x): return x + long_to_bytes(16 - len(x)) * (16 - len(x)) payload = pad(b\u0026quot;name:admin\u0026quot;) plaintext = pad(b\u0026quot;name:1234567890\u0026quot;) # newiv = iv ^ plaintext ^ payload print(xor(xor(iv, plaintext), payload).hex()) LFSXOR 明文是由长度为512字节的随机字符串和flag拼接起来的。加密脚本使用两个不同的 LSFR，分别生成了k4、k5两个密钥，并将用它们分别加密这同一段明文。\n枚举全部的 k4 和 k5 的组合 pylfsr是一个可以自定义反馈函数的 lfsr 伪随机数生成器，L4和L5分别是定义在 $f = x^4 + x^3 + 1$ 和 $f = x^5 + x^4 + x^2 + x +1$ 上的 LFSR，初始状态都是随机的，周期分别为 15 和 31（因为全为 0 的状态不允许出现，所以是 $2^k-1$），初始状态也是 15 或 31 个中的其中一个。\n由于它们周期都很小，初始状态也完全可以枚举，$15\\cdot 31$ 种情况很容易爆破，对于每一组确定的初始状态，可以开始用它来生成 $k_4,k_5$，一共只有 $15\\cdot 31$ 组 $k_4,k_5$，但是问题在于加密之前又将 $k_4, k_5$ 乱序了，所以接下来要想办法恢复 $k_4,k_5$ 正确的顺序。\n获取乱序后的 k4 和 k5 可以利用前面提到的，乱序后的 $k_4,k_5$ 最终被用来加密同一段明文了，进行的是异或操作，所以对于一个字节的密文：\n$$c_{1i} = k_{4i} \\oplus m_i \\ c_{2i} = k_{5i} \\oplus m_i$$\n所以可以利用 $c_{1i} \\oplus k_{4i} = c_{2i} \\oplus k_{5i} = m_i$ 来缩小当前位置是正确字节的可能，因为对于 $k_4$ 中的随机一个字节 $k_{4i}$ 和 $k_5j$ 中的随机一个字节 $k_{5k}$，刚好能异或对应位置 $c_{1i}, c_{2i}$ 得到相同结果的可能性并不高，在这个很小的范围中依次取一组信任，继续往下递归，直到这组 $k_4, k_5$ 一直可以满足条件，那么就用它们来解密。\nfrom Crypto.Util.number import * from pylfsr import LFSR enc1 = b'\\xbb\\xd3\\x08\\x15\\xc6:\\x08\\xb2\\xb2\\x9f\\xe4p\\xc7\\xec\\x7f\\xfd)\\xf6f\\x9c\\xe4\\xd12\\xaeJ\\x81\\xb1\\x88\\xab\\xa5V\\xa9\\x88\\x14\\xdf`~\\xf6\\xdbJ\\xb4\\x06S!0\\xbb\\xe4\\x1a\\xe6R\\x8e\\x84X\\x19K\\x95\\x07C\\xe8\\xb2\\'\\xa9\\x80\\x15\\xec\\x8f\\x8dY\\nK\\x85\\x99\\xb7!\\x134\\xa9\\xb6\\x15\\xcf\u0026amp;\\r\\x9b\\xe1\\x99\\xe4]3h~\\xf0\\xa9\\xa5\\x14\\xee}\\xd19l\\x14h\\x07v *a0\\x12\\x14\\xfe\\x0f\\x05\\xdem\\x1d\\xe4s2J\\x7f\\xc28\\xf6RR\\x8e\\xba\\xb2m\\x18M\\xf1\\xef!4\\x17\\xa8\\xb4\\x14\\xc2\\x8f\\xb9Y:K\\xaa\\x06T!\\x1b\\xbb\\xfd\\xf6Gv\\x8e\\x9a\\xeb\\xd9K\\xbb\\x06N\\x9a\\x82c\\xa9\\xa0\\x14\\xed!\\x04\\xdbm\\x13\\xe5w3B\\x7f\\xd0\\xa9\\xbf\\xb7\\x9c\\xe3\\xd00\\x83K\\x86\\xab3\\x7f\\xc1\\xbb\\xfd\\x11\\x15\\xdf\\x8e\\x80Y\\x07\\xd8\\xe5]2m\\xe9\\xbb\\xce`\\x91o\\x8f\\x8cY!\\x81\\xe4J\\x92\\x8c\\xa7T\\x16E\\x15\\xf1WMY(\\xb8[\\x8e2y~\\xcbM\\x10\\x15\\xc7\\x1fWY\\x0cK\\x87\\xce\\xe5 !b\\xa8\\x83\\x14\\xec6\\xd1!\\xc8\\x905\\xe52L\\xf1\\xba\\xcf\\n\\x9d\\x9d\\xe7u\\xadm\\x06\\xe4n2r\\xd8\\xba\\xed\\xf6\\x7f\\x9d\\xd8\\xd02m\\x12G\\x07Y\\x89\\x7f\\xc0\\xa8\\xa4\\x15\\xe5\\x043Y\\x1eJ\\xae\\x07n\\x94\\x87\\xbb\\xcf_\\x8d\\x9d\\xd1\\x14Y,\\x9e\\xe5b\\xd7\\x8c\\x7f\\xf7\\xa8\\x8f\\x14\\xc7\\x8f\\xb3\\xb6\\xf1\\x93\\xe4O\\xdd\\xc4\\xdb\\xba\\xf6!\\x15\\xfd.\\xd1\\x18\\xcf\\xf6\\x03\\xea2E\\x7f\\xe1\\xa9\\xa5\\xfe\\x9d\\xc9\\xd1;\\xd9\\xee\\x05\\x06z\\xc8\\xb2\\xbb\\xe2\\xf7{JW4\\xcdm\\x1a\\xe5U\\x8d \\x0f\u0026amp;\\x14\\x7f\\xf6\\x9d\\xd4E\\xbf\\xc3\\xdb\\xe4L\\xe1\\xf7\\x90\\xbb\\xdaZ\\xf4\\x9d\\xd13\\xb8m3\\xe2D3o~\\xf8H\\xf6U*\\x07lY\\x03K\\xab\\x07~\\xa3\\x87\\xbb\\xc9\\xf7sAQ\\x08Y6J\\x86\\x07Y\\xec\\xf7\\xbb\\xc6s\\x15\\xc6\\x7fEY\\x02J\\x95\\x07Z \\x11\\xbb\\xc6T\\x15\\xfc-\\xd0\\x06\\xe6\\x9f-\\x07^ \\x15\\xbb\\xccz\\x14\\xf3\\x8f\\x97\\xd4l9t\\x85\\xe8\\x8a\\xbe\\xbb\\xf9\\xf6f\\x9d\\xf2\\xd19\\xa2K\\xb6\\xcd\\xcf\\xf6~\\xd5\\xa9\\xaa\\x15\\xd8\\x8e\\xb3\\x81m9\\xe4f\\xb2!\\x1e\\xba\\xd8s\\xfd\\x11\\x08W\\xa1l;\\x01\\x07_!\\x11\\xbb\\xdd\\xf6x\\x9d\\xf0\\x17Y\\x15\\xfe\\x02\\xc7\\xa0!.W\\xa9\\xa5\\x8f\\x9c\\xe8\\xd1\\x12m\\x04\\xe5s3Q~\\xdd\\xa9\\xa3\\x15\\xdb\\x8f\\xac\\xaf\\xec\\xbb\\x10\\xde2_\\xba\\xba\\xe8\\xf6f.\\x1e\\xd1\\x17l\\x06\\xe4U\\xdd\\xf0\\xd6~\\x0fA\\x14\\xcb\\x8e\\xb0Y\\x1fJ\\xb2\\xe4\\xb3!\u0026quot;\\xba\\xfeU\\x14\\xedY\\xd0\u0026gt;l-~\\x06P 1\\xbb\\xf2\\xf6waD\\xd1(m\\x12`\\x06@\\xb6~\\xfa\\xa9\\xb1\\xb0\\x9d\\xfb\\x18\\xfbm\u0026amp;\\xe4v2w\\xce\\xba\\xcbo\\xd5\\x07\\x11QX\u0026lt;J\\xbd\\xb22O\\x7f\\xd8x\u0026gt;\\xc8\\x9c\\xd3\\xd03\\x9d\\xb5\\x1e\\xd72S\\xf2ry\\xf1W\\x9c\\xc89Y\\rK\\x8f\\xff\\x8a\\xe0\\xb5{\\xa9\\xae\\xb1\\x9d\\xdd\\xd1=\\xbeK\\xa3\\x06e!\\x08\\xba\\xd2\\xf6j\\x9c\\xf6\\xd0\\x0fl#\\xe5o\\xf5\\xaa~\\xc2\\xa9\\x99\\x15\\xea6\\xd1:\\xe7\\xa8\\xe4n\\xbb \\nV\\xa9\\x91\\x14\\xf9}\\xd0!m/\\xe5|2o\\x81\\xba\\xf8\\r\\x14\\xeb\\tR\\xc9\\xec\\xdd`\\xbf\\xc6\\x81\\xdfKXW\\xb3o.%\\xa9\\xcd\\xb9\\x14\\xfd\\x97\\x83\\x8eO\\n\\x03\\xb6iuu\\xab\\x9d\\xbc\\x15\\xf4\\xc3\\xd6\\xc1' enc2 = b'p\\xfd\\x1ff\\xcaB\\xa5\\xe6`\\x87\\xa8\\x8ci\\x855\\x92O8P\\xa5}^\\xd8\\xed\\x1a\\x88=c\\xe0\\x9f\\xedq\\xf8\\xe1%\\x7fX\\xd2\\xba\\xbe\\x03\\xa8\\x9a\\x9c\\x075\\x98\u0026quot;\\xca\\xed\\xa4C^\\xc6.j\\xec\\xfa\\x10\\xa7\\xd9\\x01\\x06\\x87\\x90f\\xcc\\xf6\\x1b\\x0c\\xde\\xcc,\\xfb\\xf0\\xc74\\x94\\xcfj\\x8ay\\xd5\\xd2`.@\\xed\\xc2\\xd8!DSp\\xf5\\x12f\\xf1\\xf6#\\x80\\xbe\\x16\\xa8\\xaeF\\xd0\\xd1\\xd4\\xad\\xb9\\xf7#\\x16\\x08\\xb2[\\x1a\\x87\\x8b\\xa0\\xfaEF\\xbf\\x86\\x8b\\x8c\\x90\\xa4\\xd5\\xfbcR\\xe2W\\x9c\\n5\\x8b\\xcfQ\u0026quot;\\xf2\\x16\\x10\\xb2I\\x1a\\x88\\x8b\\x8cj\\x16\\xebp\\xccS\\xd2\\x90\\xa8|q\\x05\\xafq\\xfa\\xcaHE{\\x1a\\xba#\\xfd\\x17/\\xb2L\\x1a\\x87\\x8a\\x90\\xc9Dmp\\xef\\x0ef\\xf2Z|S\\x00R\\xfc\\x1c\\x9d\\n5\\x84\\xceS\\xb0\\xa4M_\\xff\\xb9\\x1a\\x8a\\x1d\\\\\\x98D\\\\p\\xcb*f\\xdcV\\xd0\\xd5Q\\xec\\x1a\\xfa\\xf0\\x91\\xa8\\xd4\\x8a\\xca\\x9c-\\x17\\x07\\xb2_\\xff\\n\\x8a\\x83\\xfb\\xc2\\x00\\x10\\x87\\x83\\xaeF\\xf7#\\xd4\\xbe\\'\\xa9\\x8a$IMp\\x14\\xe8\\xc0\\xa4z\\xd1\\xb2H\\xe6e\\x8b\\xb0\\xcf\\xb1\\x01\u0026lt;\\x87\\x88g\\xc2Q|H\\xbe9\\xa9\\xad\\x9c#4\\x8cl8I\\x0c\\x17$\\xb3}\\x1b\\x94\\x01:j7\\x00;\\x86\\xbd\\xd2i\\xf6\\x1a\\xa4\\'R\\xf6?\\x9c\\x08\\xe1\\xd4\\xab\\xdd\\x8f\\xa4[_\\xca/@\\xed\\xe86\\xf7\\x9c\\x018i\\x04\\xc3\\x90\\xa8\\xaa\\x0c\\xde\\xf2\\xa8\\xba?\\xf4\\xd39\\xce\\\\\u0026quot;\\xfe\\x16\\x0cY/]\\xed\\xe9l\\xce\\xa5\\x018o,g\\xdb\\xf7\\x12\\xdag\\xb6=\\xfa\\xccHgk\\xcfH\\xbf\\x18\\x9e\\xbd\\xb3u\\x8f\\n$Hk\\x0e\\xd3\\xa6i\\xe1\\x15=\\x16}R]\\xb3\\xa8\\x82\\x9b\\x0b4\\x9a\\xcf{\\xc2\\xa4V\\xe8:\\x93\\x1a\\x83\\x8a\\x97j\\t\\x82\\x88\\x86\\x80f\\xf6*\\xa2\\xd5\\xbe\\x08\\xa9\\x98\\x9c#\\xf8\\\\\\xceV\\xa7\\xa5L\\xae\u0026amp;/t\\xec\\xfb\\xd9\\x02Dnp\\xe8Cf\\xf0U}R4\\x87a\\xfb\\xf0I_\\xd4\\xaa\\xb4\u0026quot;\\xca\\x16\\x18\u0026gt;/i}\\t\\x03\\xc1\\x84\\x00!\\x86\\x93g\\xed\\xf7\\x1d\\xc3\\xbf\\x01c\\x06KI[\\xd5\\x929g\\xa4t\\x87\\xb2\\\\\\x1b\\x8d\\x0b\\xd9\\x0bDp\\xf5om\\xe1\\x16\\x0e}|ZR\\xc4\\xfb\\xf2H@\\xd4\\xa28\\\\c\\x17\u0026amp;\\x07\\xc8\\xda~\\x8b\\x88\\x86DS\\xeb\\x87\\x87f\\xda\\xf73\\r\\xcaS\\xd9\\xfa\\xfaI`\\xd5\\x889^R\\x97\\xaeF\\xf6\\x1a\\x92N\\xd8*Er\\xc3\\x16\\xe0)\\x91\\xba|_Q\\x83\\x00\u0026gt;;\\xff5\\x82\\xceX\u0026quot;\\xd7\\x17\\x08P\\xae\\x1a\\xb1\\x8a\\x8f\\xc9Ep\\xa7\\x86\\x86g\\xf6m|o\\xbf\\x1c\\xa9\\xa1\\x9c+\\xc9\\x1e\\xcfI#\\xfc\\x92^\\xc1\\xb8\\x1b\\xad\\x8a\\x9e\\xceEu\\xb8$\\xe0\\x0b\\x90\\x87}[\\x0fS\\xcab]\\xd2\\xaaU\\xcfh\u0026quot;\\xfc\\xa2_\\xdd/y\u0026lt;C\\x05k\\x18\\x00\\x1aw\\x1e\\x9cA\\xf6\\x0f\\x80w\\x83\\xae\\xb8\\x9d\\x0e\\xdc\\xd4\\xaf9H\\\\\\xaf\\x9ey\\xef\\x1b\\xb4.\\xd99Dd\\xa2\\x87\\xa7f\\xc6\\xf6\\n\\x0c\\xc4R\\xd7\\xfa\\xe4Hc\\xd4\\xa78Jc\\x9c^\\xca.u\\xed\\xfcak\u0026amp;\\x8b\\x92\\x87\\x88\\xee\\x90\\x83\\x90\\x0c\\xd9R\\xcd\\x08\\x9c04\\xb1\\xceC\u0026quot;\\xea\\xe9^\\xe3\\xd4\\x1a\\x9a\\x0c[\\xfa\\xc5\\x97\\xf5\u0026gt;\\x15\\xc71\\x06\\x8d\\xac\\x19\\xa0\\t\\x0el\\xe9\\xc6%4\\x9d\\x80U\\xe3\\xfdF\\x8d\\xee\\x17.+\\x9b\\xb3\\xf0\\x83w\\x16\\xd9' enc1 = list(enc1) enc2 = list(enc2) # 如果候选随机顺序的密钥，和当前定好顺序的密钥 含有相同数量的相同字节Int，那么就需要排除掉这个字节，不需要再对这个字节进行处理 def counter(Lis1, Lis2, Int): return sum([int(i == Int) for i in Lis1]) == sum([int(i == Int) for i in Lis2]) ''' 对于每一次递归的开始，k4 k5被认定是正确的密钥，但是顺序不对 ir 是当前递归的深度（用于判断的第i个密文字节） ''' def dfs(nk4, nk5, k4, k5, ir): if ir == 300: print(\u0026quot;k4 =\u0026quot;, nk4) print(\u0026quot;k5 =\u0026quot;, nk5) content = b''.join([long_to_bytes(nk4[i % len(nk4)] ^ enc1[i]) for i in range(len(enc1))]) print(content) exit(0) if len(nk4) \u0026lt; 15 and len(nk5) \u0026lt; 31: for k4i in k4: # 15 if counter(nk4, k4, k4i): continue for k5i in k5: # 31 # 如果使用k4中的一个值 和 k5中的一个值和当前密文字节异或结果相同，那么可以继续往下递归 if (k4i ^ enc1[ir]) == (k5i ^ enc2[ir]): if counter(nk5, k5, k5i): continue dfs(nk4+[k4i], nk5+[k5i], k4, k5, ir + 1) return if len(nk4) == 15 and len(nk5) \u0026lt; 31: for k5i in k5: if (nk4[ir % 15] ^ enc1[ir]) == (k5i ^ enc2[ir]): if counter(nk5, k5, k5i): continue dfs(nk4, nk5 + [k5i], k4, k5, ir + 1) return if len(nk4) == 15 and len(nk5) == 31: if (nk4[ir % 15] ^ enc1[ir]) == (nk5[ir % 31] ^ enc2[ir]): dfs(nk4, nk5, k4, k5, ir + 1) return for i in range(2**4): ini = [int(r) for r in list(\u0026quot;0\u0026quot;*(4 - len(bin(i)[2:])) + bin(i)[2:])] L4 = LFSR(fpoly=[4, 3], initstate=ini, verbose=True) data = L4.runFullCycle() k4 = b\u0026quot;\u0026quot; for _ in range(len(data)): a = b'' for __ in range(8): a += str(L4.next()).encode() k4 += long_to_bytes(int(a, 2)) k4 = list(k4) for ii in range(2**5): iini = [int(r) for r in list(\u0026quot;0\u0026quot;*(5 - len(bin(ii)[2:])) + bin(ii)[2:])] L5 = LFSR(fpoly=[5, 4, 2, 1], initstate=iini, verbose=True) data = L5.runFullCycle() k5 = b\u0026quot;\u0026quot; for _ in range(len(data)): a = b'' for _ in range(8): a += str(L5.next()).encode() k5 += long_to_bytes(int(a, 2)) k5 = list(k5) dfs([], [], k4, k5, 0) # DASCTF{7cc33bd1c63b029fa27a6a78f1253024} Offline CTF (travel) 2021 密码正常 ak，signin 硬推了一会儿没想起用连分数，都被打烂了才交 flag；fastOT 三血，进了决赛。不过现在由于疫情，可能会去不成长沙。\n线下赛：疫情，寄了\n2020 线上赛密码ak，队友输出很猛，成功进决赛。\n线下赛去了湖南，留影记念。\n","permalink":"https://slightwind.cn/posts/ctf/huxiangbei2021/","summary":"hxb 2021 crypto signin $n1/n2$ 的连分数展开是对 $q1/q2$ 的一个逼近，所以枚举连分数中的每一项，就可以得到 $q1, q2$ 了，分解之后正常进行 RSA 解密得到 flag。\nfrom Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime pk = (1150398070565459492080597718626032792435556703413923483458704675295997646493249759818468321328556510074044954676615760446708253531839417036997811506222349194302791943489195718713797322878586379546657275419261647635859989280700191441312691274285176619391539387875252135478424580680264554294179123254566796890998243909286508189826458854346825493157697201495100628216832191035903848391447704849808577310612723700318670466035077202673373956324725108350230357879374234418393233, 1242678737076048096780023147702514112272319497423818488193557934695583793070332178723043194823444815153743889740338870676093799728875725651036060313223096288606947708155579060628807516053981975820338028456770109640111153719903207363617099371353910243497871090334898522942934052035102902892149792570965804205461900841595290667647854346905445201396273291648968142608158533514391348407631818144116768794595226974831093526512117505486679153727123796834305088741279455621586989) c1, c2 = (361624030197288323178211941746074961985876772079713896964822566468795093475887773853629454653096485450671233584616088768705417987527877166166213574572987732852155320225332020636386698169212072312758052524652761304795529199864805108000796457423822443871436659548626629448170698048984709740274043050729249408577243328282313593461300703078854044587993248807613713896590402657788194264718603549894361488507629356532718775278399264279359256975688280723740017979438505001819438, 33322989148902718763644384246610630825314206644879155585369541624158380990667828419255828083639294898100922608833810585530801931417726134558845725168047585271855248605561256531342703212030641555260907310067120102069499927711242804407691706542428236208695153618955781372741765233319988193384708525251620506966304554054884590718068210659709406626033891748214407992041364462525367373648910810036622684929049996166651416565651803952838857960054689875755131784246099270581394) n1, n2 = pk e = 0x10001 def getRoot(x, n): high = 1 while high ** n \u0026lt;= x: high *= 2 low = high // 2 while low \u0026lt; high: mid = (low + high) // 2 if low \u0026lt; mid and mid**n \u0026lt; x: low = mid elif high \u0026gt; mid and mid**n \u0026gt; x: high = mid else: return mid return mid + 1 # https://github.","title":"湖湘杯 2021 Crypto"},{"content":"easyxor shift函数是个常见的移位异或操作，convert是对一个数字使用不同的 key 和 mask 进行 4 次移位异或，这个函数在已知 key 的情况下是可逆的。\nencrypt函数是对明文块进行两种模式（CBC和OFB）的块加密，块长度为 8，对于每一块的加密使用的就是上面的convert函数。\n首先通过密文的长度可以得知一共被分成了 6 块；前 3 块明文使用 OFB 模式，后三块明文使用 CBC 模式；keys 是一个长度为 4 的列表，列表中每个值的范围是(-32, 32)，$64^4$ 爆破也是可以接受的。\n读完题目代码之后可以想到其实我们已经知道第一块明文了，就是 flag 的格式ByteCTF{，而OFB模式实际上是加密的key，最终结果和明文块异或，所以第一个明文块异或第一个密文块就可以知道第一个 key 加密的结果，也就是cur_c = convert(last, k)的cur_c，这样就可以得到第二块的 last。\n现在对于第二块，已知 IV（last），未知 keys，已知明文是可显示字符，所以可以爆破 keys 了，把能解出可显示字符明文的 keys 都保留出来，发现有 4836 个 keys 是满足的，那么我们还要借助第三块再筛一次，最终只得到一组 keys。\nfrom itertools import product from tqdm import tqdm from Crypto.Util.number import bytes_to_long, long_to_bytes def check(s): return min([((i \u0026lt; 129) and (i \u0026gt; 31)) for i in s]) c = \u0026quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026quot; c_list = [int(c[i*16:i*16+16], 16) for i in range(len(c) // 16)] known_m = bytes_to_long(b'ByteCTF{') range64 = list(range(-32, 33)) cur_c = known_m ^ c_list[0] print(cur_c) k_cnt = 0 for a,b,c,d in tqdm(product(range64, range64, range64, range64)): last = cur_c k = [a, b, c, d] try_cur_c = convert(last, k) m1 = long_to_bytes(try_cur_c ^ c_list[1]) if check(m1): # 只筛选这第一轮的话，4836个k是满足条件的，所以得筛第二轮 last = try_cur_c try_cur_c = convert(last, k) m2 = long_to_bytes(try_cur_c ^ c_list[2]) if check(m2): k_cnt += 1 try: print(m1.decode() + m2.decode(), k) except: print(\u0026quot;error\u0026quot;) print(k_cnt) # keys = [-12, 26, -3, -31] # ByteCTF{5831a241s-f30980 现在已经得到了keys和前三块的明文，可以接着解后三块明文了。\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes k = [-12, 26, -3, -31] c = \u0026quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026quot; cl = [int(c[i*16:i*16+16], 16) for i in range(len(c) // 16)] cur_c = bytes_to_long(b'ByteCTF{') ^ cl[0] def shift(m, k, c): if k \u0026lt; 0: return m ^ m \u0026gt;\u0026gt; (-k) \u0026amp; c return m ^ m \u0026lt;\u0026lt; k \u0026amp; c def convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return m def unshift_right(value, key, mask=None, nbits=32): if not mask: mask = (1 \u0026lt;\u0026lt; (nbits + 1)) - 1 i = 0 while i * key \u0026lt; nbits: part_mask = ((((1 \u0026lt;\u0026lt; nbits)-1) \u0026lt;\u0026lt; (nbits - key)) \u0026amp; ((1 \u0026lt;\u0026lt; nbits)-1)) \u0026gt;\u0026gt; (i * key) part = value \u0026amp; part_mask value ^= (part \u0026gt;\u0026gt; key) \u0026amp; mask i += 1 return value def unshift_left(value, key, mask=None, nbits=32): if not mask: mask = (1 \u0026lt;\u0026lt; (nbits + 1)) - 1 i = 0 while i * key \u0026lt; nbits: part_mask = ((((1 \u0026lt;\u0026lt; nbits)-1) \u0026gt;\u0026gt; (nbits - key)) \u0026amp; ((1 \u0026lt;\u0026lt; nbits)-1)) \u0026lt;\u0026lt; (i * key) part = value \u0026amp; part_mask value ^= (part \u0026lt;\u0026lt; key) \u0026amp; mask i += 1 return value def my_unshift(m, k, c): if k \u0026lt; 0: tmp = unshift_right(m, -k, c, 64) return tmp tmp = unshift_left(m, k, c, 64) return tmp def re_convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3, -1, -1): m = my_unshift(m, key[t], c_list[t]) return m IV = re_convert(cur_c, k) assert IV.bit_length() == 64 last = IV cur = re_convert(cl[3], k) m3 = long_to_bytes(cur ^ last) print(m3) last = cl[3] cur = re_convert(cl[4], k) m4 = long_to_bytes(cur ^ last) print(m4) last = cl[4] cur = re_convert(cl[5], k) m5 = long_to_bytes(cur ^ last) print(m5) print(m3 + m4 + m5) # q535af-2156547475u2t}$$$ 拼接起来得到完整 flag:ByteCTF{5831a241s-f30980q535af-2156547475u2t}$$$\nabusedkey 首先把用到的数据放在了task_data.py，方便些其他脚本时直接导入：\nURL = \u0026quot;http://39.105.181.182:30000\u0026quot; msg11 = URL+\u0026quot;/abusedkey/server/msg11\u0026quot; msg13 = URL+\u0026quot;/abusedkey/server/msg13\u0026quot; msg21 = URL+\u0026quot;/abusedkey/server/msg21\u0026quot; msg23 = URL+\u0026quot;/abusedkey/ttp/msg23\u0026quot; msg25 = URL+\u0026quot;/abusedkey/server/msg25\u0026quot; # -------------------------------- Secp256k1 -------------------------------- p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F a, b = 0, 7 G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8) # ------------------ https://en.bitcoin.it/wiki/Secp256k1 ------------------- Pc = (0xb5b1b07d251b299844d968be56284ef32dffd0baa6a0353baf10c90298dfd117, 0xea62978d102a76c3d6747e283091ac5f2b4c3ba5fc7a906fe023ee3bc61b50fe) 协议2的部分，想要拿到hint很简单，只要按照描述实现出来，就拿到了hint，hint.sage:\nimport requests, os, random from Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes from task_data import p, a, b, G, msg21, msg23, msg25 from hashlib import sha256 E = EllipticCurve(IntegerModRing(p), [a, b]) G = E(G) # sid2 = hex(random.getrandbits(256))[2:] sid2 = \u0026quot;8d1a95ce724141a0ea7c8ffa7eddc48605b3117c8aa886bcc2aff3b0c2175b56\u0026quot; msg22 = requests.get(msg21, data=sid2).text Qs_hex = msg22 rc = 1 # random.randint(1, p) Rc = rc * G Pic = long_to_bytes(int('FFFF', 16)) hc = int(sha256(Pic).hexdigest(), 16) Qc = hc * Rc Qc_hex = hex(Qc[0])[2:].rjust(64) + hex(Qc[1])[2:].rjust(64) assert len(Qc_hex) == 128 msg24 = requests.get(msg23, data=Qc_hex+Qs_hex).text assert len(msg24) == 256 Yc_hex, Ys_hex = msg24[:128], msg24[128:] msg26 = requests.get(msg25, data=sid2+Yc_hex).text Ys = E((int(Ys_hex[:64], 16), int(Ys_hex[64:], 16))) Zcs = rc*Ys Zcsx = long_to_bytes(int(Zcs[0])) sk2 = sha256(Zcsx).digest() msg26 = bytes.fromhex(msg26) iv, ciphertext, mac = msg26[:12], msg26[12:-16], msg26[-16:] cipher = AES.new(sk2, mode=AES.MODE_GCM, nonce=iv) try: m = cipher.decrypt_and_verify(ciphertext, mac) print(m.decode()) except ValueError: print(\u0026quot;MAC check failed\u0026quot;) # off-line guessing on protocol_II, and key compromise impersonation on protocol_I Hint: off-line guessing on protocol_II, and key compromise impersonation on protocol_I\nhint和题目描述都在说明，两个协议共用一个 Server 端的 key，那么大概思路就是通过协议 2 拿到 key，再将这个 key 用于解协议 1 的 flag，可以先简单分析一下：\n已知 rc-(随机), hc-H(c口令) 未知 rs-(随机), hs-H(s口令) Qc = rc * hc * G --- 已知 Qs = rs * hs * G --- 已知 Yc = rc * rt * G --- 已知 Ys = rs * rt * G --- 已知 Zcs = rc * rs * rt * G --- 已知 公共密钥 这里面的rc是我们可以控制的，所以可以令rc=1让问题看起来简单一点。\nrc = 1 时： Qc = hc * G --- 已知 Qs = rs * hs * G --- 已知 Yc = rt * G --- 已知 Ys = rs * rt * G --- 已知 Zcs = rs * rt * G --- 已知 公共密钥 $hs$ 是两个字节的sha256结果，显然是让我们爆破的，也就是说我们需要得到一组形式为 $hs\\cdot Point$ 和 $Point$ 的数据，这样去爆两个字节就可以了，为了得到这样的数据，我们需要构造一下发送的数据。\n发送假的 Qc = hc * rs * hs * G = hc * Qs 得到 Yc = hs * rs * rt * G 发送 Qs = rs * hs * G 得到 Ys = rs * rt * G 这样以来，$Ys$ 和 $Yc$ 刚好是我们需要的一组数据，$Yc=hs\\cdot Ys$，然后爆破一下两个字节的哈希，如果某两个字节的 sha256 乘 $Ys$ 等于 $Yc$，那么这个 sha256 的值就是 $hs$：\nimport requests, os, random, tqdm from Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes from task_data import p, a, b, G, msg21, msg23, msg25 from hashlib import sha256 E = EllipticCurve(IntegerModRing(p), [a, b]) G = E(G) sid2 = \u0026quot;8d1a95ce724141a0ea7c8ffa7eddc48605b3117c8aa886bcc2aff3b0c2175b56\u0026quot; msg22 = requests.get(msg21, data=sid2).text Qs = E((int(msg22[:64], 16), int(msg22[64:], 16))) rc = 1 # random.randint(1, p) Rc = rc*G Pic = long_to_bytes(int('FFFF', 16)) hc = int(sha256(Pic).hexdigest(), 16) fake_Qc = hc * Qs # hc * rs * hs * G fake_Qc_hex = hex(fake_Qc[0])[2:].rjust(64) + hex(fake_Qc[1])[2:].rjust(64) msg24 = requests.get(msg23, data=fake_Qc_hex+msg22).text assert len(msg24) == 256 Yc_hex, Ys_hex = msg24[:128], msg24[128:] # hs * rs * rt * G Yc = E((int(Yc_hex[:64], 16), int(Yc_hex[64:], 16))) # rs * rt * G Ys = E((int(Ys_hex[:64], 16), int(Ys_hex[64:], 16))) for pis in tqdm.tqdm(range(0xff, 0xffff+1)): hs = int(sha256(long_to_bytes(pis)).hexdigest(), 16) if ((hs*Ys) == Yc): print(f'pis = {pis}\\nhs = {hs}') break ''' pis = 36727 hs = 67294392667457530634966084521984708026794776225602296684920633502274376489620 ''' 协议 2 搞到了 $hs$，也就是协议 1 中的服务端私钥 ds，所以服务端的公钥也很容易得到，这样就有了 $(d_S,P_S)$，还有题目给我们的 $P_C$，一旦计算出 $K_{CS}$ 就可以解出 flag 了，那么问题是看起来我们必须知道 $t_S$ 和 $d_C$ 中的一个，所以需要想办法把它消掉，在要求上传 $T_C$ 的时候，上传 $-T_C$ 就可以了。\nimport requests, random from Crypto.Util.number import * from Crypto.Cipher import AES from task_data import p, a, b, G, msg11, msg13, Pc from hashlib import sha256 E = EllipticCurve(IntegerModRing(p), [a, b]) G = E(G) sid1 = \u0026quot;8d1a95ce724141a0ea7c8ffa7eddc48605b3117c8aa886bcc2aff3b0c2175b56\u0026quot; msg12 = requests.get(msg11, data=sid1).text ds = 67294392667457530634966084521984708026794776225602296684920633502274376489620 Ps = ds*G Pc = E(Pc) invPc = -1*Pc print(invPc) invPc_hex = hex(invPc[0])[2:].rjust(64) + hex(invPc[1])[2:].rjust(64) msg14 = requests.get(msg13, data=sid1+invPc_hex).text Kcs = ds * invPc sk1 = sha256(long_to_bytes(int(Kcs[0]))).digest() msg26 = bytes.fromhex(msg14) iv, ciphertext, mac = msg26[:12], msg26[12:-16], msg26[-16:] cipher = AES.new(sk1, mode=AES.MODE_GCM, nonce=iv) try: m = cipher.decrypt_and_verify(ciphertext, mac) print(m.decode()) except ValueError: print(\u0026quot;MAC check failed\u0026quot;) JustDecrypt 和美团 CTF 决赛的 secret_decryption_system 几乎是一样的题，不同的地方是给的交互次数不够，最后 unpad 不一定会被截断到什么地方，所以用一样的脚本跑出结果的概率是1/256\nfrom Crypto.Util.number import * from pwn import * from tqdm import tqdm def main(): r = remote('39.105.181.182', '30001') plaintext = b\u0026quot;Hello, I'm a Bytedancer. Please give me the flag!\u0026quot;+b\u0026quot;\\x0f\u0026quot;*15 def my_XOR(a, b): assert len(a) == len(b) return b''.join([long_to_bytes(a[i]^b[i]) for i in range(len(a))]) def proof_of_work(): rev = r.recvuntil(b\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(28).decode() rev = r.recvuntil(b\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode() + suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(b'Give me XXXX \u0026gt; ') r.sendline(prefix.encode()) def decrypt(msg): newmsg = msg + b'\\x00'*(256+64-len(msg)) r.recvuntil(b'Please enter your cipher in hex \u0026gt; ') r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) def decrypt_(msg): newmsg = msg + b'\\x00'*(256-len(msg)) r.recvuntil(b'Please enter your cipher in hex \u0026gt; ') r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) proof_of_work() msg = b'\\x00'*16 decrypt(msg) c = b\u0026quot;\u0026quot; for i in range(50): t = decrypt(c)[i] c += long_to_bytes(t^plaintext[i]) decc = decrypt_(c) print(decc) res = r.recvline()+r.recvline() if b\u0026quot;Here is your flag\u0026quot; in res: print(r.recvline()) print(r.recvline()) r.close() return (True, len(decc)) r.close() return (False, len(decc)) ll = [] while True: ss = main() ll.append(ss[1]) if ss[0]: break print(len(ll), ll) Overheard 相当于一个 Oracle，给返回pow(msg, b, p)的高位，可以想办法利用 coppersmith 定理。先后发送 Alice 和 pow(Alice, 2, p)的值，然后得到x1，x2，那么在模 p 的多项式$f(x) = (x1 + a)^2 - x2 - b$ 的值为 0，所以解这个方程的 small roots 就可以得到被舍弃的值（小于 64-bit）。\nfrom pwn import remote from Crypto.Util.number import * import itertools r = remote('39.105.38.192', 30000) p = 62606792596600834911820789765744078048692259104005438531455193685836606544743 g = 5 r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;1\u0026quot;) Alice = int(r.recvline().decode().strip()) r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;2\u0026quot;) Bob = int(r.recvline().decode().strip()) r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;3\u0026quot;) r.sendlineafter(b\u0026quot;To Bob: \u0026quot;, str(Alice).encode()) x1 = int(r.recvline().decode().strip()) r.sendlineafter(b\u0026quot;$ \u0026quot;, b\u0026quot;3\u0026quot;) r.sendlineafter(b\u0026quot;To Bob: \u0026quot;, str(pow(Alice, 2, p)).encode()) x2 = int(r.recvline().decode().strip()) def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m-i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] PR.\u0026lt;a,b\u0026gt; = PolynomialRing(Zmod(p)) f = (x1 + a)**2 - x2 - b ans = small_roots(f, (2**64, 2**64), m=8) print(\u0026quot;ans =\u0026quot;, ans) r.sendlineafter(b'$ ', b'4') r.sendlineafter(b'secret: ', str(x1 + ans[0][0]).encode()) print(r.recvline().decode().strip()) r.close() ''' ans = [(275016199582168079, 3988784878785365375)] b'ByteCTF{0fcca5ab-c7dc-4b9a-83f0-b24d4d004c19}' ''' ","permalink":"https://slightwind.cn/posts/ctf/bytectf2021/","summary":"easyxor shift函数是个常见的移位异或操作，convert是对一个数字使用不同的 key 和 mask 进行 4 次移位异或，这个函数在已知 key 的情况下是可逆的。\nencrypt函数是对明文块进行两种模式（CBC和OFB）的块加密，块长度为 8，对于每一块的加密使用的就是上面的convert函数。\n首先通过密文的长度可以得知一共被分成了 6 块；前 3 块明文使用 OFB 模式，后三块明文使用 CBC 模式；keys 是一个长度为 4 的列表，列表中每个值的范围是(-32, 32)，$64^4$ 爆破也是可以接受的。\n读完题目代码之后可以想到其实我们已经知道第一块明文了，就是 flag 的格式ByteCTF{，而OFB模式实际上是加密的key，最终结果和明文块异或，所以第一个明文块异或第一个密文块就可以知道第一个 key 加密的结果，也就是cur_c = convert(last, k)的cur_c，这样就可以得到第二块的 last。\n现在对于第二块，已知 IV（last），未知 keys，已知明文是可显示字符，所以可以爆破 keys 了，把能解出可显示字符明文的 keys 都保留出来，发现有 4836 个 keys 是满足的，那么我们还要借助第三块再筛一次，最终只得到一组 keys。\nfrom itertools import product from tqdm import tqdm from Crypto.Util.number import bytes_to_long, long_to_bytes def check(s): return min([((i \u0026lt; 129) and (i \u0026gt; 31)) for i in s]) c = \u0026quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026quot; c_list = [int(c[i*16:i*16+16], 16) for i in range(len(c) // 16)] known_m = bytes_to_long(b'ByteCTF{') range64 = list(range(-32, 33)) cur_c = known_m ^ c_list[0] print(cur_c) k_cnt = 0 for a,b,c,d in tqdm(product(range64, range64, range64, range64)): last = cur_c k = [a, b, c, d] try_cur_c = convert(last, k) m1 = long_to_bytes(try_cur_c ^ c_list[1]) if check(m1): # 只筛选这第一轮的话，4836个k是满足条件的，所以得筛第二轮 last = try_cur_c try_cur_c = convert(last, k) m2 = long_to_bytes(try_cur_c ^ c_list[2]) if check(m2): k_cnt += 1 try: print(m1.","title":"ByteCTF 2021 Crypto"},{"content":"Get shell 小米路由器后台管理页面是不给我们上传并且刷入新固件的，所以要先拿到 shell，ssh 连上路由器就可以往里面刷入新固件了。\n先正常启动路由器，并进入路由器后台管理页面，这时可以在浏览器的地址栏看到自己路由器的内网 IP，和自己的 stok，例如我的开头是：\nhttp://10.161.145.162/cgi-bin/luci/;stok=e9974e290dd74c4683328c5a5876308b/... 我的路由器 IP 是10.161.145.162，stok的值为e9974e290dd74c4683328c5a5876308b，现在把下面的链接替换成自己的，然后 Enter，浏览器返回0说明这一步可以了。\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B 然后下面这个链接也是一样的操作，同样应该返回0：\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20'12345678%5Cn12345678'%20%7C%20passwd%20root%3B 如果这两个链接都成功返回了0，那么就可以使用习惯的工具去 ssh 连接路由器了：\nssh root@「这里替换IP」 # passwd 12345678 不出意外，这边是可以连接到路由器的 shell 的，然后可以看到字符画显示的are you ok。\n上传并刷入固件 前面拿到了 shell，现在可以上传固件了，首先下载openwrt-RM2100-kernel1.bin和openwrt-RM2100-rootfs0.bin，然后 cd 进入这两个文件所在的目录，用 SCP 传到路由器上。\n# 把openwrt的固件通过SCP上传到路由器的/tmp目录下 scp openwrt-RM2100-kernel1.bin root@「这里替换IP」:/tmp scp openwrt-RM2100-rootfs0.bin root@「这里替换IP」:/tmp 然后 ssh 连接上路由器，开始刷入固件：\n# 进入/tmp目录下 cd /tmp mtd write openwrt-RM2100-kernel1.bin kernel1 nvram set uart_en=1 nvram set bootdelay=5 nvram set flag_try_sys1_failed=1 nvram commit mtd -r write openwrt-RM2100-rootfs0.bin rootfs0 等待写入完成，就可以重启路由器了，这个时候路由器的 Wi-Fi 名称变成了 OpenWrt，并且没有密码，可以直接连接，然后用 ssh 连接新的 IP：\n# 用新的IP来ssh连上去，刷完OpenWrt之后，内网IP也会改变 ssh root@192.168.1.1 # 连上之后可以看到：root@OpenWrt:~# 到这里，固件就刷入成功了。路由器管理地址为：192.168.1.1 用户名：root 密码：password\n如果现在的固件可以满足使用要求，那么就不需要接着操作了，但是我需要使用路由器上运行一个脚本来自动使用账号密码连接校园网，每当网络断开时再重新去连接，而当前的固件不支持curl命令，个人感觉 UI 也不够美观，所以我使用它来写入新的固件，这个固件支持curl，也更加美观。\n刷入新固件 由于最新编译 ROM 较大无法直接通过telnet刷入，所以刷完上面 ROM 后需要在路由器管理后台更新最新 OP 固件。\n先下载一下03.10-openwrt-ramips-mt7621-redmi-ac2100-squashfs-sysupgrade.bin固件。\n然后登陆192.168.1.1后台后点击「系统」-「备份/升级」-「刷写新固件（不保留配置）」-「上传op固件包」\n选择刚刚下载的 bin 文件进行安装，安装完成后，重启路由器，然后连接上路由器后台就可以了，这里同样要注意，刷入新固件后路由器的IP会改变，最好进电脑的 Wi-Fi 详情里面看一下，我的是变成了 192.168.2.1，ssh 和 web 后台密码都是password。\n现在就可以在路由器的后台进行一些自己需要的配置操作了。\n救砖：如果折腾的过程中出现了什么问题，可以使用官方的救砖工具MIWIFI Repair Tool，并刷入官方固件miwifi_rm2100_firmware_d6234_2.0.7.bin。\nMentioned files - - openwrt-RM2100-kernel1.bin 谷歌云盘 腾讯微云 openwrt-RM2100-rootfs0.bin 谷歌云盘 腾讯微云 03.10-openwrt-ramips-mt7621-redmi-ac2100-squashfs-sysupgrade.bin 谷歌云盘 腾讯微云 MIWIFI Repair Tool 谷歌云盘 腾讯微云 miwifi_rm2100_firmware_d6234_2.0.7.bin 谷歌云盘 腾讯微云 ","permalink":"https://slightwind.cn/posts/environment/install-openwrt-for-redmi-ac2100/","summary":"Get shell 小米路由器后台管理页面是不给我们上传并且刷入新固件的，所以要先拿到 shell，ssh 连上路由器就可以往里面刷入新固件了。\n先正常启动路由器，并进入路由器后台管理页面，这时可以在浏览器的地址栏看到自己路由器的内网 IP，和自己的 stok，例如我的开头是：\nhttp://10.161.145.162/cgi-bin/luci/;stok=e9974e290dd74c4683328c5a5876308b/... 我的路由器 IP 是10.161.145.162，stok的值为e9974e290dd74c4683328c5a5876308b，现在把下面的链接替换成自己的，然后 Enter，浏览器返回0说明这一步可以了。\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B 然后下面这个链接也是一样的操作，同样应该返回0：\nhttp://「这里替换IP」/cgi-bin/luci/;stok=「stok的值」/api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20'12345678%5Cn12345678'%20%7C%20passwd%20root%3B 如果这两个链接都成功返回了0，那么就可以使用习惯的工具去 ssh 连接路由器了：\nssh root@「这里替换IP」 # passwd 12345678 不出意外，这边是可以连接到路由器的 shell 的，然后可以看到字符画显示的are you ok。\n上传并刷入固件 前面拿到了 shell，现在可以上传固件了，首先下载openwrt-RM2100-kernel1.bin和openwrt-RM2100-rootfs0.bin，然后 cd 进入这两个文件所在的目录，用 SCP 传到路由器上。\n# 把openwrt的固件通过SCP上传到路由器的/tmp目录下 scp openwrt-RM2100-kernel1.bin root@「这里替换IP」:/tmp scp openwrt-RM2100-rootfs0.bin root@「这里替换IP」:/tmp 然后 ssh 连接上路由器，开始刷入固件：\n# 进入/tmp目录下 cd /tmp mtd write openwrt-RM2100-kernel1.bin kernel1 nvram set uart_en=1 nvram set bootdelay=5 nvram set flag_try_sys1_failed=1 nvram commit mtd -r write openwrt-RM2100-rootfs0.bin rootfs0 等待写入完成，就可以重启路由器了，这个时候路由器的 Wi-Fi 名称变成了 OpenWrt，并且没有密码，可以直接连接，然后用 ssh 连接新的 IP：","title":"Install OpenWrt for Redmi Router AC2100"},{"content":"Install conda 官网上没有直接给出 M1 Mac 版本的 SageMath 二进制安装文件，不过给出了使用 conda 安装 Sage 的方法，参考Install from conda-forge。\n所以如果自己的 Mac 上还没有安装 conda 的话，可以先安装一下，然后使用 conda 安装 SageMath。\n首先下载Miniforge3-MacOSX-arm64.sh，cd 进入Miniforge3-MacOSX-arm64.sh所在的目录。\nbash Miniforge3-MacOSX-arm64.sh 接着一路回车，直到确认条款：\nDo you accept the license terms? [yes|no] [no] \u0026gt;\u0026gt;\u0026gt; yes 然后编辑配置文件vim ~/.zshrc，在最下面加入如下内容：\npath=('/Users/「这里替换成Mac用户名」/miniforge3/bin' $path) export PATH :wq保存并退出，然后source ~/.zshrc，conda info应该就可以看到了，到这里 conda 安装完成。\n在终端输入下面这些，给 conda 换到清华源，这样在使用国内网络不走代理的情况下安装一些东西就更快了：\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes 然后输入conda config --show | grep https可以看到已经更新成功的上面的链接。\n如果是直接新开的终端，直接输入conda是没有反应的，需要先source ~/.zshrc一下。\nInstall SageMath conda config --append channels conda-forge conda config --set channel_priority strict conda create -n sage sage python=3.9 # Proceed ([y]/n)? y # 然后就开始下载安装了 这时输入conda activate sage，然后输入sage就可以看到sage启动了，也可以使用sage xxx.sage来执行一个sage脚本，这样就是安装完成了。\n注意每次都要先vim ~/.zshrc进入conda，然后conda activate sage进入sage。\nMentioned files - - Miniforge3-MacOSX-arm64.sh - 腾讯微云 ","permalink":"https://slightwind.cn/posts/crypto/install-sagemath-for-apple-silicon-m1/","summary":"Install conda 官网上没有直接给出 M1 Mac 版本的 SageMath 二进制安装文件，不过给出了使用 conda 安装 Sage 的方法，参考Install from conda-forge。\n所以如果自己的 Mac 上还没有安装 conda 的话，可以先安装一下，然后使用 conda 安装 SageMath。\n首先下载Miniforge3-MacOSX-arm64.sh，cd 进入Miniforge3-MacOSX-arm64.sh所在的目录。\nbash Miniforge3-MacOSX-arm64.sh 接着一路回车，直到确认条款：\nDo you accept the license terms? [yes|no] [no] \u0026gt;\u0026gt;\u0026gt; yes 然后编辑配置文件vim ~/.zshrc，在最下面加入如下内容：\npath=('/Users/「这里替换成Mac用户名」/miniforge3/bin' $path) export PATH :wq保存并退出，然后source ~/.zshrc，conda info应该就可以看到了，到这里 conda 安装完成。\n在终端输入下面这些，给 conda 换到清华源，这样在使用国内网络不走代理的情况下安装一些东西就更快了：\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.","title":"Install SageMath for Apple Silicon M1"},{"content":"这题使用的加密算法是 Demytko，属于一种类似 RSA 的在椭圆曲线上的加密算法，这题的攻击思路也是可以完全类比 RSA Hastad 广播攻击。\n加密后的结果是椭圆曲线上的点， Division Polynomials 使我们可以用仅含一个未知数的多项式来表示这个点的 $x$ 坐标：\n$$ \\begin{aligned} \\psi_{-1} \u0026amp;=-1 \\\\ \\psi_{0} \u0026amp;=0 \\\\ \\psi_{1} \u0026amp;=1 \\\\ \\psi_{2} \u0026amp;=2 y \\\\ \\psi_{3} \u0026amp;=3 x^{4}+6 a x^{2}+12 b x-a^{2} \\\\ \\psi_{4} \u0026amp;=4 y\\left(x^{6}+5 a x^{4}+20 b x^{3}-5 a^{2} x^{2}-4 a b x-8 b^{2}-a^{3}\\right) \\\\ \\psi_{2 i+1} \u0026amp;=\\psi_{i}\\left(\\psi_{i+2} \\psi_{i-1}^{2}-\\psi_{i-2} \\psi_{i+1}^{2}\\right) / 2 y, i \\geq 2 \\\\ \\psi_{2 i} \u0026amp;=\\psi_{i+2} \\psi_{i}^{3}-\\psi_{i+1}^{3} \\psi_{i-1}, i \\geq 3 \\end{aligned} $$\n此外，还可以定义多项式 $\\phi_{m}$ 和 $\\omega_{m}$：\n$$ \\begin{aligned} \\phi_{m} \u0026amp;=x \\psi_{m}^{2}-\\psi_{m+1} \\psi_{m-1} \\\\ \\omega_{m} \u0026amp;=\\left(\\psi_{m+2} \\psi_{m-1}^{2}-\\psi_{m-2} \\psi_{m+1}^{2}\\right) / 4 y \\end{aligned} $$\n那么椭圆曲线上的数乘，就可以用 Division Polynomials 来表示了：\n$$ m P=\\left(\\frac{\\phi_{m}(P)}{\\psi_{m}(P)^{2}}, \\frac{\\omega_{m}(P)}{\\psi_{m}(P)^{3}}\\right) $$\n$$ ciphertext=\\frac{\\phi_{m}(P)}{\\psi_{m}(P)^{2}} $$\n$$ f=ciphertext\\cdot \\psi_{m}(P)^{2}-\\phi_{m}(P)=0\\ (mod\\ n) $$\n由于密文给了 $70$ 组，所以 $f_i$ 多项式一共有 $70$ 个，由于指数 $e=3$，所以 $f_i$ 为九次同余方程，可以通过中国剩余定理将 $70$ 个同余方程合并成一个，这时得到的是一个系数很大，模数 $N$ 也很大的九次同余方程，这时可以通过格基规约算法得到模这个很大的 $N$ 的意义下的、较小的系数，当真实系数小于 $N$ 时，同余方程便可以直接看作等号连接的方程，即可很方便的求解一个较小的根（明文）。\n参考论文 SOLVING SIMULTANEOUS MODULAR EQUATIONS OF LOW DEGREE\n非预期：在使用 CRT 合并成一个同余式之后，由于明文 $m$ 相对 $n$ 过于小，可以用 Sage 的.small_roots求解出根，这样就不需要自己规约了。\nfrom functools import reduce from Crypto.Util.number import * f = open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;) ciphertext = [] a, b, n = [], [], [] for i in range(70): ci, ai, bi, ni = [int(num) for num in f.readline().strip().split(\u0026quot;, \u0026quot;)] ciphertext.append(ci) a.append(ai) b.append(bi) n.append(ni) e = 3 deg = 9 coeffi = [] for i in range(70): E = EllipticCurve(IntegerModRing(n[i]), [a[i], b[i]]) P.\u0026lt;m\u0026gt; = PolynomialRing(Zmod(n[i])) f = ciphertext[i]*E._multiple_x_denominator(e, m) - E._multiple_x_numerator(e, m) coeffi.append(f.coefficients(sparse=False)) large_coeffi = [crt([int(coeffi[j][i]) for j in range(70)], [n[j] for j in range(70)]) for i in range(deg+1)] N_bitlength = sum([n[i].bit_length() for i in range(70)]) min_n = min(n) N = reduce(lambda x, y: x * y, n) Sc = large_coeffi var(\u0026quot;x\u0026quot;) assume(x, 'integer') f = Sc[9]*x^9 + Sc[8]*x^8 + Sc[7]*x^7 + Sc[6]*x^6 + Sc[5]*x^5 + Sc[4]*x^4 + Sc[3]*x^3 + Sc[2]*x^2 + Sc[1]*x + Sc[0] lat = [] lat.append([large_coeffi[i]*min_n**i for i in range(deg+1)]+[1/(deg+1)]) for i in range(deg+1): lat.append([((min_n**j)*N if (i==j) else 0) for j in range(deg+1)]+[0]) Mat = matrix(lat) Mat_LLL = Mat.LLL() for lin in range(deg): Sc = [int(i) for i in Mat_LLL[lin]] Sc = [(Sc[i] // (min_n**i)) for i in range(deg + 1)] var(\u0026quot;x\u0026quot;) assume(x, 'integer') f = Sc[9]*x^9 + Sc[8]*x^8 + Sc[7]*x^7 + Sc[6]*x^6 + Sc[5]*x^5 + Sc[4]*x^4 + Sc[3]*x^3 + Sc[2]*x^2 + Sc[1]*x + Sc[0] print(factor(f)) break ''' m = 3088969433059681806521206959873975785377227976800172674306727155831805513908352148702210247662586117242206183337522557 print(long_to_bytes(m)) ''' Nep{LOoK_aT_th3_sT4R-Lo0k_h0w_tH3y_5h1N3_fOr_Y0u}\n","permalink":"https://slightwind.cn/posts/ctf/official-solution-to-lowexponent-problem-in-nepctf2021/","summary":"这题使用的加密算法是 Demytko，属于一种类似 RSA 的在椭圆曲线上的加密算法，这题的攻击思路也是可以完全类比 RSA Hastad 广播攻击。\n加密后的结果是椭圆曲线上的点， Division Polynomials 使我们可以用仅含一个未知数的多项式来表示这个点的 $x$ 坐标：\n$$ \\begin{aligned} \\psi_{-1} \u0026amp;=-1 \\\\ \\psi_{0} \u0026amp;=0 \\\\ \\psi_{1} \u0026amp;=1 \\\\ \\psi_{2} \u0026amp;=2 y \\\\ \\psi_{3} \u0026amp;=3 x^{4}+6 a x^{2}+12 b x-a^{2} \\\\ \\psi_{4} \u0026amp;=4 y\\left(x^{6}+5 a x^{4}+20 b x^{3}-5 a^{2} x^{2}-4 a b x-8 b^{2}-a^{3}\\right) \\\\ \\psi_{2 i+1} \u0026amp;=\\psi_{i}\\left(\\psi_{i+2} \\psi_{i-1}^{2}-\\psi_{i-2} \\psi_{i+1}^{2}\\right) / 2 y, i \\geq 2 \\\\ \\psi_{2 i} \u0026amp;=\\psi_{i+2} \\psi_{i}^{3}-\\psi_{i+1}^{3} \\psi_{i-1}, i \\geq 3 \\end{aligned} $$","title":"Official Solution to the \"lowExponent\" Problem in NepCTF2021"},{"content":"0xGame2020是第一届0xGame比赛，时间持续一个月，面向零基础的新生。题目和exp可以在我的GitHub上找到：https://github.com/Am473ur/My-CTF-Challenge/tree/main/0xGame2020 ，这里记录一下出题人角度的 wp。\nWeek 1 Calendar 题目给了一张图片和一串逗号隔开的坐标信息，没看出来的话不难想到去百度一下“日历加密”，这题只是做了简单的修改。\nSAT1,THU1,MON3,MON2,WED3,SUN2,THU1,SUN4,FRI3,THU1,MON4,MON4,FRI4,THU3,SUN4,SUN2,TUE4,THU1,FRI1,MON3,MON2\n懒得百度的话，也不难看出前三个字母代表周一到周日，紧跟的数字范围是 1～4，所以他们代表两个坐标，列举出来并用a～z替换1～26，即可得到 flag。\neasyXor 做出这题只需要知道异或的逆运算还是异或，反过来跑一遍就拿到了flag。\nexp:\ncipher = [72, 63, 38, 12, 8, 30, 30, 6, 82, 4, 84, 88, 92, 7, 79, 29, 8, 90, 85, 26, 25, 87, 80, 10, 20, 20, 9, 4, 80, 73, 31, 5, 82, 0, 1, 92, 0, 0, 94, 81, 4, 85, 27, 35] flag = \u0026quot;\u0026quot; cipher += [ord(\u0026quot;^\u0026quot;)] for i in range(len(cipher)-1): flag = chr(cipher[len(cipher) - i - 2] ^ cipher[len(cipher) - i - 1]) + flag cipher[len(cipher) - i - 2] = ord(flag[0]) print(flag) # 0xGame{ec15a9eb-08b7-4c39-904d-27eed888f73f} 发现有的学弟跑完脚本手动补0，exp正确的话，是可以得到完整flag的。\nsupperAffine 这题其实就是普通的仿射加密，看起来是套了三层，但是一旦展开化简，仍然是 $Ax+B$ 的一次式。\n$$ \\begin{aligned} f(x)\u0026amp;=A_1(A_2(A_3\\cdot x+B_3)+B_2)+B_3\\\\ \u0026amp;=(A_1A_2A_3)\\cdot x+(A_1A_2B_3+A_1B_2+B_1)\\\\ \u0026amp;=A\\cdot x+B \\end{aligned} $$\n其中 $A = A_1A_2A_3,\\ B = A_1A_2B_3+A_1B_2+B_1.$\n并且过大的 $A$ 和 $B$ 都是没有意义的，可以等效为模数以内的数，所以解普通的仿射加密的脚本都可以直接解这一题。\nexp:\nfrom Crypto.Util.number import * from string import ascii_letters, digits table = ascii_letters + digits cipher = \u0026quot;t6b7Tn{2GByBZBB-aan2-JRWn-GnZB-Jyf7a722ffnZ}\u0026quot; MOD = len(table) def find_ab(): for a in range(MOD): for b in range(MOD): if (a * table.find(\u0026quot;0\u0026quot;) + b) % MOD == table.find(cipher[0]): if (a * table.find(\u0026quot;x\u0026quot;) + b) % MOD == table.find(cipher[1]): if (a * table.find(\u0026quot;G\u0026quot;) + b) % MOD == table.find(cipher[2]): if (a * table.find(\u0026quot;a\u0026quot;) + b) % MOD == table.find(cipher[3]): print(\u0026quot;a, b = {}, {}\u0026quot;.format(a, b)) return (a, b) flag = \u0026quot;\u0026quot; A, B = find_ab() for i in cipher: if i not in table: flag += i else: flag += table[inverse(A, MOD) * (table.find(i) - B) % MOD] print(flag) 0xGame{1b292822-33e1-46fe-be82-49ca3a11cce8}\nequationSet 这题是个简单的解方程组，可以发现给出的值有 $$ \\begin {aligned} n\u0026amp;= p\\cdot q\\cdot r\\\\ s\u0026amp;= p + q + r\\\\ t\u0026amp;= p\\cdot(q+r) \\end {aligned} $$\n我们需要求的是\n$$ \\phi(n)=(p-1)\\cdot (q-1)\\cdot (r-1) $$\n其中\n$$ p = GCD(n, t) $$\n所以\n$$ \\begin {aligned} \\phi(n) \u0026amp;= (p-1)\\cdot( q\\cdot r-(q+r)+1) \\\\ \u0026amp;= (p-1)\\cdot( (n-t)/p+1) \\end {aligned} $$\nexp:\nfrom Crypto.Util.number import * c = 216719040256186298397028655750064798850... n = 894056034566447301955142597300391580123... s = 296550633935119159669335323468002356547... t = 157435908314881832180551915807491465031... p = GCD(n, t) phi = (p - 1) * ((n - t) // p + 1) d = inverse(65537, phi) m = pow(c, d, n) print(long_to_bytes(m)) 这题也可以使用sagemath直接解，甚至不需要简单的公式推导：\nvar('p q r') solve([p + q + r == s, p * q * r == n, p * q + p * r == t],[p, q, r]) 可以直接求出3个素数的值，然后进行解密。\nFibonacci 这题的考点是斐波那契数列对一个模数n取模，会出现循环节，求出循环周期这题就相当于解决了。\n这个周期就是皮萨诺周期（Pisano periods），先对 $n$ 进行素因数分解，然后求解每个素数幂的周期，最后通过中国剩余定理（Chinese remainder theorem）合并，一个素数幂 $p^n$ 的周期等于 $p^{n-1}$ 乘以 $p$ 的周期，所以需要求出每个素因数的周期。这里分为两种情况，如果 $5$ 是模 $p$ 的二次剩余，那么 $p$ 的周期是 $p-1$ 的一个因数；如果不是，那么周期为 $2(p+1)$ 的一个因数。$5$ 是否为模 $p$ 的二次剩余，可以通过勒让德（Legrend）符号来判断。\n不过这题的 $n$ 很小，直接爆破就可以很快得到它的周期。。。（而且还挺快的orz）\n这里给出通过定理求解的脚本（用C++写矩阵快速幂来实现的话会快很多）。\nfrom Crypto.Util.number import * from gmpy2 import next_prime def genFibonacci(): a = [1, 1] for i in range(2, 2**16): a.append(a[i-1] + a[i-2]) return a def Legrend(a, p): if a == 1: return 1 if p % a == 0: return 0 if a % 2 == 0: return Legrend(a // 2, p) * pow(-1, (pow(p, 2) - 1) // 8) return Legrend(p % a, a) * pow(-1, (a - 1)*(p - 1) // 4) def isPeriod(T, a): for t in range(T): p = t + T while p \u0026lt; len(a): if a[p] != a[t]: return False p += T return True def Factor_n(n): a = [] for i in range(2**3, 2**5): if (not isPrime(i)) or (n % i): continue a.append([i, 0]) n //= i while n % i == 0: n //= i a[-1][1] += 1 return a def Factor_x(x): a = [] for i in range(2, x): if x % i == 0: a.append(i) return a def solve(a): per = [] for i in range(len(a)): prime = a[i][0] if Legrend(5, prime) == 1: fac = Factor_x(prime - 1) tmp = prime-1 else: fac = Factor_x(2*(prime + 1)) tmp = 2*(prime + 1) fib_mod = [(k % prime) for k in fib] for t in fac: if isPeriod(t, fib_mod): per.append(t*(prime**a[i][1])) break else: per.append(tmp*(prime**a[i][1])) LCM = per[0] for i in range(1, len(per)): LCM = (per[i] * LCM) // GCD(LCM, per[i]) return LCM r = 6799657976717333 n = 34969 c = 18230697428395162035214602694158399484881314... N = 18856119995376203055253776689360000192482523... fib = genFibonacci() a = Factor_n(n) T = solve(a) fib_mod = [(k % n) for k in fib] S = sum(fib_mod[:T]) * (r // T)+sum(fib_mod[:r%T]) p = next_prime(S**16) q = N // p m = pow(c, inverse(65537, (p - 1) * (q - 1)), N) print(long_to_bytes(m)) Week 2 smallModulus 这题很简单，只是过一层 proof of work​ 然后用 CRT 就可以拿到 flag，是想让大家熟悉一下远程的题目，写个自动的脚本，但是这题可以 nc 连上去手动拿 8 组数据出来，然后本地计算出flag\u0026hellip;\u0026hellip;\n爆破 pow 可以用 pwntools 的 mbruteforce() 函数来多线程爆，速度相对快很多。\nfrom pwn import * import hashlib import string from functools import reduce from Crypto.Util.number import* from gmpy2 import invert HOST = \u0026quot;xx.xxx.xxx.xx\u0026quot; PORT = 10000 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode() + suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) def CRT(a, m): Num = len(m) M = reduce(lambda x, y: x*y, m) Mi = [M // i for i in m] t = [invert(Mi[i], m[i]) for i in range(Num)] x = 0 for i in range(Num): x += a[i] * t[i] * Mi[i] return x % M def getData(): line = r.recvuntil(b\u0026quot;\u0026gt; \u0026quot;) r.sendline(b\u0026quot;1\u0026quot;) line = r.recvline().decode().strip() mod, res = int(line[9:25], 16), int(line[37:54], 16) return (mod, res) proof_of_work() m = [] a = [] for i in range(8): mod, res = getData() m.append(mod) a.append(res) flag = CRT(a, m) print(long_to_bytes(flag)) r.interactive() # 0xGame{3a8f45be-a0cf-457e-958e-b896056841d7} parityOracle RSA parity oracle 是一个经典的攻击，并且给出了 CTF Wiki 上相关部分的链接，我把模数改成了 4，理解一下就可以自己编写脚本解决这一题了。\n这是一个不断更新上下界来缩小范围逼近正确的明文值的过程，对不同余数下的上下界的更新需要分类讨论。\nfrom pwn import * from Crypto.Util.number import * HOST = \u0026quot;xx.xxx.xxx.xx\u0026quot; PORT = 10001 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) def getNum(c): r.sendline(b\u0026quot;1\u0026quot;) r.recvuntil(b\u0026quot;Your cipher (in hex): \u0026quot;) r.sendline(hex(c)[2:].encode()) return int(r.recvline().decode().strip()) proof_of_work() r.recvuntil(b\u0026quot;n = \u0026quot;) n = int(r.recvline().decode().strip()) r.recvuntil(b\u0026quot;c = \u0026quot;) c = int(r.recvline().decode().strip()) e = 65537 upper = n lower = 0 i = 1 while True: power = pow(4, i, n) new_c = (pow(power, e, n)*c) % n rev = getNum(new_c) if rev == 0: upper = (3 * lower + upper) // 4 elif rev == 1: temp = upper upper = (lower + upper) // 2 lower = (3 * lower + temp) // 4 elif rev == 2: temp = upper upper = (lower + 3 * upper) // 4 lower = (lower + temp) // 2 else: lower = (lower + 3 * upper) // 4 if (upper - lower) \u0026lt; 2: break i += 1 for i in range(100): if pow(lower + i, e, n) == c: print(long_to_bytes(lower + i)) break r.interactive() # 0xGame{a9abdec6-7b84-4443-afb8-ee4dada8bdca} Week 3 signinRSA 很简单的一题，发送密文，服务器会返回解密后的结果，只是不能发送flag的密文。\n没想到有两位学弟用 parityOracle 的脚本打。。。\n因为 $c\\cdot 2^e\\equiv m^e\\cdot 2^e\\equiv (2m)^e\\ mod\\ n$ 所以可以发送 $c\\cdot pow(2,e,n)$ 收到 $2m$，除 $2$ 得到 flag。\n有位学弟想到发送 -c，得到返回 -m，tql\neasyRSA 这题是给了 $x=11\\cdot d + 7\\cdot (p-1)\\cdot (q-1)$ ，我们知道 $e\\cdot d\\equiv 1\\ mod\\ (p-1)\\cdot (q-1)$ ，所以存在 $r$ 使\n$$ e\\cdot d= 1\\ +\\ r\\cdot(p-1)\\cdot (q-1) $$\n所以\n$$ x\\cdot e=11\\cdot e\\cdot d +7\\cdot e\\cdot \\phi(n)\\\\ x\\cdot e=11\\cdot (1+r\\cdot \\phi (n)) +7\\cdot e\\cdot \\phi(n)\\\\ x\\cdot e-11=(11\\cdot r+7\\cdot e)\\cdot \\phi (n) $$\n枚举 $r$ 即可得到 $\\phi(n)$ .\nfrom Crypto.Util.number import * n = 15321211041844905603734344178124947... c = 14896093236493033914781929755936872... x = 26506090189848554080676908570070818... e = 65537 kphi = x * e - 11 for r in range(e): k = 7 * e + 11 * r if kphi % k: continue phi = kphi // k if len(bin(n - phi + 1)[2:]) \u0026gt; 1025: continue print(long_to_bytes(pow(c, inverse(e, phi), n))) # 0xGame{cfac8284-3013-439b-8ff3-884decb642bb} paddingOracle 题目名称直接告诉了是 Padding Oracle Attack，学弟们也都学会并实现了这种攻击，网上资料也非常多，我就不详细写了（其实是因为懒）。\n这种攻击针对的是块加密的 CBC 模式，通过求得正确的中间值（Intermediary Value）并在最终和正确的向量异或得到明文。需要对密文分块从后往前破解，对于每一块，从最后一字节往前破解。\n对于一块需要破解的密文，需要先构造一个IV，并枚举IV的最后一字节，直到服务器告诉我们解密后的 padding 是正确的，将枚举到的这个字节的值和 padding 的值（\\x01）异或即可得到当前位置的中间值。然后更新IV的最后一字节（中间值最后一字节和\\x02异或）来保证枚举倒数第二字节的时候，倒数第一字节解密后的值是\\x02（这样爆破倒数第二字节的时候，只要服务器解密后倒数第二字节是\\x02就会 padding 正确）。\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from pwn import * HOST = \u0026quot;49.235.239.97\u0026quot; PORT = 10003 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode() + suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) proof_of_work() r.recvuntil(b\u0026quot;iv : \u0026quot;) iv = [long_to_bytes(int(r.recvline().decode().strip(), 16))] r.recvuntil(b\u0026quot;crypttext : \u0026quot;) crypttext = long_to_bytes(int(r.recvline().decode().strip(), 16)) blocks = [crypttext[i*16:i*16+16] for i in range(len(crypttext) // 16)] iv += blocks[:-1] flag = b\u0026quot;\u0026quot; for block in range(len(blocks)): mid_value = [] new_iv = bytearray(b\u0026quot;\\x00\u0026quot;*16) for i in range(16): for j in range(256): new_iv[15 - i] = j r.recvuntil(b\u0026quot;\u0026gt; \u0026quot;) r.sendline(b\u0026quot;1\u0026quot;) r.recvuntil(b\u0026quot;Your IV (in hex): \u0026quot;) r.sendline(new_iv.hex()) r.recvuntil(b\u0026quot;Your cipher (in hex): \u0026quot;) r.sendline(blocks[block].hex().encode()) data = r.recvline() if b\u0026quot;success\u0026quot; in data: ans = j ^ (i + 1) break mid_value.append(ans) for m in range(15 - i, 16): new_iv[m] = (i + 2) ^ mid_value[15 - m] find = \u0026quot;\u0026quot; for i in range(16): find += hex(iv[block][i] ^ mid_value[15 - i])[2:].rjust(2, '0') flag += long_to_bytes(int(find, 16)) print(flag) r.interactive() Week 4 littleTrick 逐字节构造服务器端的 flag，使服务器发送给我们的密文解密后只有一字节是我们未知的，所以我们只需要本地枚举一下这个字节，并在本地加密，本地的密文和服务器返回的密文一致的话，就说明爆破对了。\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from pwn import * HOST = \u0026quot;xx.xxx.xxx.xx\u0026quot; PORT = 10004 r = remote(HOST, PORT) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXXX+\u0026quot;) suffix = r.recv(16).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode() + suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, 'upto') r.recvuntil(\u0026quot;Give me XXXX:\u0026quot;) r.sendline(prefix) proof_of_work() r.recvuntil(b\u0026quot;n : \u0026quot;) n = int(r.recvline().decode().strip(), 16) e = 65537 flag = b\u0026quot;\u0026quot; for i in range(44): mask = b\u0026quot;1\u0026quot; * (44 - i - 1) print(mask) r.sendlineafter(b\u0026quot;\u0026gt; \u0026quot;, b\u0026quot;1\u0026quot;) r.sendlineafter(b\u0026quot;Your mask (in hex): \u0026quot;, hex(pow(bytes_to_long(mask), e, n))[2:].encode()) tar = int(r.recvline().decode().strip(), 16) for j in range(32, 128): guess = flag + long_to_bytes(j) + mask if pow(bytes_to_long(guess), e, n) == tar: flag += long_to_bytes(j) print(flag) break r.interactive() ElGamal 这题的考点是判断二次剩余，如果发现了y是二次剩余的话，那么只需要判断c1是否为二次剩余就可以了。\nfrom Crypto.Util.number import * y = 2101136318398982764494355697982735290351867853540128399809061806690701481465143258501856786165972388085070268979718711434744226290744692988395355120277617 g = 8401562798890834492298947403582806359769363301996138198850077614144023393945770711612546197987255078645962298286362268504959833530010137313108031112774451 p = 10946148224653120484646906462803901217745837751637974066354601688874051778651193811412739372059281847771491564589986518154039493312147458591216351424346123 datalist = [c.split(\u0026quot;, \u0026quot;) for c in open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;).read().split(\u0026quot;\\n\u0026quot;)[:-1]] flag = \u0026quot;\u0026quot;.join([\u0026quot;0\u0026quot; if pow(int(c[1], 16), (p - 1) // 2, p) == 1 else \u0026quot;1\u0026quot; for c in datalist]) print(long_to_bytes(int(flag, 2))) 如果y不是二次剩余的话，就需要多进行一层判断。\n这题改自 CVE-2018-6594\nfrom Crypto.Util.number import * f = open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;).read().split(\u0026quot;\\n\u0026quot;)[:-1] datalist = [c.split(\u0026quot;, \u0026quot;) for c in f] y = 2101136318398982764494355697982735290351867853540128399809061806690701481465143258501856786165972388085070268979718711434744226290744692988395355120277617 g = 8401562798890834492298947403582806359769363301996138198850077614144023393945770711612546197987255078645962298286362268504959833530010137313108031112774451 p = 10946148224653120484646906462803901217745837751637974066354601688874051778651193811412739372059281847771491564589986518154039493312147458591216351424346123 flag = \u0026quot;\u0026quot; for c in datalist: output = -1 if (pow(y, (p - 1) // 2, p) == 1) or (pow(int(c[0], 16), (p - 1) // 2, p) == 1): if pow(int(c[1], 16), (p - 1) // 2, p) == 1: flag += \u0026quot;0\u0026quot; else: flag += \u0026quot;1\u0026quot; else: if pow(int(c[1], 16), (p - 1) // 2, p) == 1: flag += \u0026quot;1\u0026quot; else: flag += \u0026quot;0\u0026quot; flag = long_to_bytes(int(flag, 2)) print(flag) ","permalink":"https://slightwind.cn/posts/ctf/0xgame-2020-crypto-problems/","summary":"0xGame2020是第一届0xGame比赛，时间持续一个月，面向零基础的新生。题目和exp可以在我的GitHub上找到：https://github.com/Am473ur/My-CTF-Challenge/tree/main/0xGame2020 ，这里记录一下出题人角度的 wp。\nWeek 1 Calendar 题目给了一张图片和一串逗号隔开的坐标信息，没看出来的话不难想到去百度一下“日历加密”，这题只是做了简单的修改。\nSAT1,THU1,MON3,MON2,WED3,SUN2,THU1,SUN4,FRI3,THU1,MON4,MON4,FRI4,THU3,SUN4,SUN2,TUE4,THU1,FRI1,MON3,MON2\n懒得百度的话，也不难看出前三个字母代表周一到周日，紧跟的数字范围是 1～4，所以他们代表两个坐标，列举出来并用a～z替换1～26，即可得到 flag。\neasyXor 做出这题只需要知道异或的逆运算还是异或，反过来跑一遍就拿到了flag。\nexp:\ncipher = [72, 63, 38, 12, 8, 30, 30, 6, 82, 4, 84, 88, 92, 7, 79, 29, 8, 90, 85, 26, 25, 87, 80, 10, 20, 20, 9, 4, 80, 73, 31, 5, 82, 0, 1, 92, 0, 0, 94, 81, 4, 85, 27, 35] flag = \u0026quot;\u0026quot; cipher += [ord(\u0026quot;^\u0026quot;)] for i in range(len(cipher)-1): flag = chr(cipher[len(cipher) - i - 2] ^ cipher[len(cipher) - i - 1]) + flag cipher[len(cipher) - i - 2] = ord(flag[0]) print(flag) # 0xGame{ec15a9eb-08b7-4c39-904d-27eed888f73f} 发现有的学弟跑完脚本手动补0，exp正确的话，是可以得到完整flag的。","title":"0xGame 2020 Crypto Problems"},{"content":"强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered\n然后看到里面提到可以这样获取 $p$：\n$$ \\large gcd(m^{c_1}-Sig^e,N)=p $$\n这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。\nfrom Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n // p flag = \u0026quot;flag{\u0026quot; + sha1(long_to_bytes(p if p \u0026lt; q else q)).hexdigest() + \u0026quot;}\u0026quot; print(flag) # flag{601cb6f6d990ed5b89cf0de60508a95c07543793} bank proof_of_work:\nfrom hashlib import sha256 from string import digits, ascii_letters from pwn import * r = remote(\u0026quot;39.101.134.52\u0026quot;, \u0026quot;8005\u0026quot;) def proof_of_work(): rev = r.recvuntil(\u0026quot;sha256(XXX+\u0026quot;) suffix = r.recv(17).decode() rev = r.recvuntil(\u0026quot; == \u0026quot;) tar = r.recv(64).decode() def f(x): hashresult = sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, digits + ascii_letters, 3, 'upto') r.recvuntil(\u0026quot;Give me XXX:\u0026quot;) r.sendline(prefix) def send_teamtoken(): r.recvuntil(\u0026quot;teamtoken:\u0026quot;) r.sendline(\u0026quot;icqc487d794f00cdb22409bd5ea7e736\u0026quot;) proof_of_work() send_teamtoken() r.interactive() 连上去过完 proof of work，输入一个字符串作为名字，会给出余额和菜单：\nyour cash:10 you can choose: transact, view records, provide a record, get flag, hint\n试了一下发现可以向某个商人交易，例如 Alice 1 向 Alice 支付，然后会通过 hint 里面的函数生成这次交易的记录，同时我们也可以给他发送一条记录来伪造一次交易。有了足够的余额（1000）就可以买 flag 了。\n但是，出题人好像没滤交易时的负数？然后\u0026hellip;.\n可以交易负金额可还行，就拿到了 flag。。。\nWeb dice2cry 题目描述：web+cry，输入team_token进入一个掷骰子的页面，在cookie可以看到encrypto_flag，public_n，public_e，应该是 RSA，然后每次掷骰子都会向abi.php get一次数据，abi.php也可以单独调用，相当于于一个随机返回 0～2 整数的 api，以 json 的形式返回值。然后有 js 来操作一下返回 1～6 的点数。\n然后可以在 http://106.14.66.189/abi.php.bak 拿到 abi.php 的源码：\n\u0026lt;?php session_start(); header(\u0026quot;Content-type:text/html;charset=utf-8\u0026quot;); $data = json_decode($json_string, true); $rand_number = isset($_POST['this_is.able']) ? $_POST['this_is.able'] : mt_ rand(); $n = gmp_init($data['n']); $d = gmp_init($data['d']); $c = gmp_init($rand_number); $m = gmp_powm($c,$d,$n); $v3 = gmp_init('3'); $r = gmp_mod($m,$v3); $result=(int)gmp_strval($r); $dice = array(\u0026quot;num\u0026quot;=\u0026gt;$result); $json_obj = json_encode($dice); echo $json_obj; ?\u0026gt; 如果没有 post 一个数字，$rand_number 就是随机的，否则就是 post 的那个数字，所以 $rand_number 是可控的。\n然后服务端会通过私钥 d 对 $rand_number 解密，并返回解密后模 3 的值，也就是一开始看到的 0～2 的“随机数”，所以这题显然是选择密文攻击，CTF wiki 上有关于 RSA parity oracle 原理的详细介绍，和这一题唯一的区别是 CTF wiki 上的是模 2。\n我们可以类比 CTF wiki 上的推理来对这题模三情况的推理，最终的思想是一样的，不断缩小上下界的范围逼近正确值。\nupper 和 lower 的初始值分别为 n 和 0，这是明文的范围。还要知道这一题的 n 模 3 得 2。\n第 $i$ 次，明文P的范围是：\n$$ \\frac { x N } { 3 ^ { i } } \\leq P \u0026lt; \\frac { x N + N } { 3 ^ { i } }.\\ \\ (\\ 1\\ ) $$\n第 $i+1$ 次，明文P的范围是：\n$$ \\frac { k N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { k N + N } { 3 ^ { i+1 } }.\\ \\ (\\ 2\\ ) $$\n对于不同的返回值（0～2），可以体现出 $k$ 模 3 后的特征（0～2）：\n$$ \\begin{cases} k=3y, \u0026amp;if\u0026amp;\\ k\\ \\equiv 0\\ (mod\\ 3),y\\in N^* \\\\ k=3y+1, \u0026amp;if\u0026amp;\\ k\\ \\equiv 1\\ (mod\\ 3),y\\in N^* \\\\ k=3y+2, \u0026amp;if\u0026amp;\\ k\\ \\equiv 2\\ (mod\\ 3),y\\in N^* \\end{cases} $$\n将不等式（1）分子分母同时乘 3，第 $i$ 次的：\n$$ \\frac { 3x N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3x N + 3N } { 3 ^ { i+1 } }.\\ \\ (\\ 3\\ ) $$\n如果返回 0，将 $k = 3y$ 带入 (2) 得：\n$$ \\frac { 3y N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3y N + N } { 3 ^ { i+1 } }.\\ \\ (\\ 4\\ ) $$\n由于P一定存在，所以（3）和（4）存在交集，所以 y = x，那么只需要更新上界“upper”：\nupper = (2*lower+upper)//3 如果返回 1，将 $k = 3y + 1$ 带入（2），\n$$ \\frac { 3y N+N } { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3y N + 2N } { 3 ^ { i+1 } }.\\ \\ (\\ 5\\ ) $$\n由于P一定存在，所以（3）和（5）存在交集，所以 $y = x$，那么需要同时更新上界和下界：\nupper = (lower+2*upper)//3; lower = (2*lower+upper)//3 如果返回 2，将 $k = 3y + 2$ 带入（2），\n$$ \\frac { 3y N +2N} { 3 ^ { i+1 } } \\leq P \u0026lt; \\frac { 3y N + 3N } { 3 ^ { i+1 } }.\\ \\ (\\ 6\\ ) $$\n由于P一定存在，所以（3）和（6）存在交集，所以 $y = x$，那么只需要更新下界“lower”：\nlower = (lower+2*upper)//3 这样每一次范围的更新都会缩小范围，最终逼近明文m。\nimport requests from Crypto.Util.number import* PHPSESSID = \u0026quot;jpa80o0gbpi4djabq80iopu7st\u0026quot; c = 47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274 n = 0x8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157 e = 0x10001 head = { 'User-Agent': \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\u0026quot; } cookies = {\u0026quot;PHPSESSID\u0026quot;: \u0026quot;jpa80o0gbpi4djabq80iopu7st\u0026quot;, \u0026quot;public_n\u0026quot;: \u0026quot;8f5dc00ef09795a3efbac91d768f0bff31b47190a0792da3b0d7969b1672a6a6ea572c2791fa6d0da489f5a7d743233759e8039086bc3d1b28609f05960bd342d52bffb4ec22b533e1a75713f4952e9075a08286429f31e02dbc4a39e3332d2861fc7bb7acee95251df77c92bd293dac744eca3e6690a7d8aaf855e0807a1157\u0026quot;, \u0026quot;public_e\u0026quot;: \u0026quot;010001\u0026quot;, \u0026quot;encrypto_flag\u0026quot;: \u0026quot;47901621682590941572620529757837523913923282588404656329721569362138054509808822622251355379677887022457532571566654200359453443547599919220729099865254694139150169466016053324444883650312695408132078436223779808465475540169329172223457636008422506025071303750315470905372763770412921709244110136409268083274\u0026quot;} r = requests.post(\u0026quot;http://106.14.66.189/main.php\u0026quot;, cookies=cookies, headers=head) def getNum(new_c): r = requests.post( \u0026quot;http://106.14.66.189/abi.php\u0026quot;, data={'this[is.able': new_c}, cookies=cookies, headers=head) print(r.text) return int(r.text[7]) upper = n lower = 0 i = 1 while True: # n % 3 == 2 power = pow(3, i, n) new_c = (pow(power, e, n) * c) % n # pow(3^{i}*m, e, n) rev = getNum(new_c) if rev == 0: # power * m mod n == 0 upper = (2 * lower + upper) // 3 elif rev == 1: # power * m mod n == (1 or 2) temp = upper upper = (lower + 2 * upper) // 3 lower = (2 * lower + temp) // 3 else: lower = (lower + 2 * upper) // 3 if (upper - lower) \u0026lt; 2: break i += 1 print(long_to_bytes(upper)) Crypto modestudy from Crypto.Util.number import * from string import digits, ascii_letters from binascii import unhexlify from hashlib import sha256 from pwn import * import os r = remote(\u0026quot;139.224.254.172\u0026quot;, \u0026quot;7777\u0026quot;) def proof_of_work(): # 多线程爆破 rev = r.recvuntil(\u0026quot;sha256(\u0026quot;) suffix = r.recvuntil(\u0026quot;+\u0026quot;)[:-1].decode() rev = r.recvuntil(\u0026quot;?=\u0026quot;) def f(x): hashresult = hashlib.sha256(suffix.encode()+x.encode()).digest() bits = ''.join(bin(j)[2:].zfill(8) for j in hashresult) return bits.startswith('0' * 5) prefix = util.iters.mbruteforce(f, digits + ascii_letters, 8, 'upto') r.sendline(prefix) def challenge1(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;session=\u0026quot;) session = r.recv(16) r.recvuntil(\u0026quot;checksum=\u0026quot;) checksum = r.recv(64) r.recvuntil(\u0026quot;cookie:\u0026quot;) plain = \u0026quot;session={};admin=0\u0026quot;.format(session) bit = ((unhexlify(checksum)[15]) ^ ord('0') ^ ord('1')) checksum = checksum.decode() checksum_final = checksum[:30] + hex(bit)[2:] + checksum[32:] newcookie = \u0026quot;session={};admin=1;checksum={}\u0026quot;.format( session.decode(), checksum_final) r.sendline(newcookie) def challenge2(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) r.recvuntil(\u0026quot;sha256(iv)=\u0026quot;) sha_iv = r.recv(64).decode() r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.sendline(\u0026quot;A\u0026quot; * 32) r.recvuntil(\u0026quot;[+] \u0026quot;) plain = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1] m0 = bytes.fromhex(plain[:32].decode()) m1 = bytes.fromhex(plain[32:].decode()) iv = long_to_bytes(bytes_to_long(m0) ^ bytes_to_long(m1) ^ bytes_to_long(b\u0026quot;A\u0026quot;*16)) r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) assert sha256(iv).hexdigest() == sha_iv r.sendline(iv.hex()) def challenge3(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;3\u0026quot;) r.recvuntil(\u0026quot;128bit_ecb_encrypt(cookie):\u0026quot;) cipher = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() cipher = bytearray.fromhex(cipher) for i in range(16): cipher[32 + i] = cipher[64 + i] r.sendline(cipher.hex()) def challenge4(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;4\u0026quot;) r.recvuntil(\u0026quot;sha256(secret)=\u0026quot;) sha_secret = r.recv(64).decode() secret = b\u0026quot;\u0026quot; for Byte in range(16): byte_len = (15 - (Byte % 16)) if ((Byte % 16) != 15) else 16 bound = ((byte_len + Byte + 1) // 16) * 32 r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;input(encode hex):\u0026quot;) r_ = os.urandom(byte_len) r.sendline(r_.hex()) r.recvuntil(\u0026quot;encrypted msg: \u0026quot;) C_ = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() print(\u0026quot;brute force {} byte\u0026quot;.format(Byte+1)) for i in range(256): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;input(encode hex):\u0026quot;) Pi = int((r_.hex()+secret.hex())[-30:]+long_to_bytes(i).hex(), 16) r.sendline(long_to_bytes(Pi).hex()) r.recvuntil(\u0026quot;encrypted msg: \u0026quot;) Ci = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() if Ci[:32] == C_[bound-32:bound]: secret += long_to_bytes(i) print(\u0026quot;Current secret: {}\u0026quot;.format(secret)) break r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) r.recvuntil(\u0026quot;secret(encode hex):\u0026quot;) r.sendline(secret.hex()) def challenge5(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;5\u0026quot;) r.recvuntil(\u0026quot;sha256(secret)=\u0026quot;) sha_secret = r.recv(64).decode() r.recvuntil(\u0026quot;(secret).encode(\\\u0026quot;hex\\\u0026quot;)=\u0026quot;) c = r.recv(32) secret = \u0026quot;\u0026quot; for i in range(8): part_c = c[i*4:i*4+4] guess = \u0026quot;\u0026quot; for j in range(0xffff): temp = \u0026quot;0\u0026quot; * (4 - len(hex(j)[2:])) + hex(j)[2:] guess += temp if len(guess) == 1024: # 由于向服务端发送接收时间成本较高，所以一次发送1024bits加快爆破速度 r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;1\u0026quot;) r.recvuntil(\u0026quot;input(encode hex):\u0026quot;) r.sendline(guess) r.recvuntil(\u0026quot;encode(\\\u0026quot;hex\\\u0026quot;):\u0026quot;) temp_c = r.recv(1024) flag = False for k in range(256): if temp_c[k*4:k*4+4] == part_c: secret += guess[k*4:k*4+4] flag = True break if flag: break guess = \u0026quot;\u0026quot; print(\u0026quot;Current secret:\u0026quot;, secret) r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;2\u0026quot;) r.recvuntil(\u0026quot;secret(encode hex):\u0026quot;) r.sendline(secret) def challenge6(): r.recvuntil(\u0026quot;your choice:\u0026quot;) r.sendline(\u0026quot;6\u0026quot;) r.recvuntil(\u0026quot;iv+aes128_cbc(key,iv,padding(secret)):\u0026quot;) iv_cbc = r.recvuntil(\u0026quot;\\n\u0026quot;)[:-1].decode() iv = bytearray.fromhex(iv_cbc[:32]) cbc = bytearray.fromhex(iv_cbc[32:64]) mid = [] new_iv = bytearray(b'\\x00' * 16) count = 1 for i in range(16): for j in range(256): new_iv[15 - i] = j upload = new_iv + cbc r.sendline('1') r.recvuntil(\u0026quot;input your iv+c (encode hex):\u0026quot;) r.sendline(upload.hex()) search = r.recvuntil(\u0026quot;your choice:\u0026quot;) if b\u0026quot;success\u0026quot; in search: print(search) ans = j ^ count break count += 1 mid.append(ans) for m in range(15 - i, 16): new_iv[m] = count ^ mid[15 - m] find = \u0026quot;\u0026quot; for i in range(16): find += hex(iv[i] ^ mid[15 - i])[2:].rjust(2, '0') r.sendline('2') r.recvuntil(\u0026quot;secret(encode hex):\u0026quot;) r.sendline(find) proof_of_work() r.recvuntil(\u0026quot;teamtoken=\u0026quot;) r.sendline(\u0026quot;icqc487d794f00cdb22409bd5ea7e736\u0026quot;) challenge1() challenge2() challenge3() challenge4() challenge5() challenge6() r.interactive() # 这边再输入7得到flag # icqc487d794f00cdb22409bd5ea7e736 # flag{86ac04cc901a04462c55923eedf5affe} ","permalink":"https://slightwind.cn/posts/ctf/writeup-for-qwb-2020/","summary":"强网先锋 baby_crt 考点是 CRT-RSA，找到一篇paper：Wagner’s Attack on a Secure CRT-RSA Algorithm Reconsidered\n然后看到里面提到可以这样获取 $p$：\n$$ \\large gcd(m^{c_1}-Sig^e,N)=p $$\n这个题目只有 $c_1$ 没有给出，但是很小，可以直接爆破。\nfrom Crypto.Util.number import * from hashlib import sha1 e = 65537 n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997 m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540 sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246 for c1 in range(1, 65536): p = GCD(pow(m, c1, n) - pow(sig, e, n), n) if p == 1: continue print(p) break q = n // p flag = \u0026quot;flag{\u0026quot; + sha1(long_to_bytes(p if p \u0026lt; q else q)).","title":"Writeup for 强网杯 2020"},{"content":"piece_of_cake 两个函数大概都是一个类似 RSA 的操作，加上一个加密算法，之前的一篇博客有介绍，\nAn Introduction to Mathematical Cryptography 书里称这个算法是 “a toy model of a real public key cryptosystem”。（bitlength 凑的刚刚好可以保证解密，很巧妙）\nmake_cake() 这边的 cake 很小（256bits）符合正常解密的条件，可以直接用高斯格基规约算法，然而 eat_cake() 这边的 cake 是比较大的（768bits）就会导致在取模的时候值容易发生改变，所以给它加上几个 g，并使用给出的 pow 来验证是否是正确的 cake。\n规约得到的密钥对 $(F, G)$ 是不一定等于原来的密钥对 $(f, g)$，但它们在解密过程是等价的，我们得到的密钥对 (F, G) 长度都是 768bits。\nexp 多跑几次就能得到 flag。\nfrom gmpy2 import iroot, sqrt, invert from pwn import remote from string import ascii_letters, digits from hashlib import sha256 r = remote('170.106.35.18', 8631) def proof_of_work(txt, Hash): for a in ascii_letters+digits: for b in ascii_letters+digits: for c in ascii_letters+digits: if sha256((a+b+c+txt).encode()).hexdigest() == Hash: return a+b+c def gaussian(v1, v2): while True: if sqrt(v2[0]**2 + v2[1]**2) \u0026lt; sqrt(v1[0]**2 + v1[1]**2): v1, v2 = v2, v1 m = int((v1[0]*v2[0] + v1[1]*v2[1]) / (v1[0]**2 + v1[1]**2)) if m == 0: return (v1, v2) v2 = [v2[0] - m * v1[0], v2[1] - m * v1[1]] r.recvuntil(\u0026quot;XXX+\u0026quot;) nonce = r.recv(17).decode() r.recvuntil(\u0026quot; == \u0026quot;) target = r.recv(64).decode() r.recvuntil(\u0026quot;\\nGive me XXX:\u0026quot;) w = proof_of_work(nonce, target) r.send(str(w)+\u0026quot;\\n\u0026quot;) r.recvuntil(\u0026quot;What's your choice?\\n\u0026quot;) r.send(\u0026quot;1\\n\u0026quot;) r.recvline() temp = r.recvline().strip().decode().split(\u0026quot; \u0026quot;) q, h, c = [int(i) for i in temp] N = int(r.recvline().strip().decode()) cip = int(r.recvline().strip().decode()) s1, s2 = gaussian([1, h], [0, q]) f, g = s1[0], s1[1] cake = (c * f % q) % g cake = invert(f, g) * cake % g for k in range(10000): if pow(cake, 0x10001, N) == cip: print(\u0026quot;cake is: \u0026quot;, cake) break cake += g r.send(str(cake) + \u0026quot;\\n\u0026quot;) print(r.recvline().strip().decode()) #WMCTF{Wh4t_A_pi3ce_of_CAKE!} babySum 密度接近 0.8 的子集和问题（Subset sum problem），BKZ-24 跑得比较慢好在成功率高一点。\nfrom json import load def check(sol, A): s = 0 for x, a in zip(sol, A): s += x * a return s k, n, d = 20, 120, 0.8 s, A = load(open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;)) N = 50 lat = [] for i, a in enumerate(A): lat.append([1 * (j == i) for j in range(n)] + [N * a] + [N]) lat.append([0] * n + [N * s] + [k * N]) itr = 0 while True: itr += 1 print(itr) nums = lat[::] shuffle(nums) m = matrix(ZZ, nums) ml = m.BKZ(block_size=24) for i, row in enumerate(ml): if not (-1 \u0026lt;= min(row[:-1]) and max(row[:-1]) \u0026lt;= 1): continue for i in range(len(row)): if row[i] \u0026lt; 0: row[i] *= -1 temp_bool = (check(row, A) == s) if temp_bool == True: print(i, row) quit() #0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 到 check.py 里面运行输入得到 flag：WMCTF{83077532752999414286785898029842440}\nGame 对 AES 选择明文攻击，逐个字节爆破。\nCBC 模式的 AES 加密，块长度为 b，C0 是初始向量 IV，IV 是和服务器端同步的最新的加密向量。\nIV 始终和服务器端的 IV 同步，用来消除掉当前加密的一次异或，再用 C0 异或一下就构造出了 Step2 的加密结果的第一个 block。所以爆破一个 byte 最多会和服务器交互 256 次，不过平均下来约 128 次得到一个 byte。\n以 16bytes 块长度为例，让服务器把已知的 15bytes 的 r 和未知部分的前 1byte 拼起来加密，然后本地去枚举最后一个 byte 和 15bytes 拼起来发送到服务器加密，如果加密后的第一个块和在服务器端拼起来的那段是相等的，就说明猜对了。就多知道了一个 secret 的 byte，把它当作已知，再进行下一个 byte 的枚举。\nfrom pwn import remote from hashlib import sha256 from Crypto.Util.number import * import string import os r = remote('81.68.174.63', 16442) def proof_of_work(txt, Hash): S = string.ascii_letters + string.digits for a in S: for b in S: for c in S: for d in S: if sha256((a + b + c + d + txt).encode()).hexdigest() == Hash: print(a + b + c + d) return a + b + c + d def select_x(x): r.recvuntil(\u0026quot;3. exit\\n\u0026quot;) r.recvuntil(\u0026quot;\u0026gt;\u0026quot;) r.send(str(x)) r.recvuntil(\u0026quot;(in hex): \u0026quot;) r.recvuntil(\u0026quot;XXXX+\u0026quot;) nonce = r.recv(16).decode() r.recvuntil(\u0026quot; == \u0026quot;) target = r.recv(64).decode() print(\u0026quot;waiting....\u0026quot;) w = proof_of_work(nonce, target) r.send(str(w)) print(\u0026quot;----------proof of work is ok!----------\u0026quot;) r.recvuntil(\u0026quot;IV is: \u0026quot;) IV = r.recv(32).decode() # 16 bytes -\u0026gt; 32 hexlength print(\u0026quot;IV is: {}\u0026quot;.format(IV)) secret = b\u0026quot;\u0026quot; for Byte in range(48): byte_len = (15 - (Byte % 16)) if ((Byte % 16) != 15) else 16 bound = ((byte_len + Byte + 1) // 16) * 32 select_x(1) r_ = os.urandom(byte_len) r.send(r_.hex()) C_ = r.recvline().strip().decode() C0 = IV if bound == 32 else C_[bound-64:bound-32] IV = C_[-32:] print(\u0026quot;brute force {} byte\u0026quot;.format(Byte+1)) for i in range(256): select_x(1) Pi = int(C0, 16) ^ int(IV, 16) ^ int((r_.hex() + secret.hex())[-30:] + long_to_bytes(i).hex(), 16) r.send(long_to_bytes(Pi).hex()) Ci = r.recvline().strip().decode() IV = Ci[-32:] if Ci[:32] == C_[bound-32:bound]: secret += long_to_bytes(i) print(\u0026quot;Current secret: {}\u0026quot;.format(secret)) break print(\u0026quot;secret is: {}\u0026quot;.format(secret)) select_x(2) r.send(secret.hex()) flag = r.recvline().strip().decode() print(flag) ","permalink":"https://slightwind.cn/posts/ctf/writeup-for-crypto-problems-in-wmctf-2020/","summary":"piece_of_cake 两个函数大概都是一个类似 RSA 的操作，加上一个加密算法，之前的一篇博客有介绍，\nAn Introduction to Mathematical Cryptography 书里称这个算法是 “a toy model of a real public key cryptosystem”。（bitlength 凑的刚刚好可以保证解密，很巧妙）\nmake_cake() 这边的 cake 很小（256bits）符合正常解密的条件，可以直接用高斯格基规约算法，然而 eat_cake() 这边的 cake 是比较大的（768bits）就会导致在取模的时候值容易发生改变，所以给它加上几个 g，并使用给出的 pow 来验证是否是正确的 cake。\n规约得到的密钥对 $(F, G)$ 是不一定等于原来的密钥对 $(f, g)$，但它们在解密过程是等价的，我们得到的密钥对 (F, G) 长度都是 768bits。\nexp 多跑几次就能得到 flag。\nfrom gmpy2 import iroot, sqrt, invert from pwn import remote from string import ascii_letters, digits from hashlib import sha256 r = remote('170.106.35.18', 8631) def proof_of_work(txt, Hash): for a in ascii_letters+digits: for b in ascii_letters+digits: for c in ascii_letters+digits: if sha256((a+b+c+txt).","title":"Writeup for Crypto problems in WMCTF 2020"},{"content":"Crypto RSA 同一个解密指数用了三次加密同一段明文，这本书第129页介绍了 Common Private Exponent Attack：\nCRYPTANALYSIS OF RSA AND ITS VARIANTS\n这题的情况和里面的样例是一样的，可以直接套用这个格子然后LLL即可算出d：\nfrom binascii import hexlify, unhexlify e0 = 0x9a7dc3e0f2a3531035b18541df28b8407502c2101970862d19b107ea7dc37554e5ac620b3ce4be38e5d6fd6b1920aef9e017aa383e3c1dd8e7847dc7715832fa450d1b572cfe133c702c598ed022d40ad193608bcfeb9b9aebc910dd3257caa42e503764475b89bb99056822e21ba5723d9eee3196a6fca3debd1c7687fd310d n0 = 0xa98c363cf72b3bce39bae63a9d3d5ba0acaa7e81f9b1191ce20bb0b54a8c19216d20af640121c482e882c0772671280af9f42c764128a94104266dd65c0bcd93766e0f0ce119072302b7f3e5cc4b5cfece38e4124041a8f8dcbdb9193f35bede2c284e40f80398bf0ba0609229fa27faa2d51c552ff1ed911a6f6f220b7b6fed c0 = 0x57fcf94d27451fc35386e0f6eff53c6540ccff51862c992f4b59d0d49fa350493041c5be2f54a37f3afe81aa5e9a738461b3b709a4611a7289c83d769cb02f3c5d18e65d68f6fff1df0418c8a7351be1d7cce1a7514797c9bdc67d969224d783a5d004d67a5ef986d564ab1945e5c83a53d8d1dcb5e45323764a200e737b80c e1 = 0xbb31e6433057edfed88b6a37e4419a828d1575b2b9d04a5058cd912d5efb06b2f0c5c06c5d0dd35ebeda8afa8a9cc945c244c13fc501c76e720c2c04cab70c9f906c4a810defdd84c3a38507cdf79b4e4b0c7770cc3d2d862ea9bd5fe2469290d9d2a09c8164437e9d5b7b3a9c49d111e5caa9577f8ed1ef1916ec4cb71bbb8d n1 = 0xbcc2c4f4f51abb236b411f1f9d86d71133eb2d4ffe45a319b6ab6df1174b9ee619e696666702655b6c185735298cc008e9b7df842c480d3d42bb67228b6c7408a7afe68ab85ee1c80f43c8c52764c79ffdecc6e3a5ea76c1123affe9f02c649e5f5ca0a4082107ce4a2040e5756bf6a2b34757aefa5fb6fec6d7a9e86f0c8159 c1 = 0xacf91d2b6a300a60193485ef2e1127b5863c69da71ab9e7d71a3213e960a73e42f8e8031bf0ef20184ae0a259fd50260aacce06546af2f8bbef8a2f360c8f7511ad9c99d8715012ce0a4fa8dbba8c10d74f477156076bdfda80dc449eec3b45c7cd82802ecce7635e186d29744df04fcf812dc7e2d2f3c8cd751e4fcea43db1e e2 = 0x332f82f338c8b84524103d310d59fc541b66705948c57eaf972b26bb209a6ddde3d6930948a559ac1a3a26790cb1a133a90b999b164d4e22014b27660dad4e5639ffc19bcd2e4961c5b00b9116f49c3c02880bb3ad32972287442d6a86a9c86cd3981ee1084df4322edb9c5da39146e10de0586c8b5433a851d649a45c5a73cd n2 = 0xd0ad4d11576bb041ea2ce53f354dba362a93411a37f4a529e8b5eeae83a3437df6bd5e4e1f87a4d324a6ce2850f3568c929f5d5f73fef45bda03fa7bff00304a1eb833ce3535ee3552aa62b644f0d3c1679fe2c57b978c695f03e5b2d18d9b0821c7e0ca332f552b12e2b7109210d051bbe9d9b9e3cc3b16c81e77ebca65aca3 c2 = 0xc59078ae7cb454c970f272f595da71ae2b681156a1ce7112d9b96346f38bcdca87192ea39ac273851210e9f98f0d89f1bc657ce69ca14708cba8b319160a1f67b8cfc3643dc9b6a70769d8d64a9a3504d799f3d9afca7c7114880f4ccb5bef35738e660e4ede1c884f4a60f1f0e559fb754abd8e4b905ad3626a876bea43ec8e M = isqrt(max(n0, n1, n2)) M = 10704523536419069847275584063070587220303695362157261593514212717132031073368631333467085885236049291630529090309346493924305038011673707087598638071644281 B = matrix(ZZ, [ [M, e0, e1, e2], [0, -n0, 0, 0], [0, 0, -n1, 0], [0, 0, 0, -n2], ]) BL = B.LLL() temp = int(BL[0, 0]) if temp \u0026lt; 0: temp *= -1 d = int(temp // M) m = hex(pow(c2, d, n2))[2:] print(unhexlify(m)) print(d) #b'SCTF{673ff064da31c0d7aee56884b01a09}' #1235666648165896286568418878956456259719846117790808720561608081687435539909970845494445047046945948132187344353861 Lattice 这题是109维的NTRU加密，在An Introduction to Mathematical Cryptography书里有介绍使用格基规约攻击NTRU的算法，如图构建一个格子，然后进行约减，一开始用LLL，没有找到合适的约减基，然后用BKZ-24很容易找到了，可能由于格比较稀疏，尽管格子相当于是218维，测试了BKZ-32都可以在20秒之内规约完成，取约减后的最短向量，就得到了 $f\u0026rsquo;$ 和 $g\u0026rsquo;$（前 $n$ 位是 $f\u0026rsquo;$，后 $n$ 位 $g\u0026rsquo;$）。\n用得到的 $f\u0026rsquo;$ 进行NTRU解密得到的明文应该是一个01串，在头部补合适数量的0变成全部可打印字符就是flag了。\nZx.\u0026lt;x\u0026gt; = ZZ[] n = 109 q = 2048 p = 3 pub_key = 510*x ^ 108 - 840*x ^ 107 - 926*x ^ 106 - 717*x ^ 105 - 374*x ^ 104 - 986*x ^ 103 + 488*x ^ 102 + 119*x ^ 101 - 247*x ^ 100 + 34*x ^ 99 + 751*x ^ 98 - 44*x ^ 97 - 257*x ^ 96 - 749*x ^ 95 + 648*x ^ 94 - 280*x ^ 93 - 585*x ^ 92 - 347*x ^ 91 + 357*x ^ 90 - 451*x ^ 89 - 15*x ^ 88 + 638*x ^ 87 - 624*x ^ 86 - 458*x ^ 85 + 216*x ^ 84 + 36*x ^ 83 - 199*x ^ 82 - 655*x ^ 81 + 258*x ^ 80 + 845*x ^ 79 + 490*x ^ 78 - 272*x ^ 77 + 279*x ^ 76 + 101*x ^ 75 - 580*x ^ 74 - 461*x ^ 73 - 614*x ^ 72 - 171*x ^ 71 - 1012*x ^ 70 + 71*x ^ 69 - 579*x ^ 68 + 290*x ^ 67 + 597*x ^ 66 + 841*x ^ 65 + 35*x ^ 64 - 545*x ^ 63 + 575*x ^ 62 - 665*x ^ 61 + 304*x ^ 60 - 900*x ^ 59 + 428*x ^ 58 - 992*x ^ 57 - 241*x ^ 56 + 953*x ^ 55 - 784*x ^ 54 - 730*x ^ 53 - 317*x ^ 52 + 108*x ^ 51 + 180*x ^ 50 - 881*x ^ 49 - 943*x ^ 48 + 413*x ^ 47 - 898*x ^ 46 + 453*x ^ 45 - 407*x ^ 44 + 153*x ^ 43 - 932*x ^ 42 + 262*x ^ 41 + 874*x ^ 40 - 7*x ^ 39 - 364*x ^ 38 + 98*x ^ 37 - 130*x ^ 36 + 942*x ^ 35 - 845*x ^ 34 - 890*x ^ 33 + 558*x ^ 32 - 791*x ^ 31 - 654*x ^ 30 - 733*x ^ 29 - 171 * x ^ 28 - 182*x ^ 27 + 644*x ^ 26 - 18*x ^ 25 + 776*x ^ 24 + 845*x ^ 23 - 675*x ^ 22 - 741*x ^ 21 - 352*x ^ 20 - 143*x ^ 19 - 351*x ^ 18 - 158*x ^ 17 + 671*x ^ 16 + 609*x ^ 15 - 34*x ^ 14 + 811*x ^ 13 - 674*x ^ 12 + 595*x ^ 11 - 1005*x ^ 10 + 855*x ^ 9 + 831*x ^ 8 + 768*x ^ 7 + 133*x ^ 6 - 436*x ^ 5 + 1016 * x ^ 4 + 403*x ^ 3 + 904*x ^ 2 + 874*x + 248 e = -453*x ^ 108 - 304*x ^ 107 - 380*x ^ 106 - 7*x ^ 105 - 657*x ^ 104 - 988*x ^ 103 + 219*x ^ 102 - 167*x ^ 101 - 473*x ^ 100 + 63*x ^ 99 - 60*x ^ 98 + 1014*x ^ 97 - 874*x ^ 96 - 846*x ^ 95 + 604*x ^ 94 - 649*x ^ 93 + 18*x ^ 92 - 458*x ^ 91 + 689*x ^ 90 + 80*x ^ 89 - 439*x ^ 88 + 968*x ^ 87 - 834*x ^ 86 - 967*x ^ 85 - 784*x ^ 84 + 496*x ^ 83 - 883*x ^ 82 + 971*x ^ 81 - 242*x ^ 80 + 956*x ^ 79 - 832*x ^ 78 - 587*x ^ 77 + 525*x ^ 76 + 87*x ^ 75 + 464*x ^ 74 + 661*x ^ 73 - 36*x ^ 72 - 14*x ^ 71 + 940*x ^ 70 - 16*x ^ 69 - 277*x ^ 68 + 899*x ^ 67 - 390*x ^ 66 + 441*x ^ 65 + 246*x ^ 64 + 267*x ^ 63 - 395*x ^ 62 + 185*x ^ 61 + 221*x ^ 60 + 466*x ^ 59 + 249*x ^ 58 + 813*x ^ 57 + 116*x ^ 56 - 100 * x ^ 55 + 109*x ^ 54 + 579*x ^ 53 + 151*x ^ 52 + 194*x ^ 51 + 364*x ^ 50 - 413*x ^ 49 + 614*x ^ 48 + 367*x ^ 47 + 758*x ^ 46 + 460*x ^ 45 + 162*x ^ 44 + 837*x ^ 43 + 903*x ^ 42 + 896*x ^ 41 - 747*x ^ 40 + 410*x ^ 39 - 928*x ^ 38 - 230*x ^ 37 + 465*x ^ 36 - 496*x ^ 35 - 568*x ^ 34 + 30*x ^ 33 - 158*x ^ 32 + 687*x ^ 31 - 284*x ^ 30 + 794*x ^ 29 - 606 * x ^ 28 + 705*x ^ 27 - 37*x ^ 26 + 926*x ^ 25 - 602*x ^ 24 - 442*x ^ 23 - 523*x ^ 22 - 260*x ^ 21 + 530*x ^ 20 - 796*x ^ 19 + 443*x ^ 18 + 902*x ^ 17 - 210*x ^ 16 + 926*x ^ 15 + 785*x ^ 14 + 440*x ^ 13 - 572*x ^ 12 - 268*x ^ 11 - 217*x ^ 10 + 26*x ^ 9 + 866*x ^ 8 + 19*x ^ 7 + 778*x ^ 6 + 923*x ^ 5 - 197 * x ^ 4 - 446*x ^ 3 - 202*x ^ 2 - 353*x - 852 pub_key_coeffs = pub_key.coefficients() def mul(f, g): return (f * g) % (x ^ n-1) def bal_mod(f, q): g = list(((f[i] + q // 2) % q) - q // 2 for i in range(n)) return Zx(g) def inv_mod_prime(f, p): T = Zx.change_ring(Integers(p)).quotient(x ^ n - 1) return Zx(lift(1 / T(f))) M_h = Matrix(n * 2, n * 2, 0) for i in range(n): M_h[i, i], M_h[n + i, n + i] = 1, q for j in range(n): M_h[i, n + j] = pub_key_coeffs[j] pub_key_coeffs.insert(0, pub_key_coeffs.pop()) M_r = M_h.BKZ(block_size=24) t = [i for i in M_r[0]] f, g = Zx(t[:n]), Zx(t[n:]) fp = inv_mod_prime(f, p) a = bal_mod(mul(f, e), q) m = bal_mod(mul(fp, a), p) for k in range(8): flag = k * \u0026quot;0\u0026quot; + \u0026quot;\u0026quot;.join([str(i) for i in m.list()]) flag += (8 - len(flag) % 8) * \u0026quot;0\u0026quot; temp = \u0026quot;\u0026quot; for i in range(len(flag) // 8): temp += chr(int(flag[i*8:i*8+8], 2)) print(temp) flag：SCTF{@#26f35b89d3#@}\nMisc Can you hear 用MMSSTV，可以直接看到flag: SCTF{f78fsd1423fvsa}\neasymisc 倒序补上文件头得到可以正常显示的图片（又是熟悉的这个男人），图片上有flag{that_is_not_right_man}。\nfrom binascii import hexlify,unhexlify data = hexlify(open(\u0026quot;galf_si_erehw.jpg\u0026quot;,\u0026quot;rb\u0026quot;).read()) open(\u0026quot;where_is_flag.jpg\u0026quot;,\u0026quot;wb\u0026quot;).write(unhexlify(data[::-1])) 然后winhex打开可以看到一堆字符串，提示用RC4解密密文xoBTuw36SfH4hicvCzFD9ESj，密钥就是图片上花括号里的字符串，找网站在线解密就可以得到flag：SCTF{St@Y_@T_H0Me}\n","permalink":"https://slightwind.cn/posts/ctf/writeup-for-crypto-problems-in-sctf-2020/","summary":"Crypto RSA 同一个解密指数用了三次加密同一段明文，这本书第129页介绍了 Common Private Exponent Attack：\nCRYPTANALYSIS OF RSA AND ITS VARIANTS\n这题的情况和里面的样例是一样的，可以直接套用这个格子然后LLL即可算出d：\nfrom binascii import hexlify, unhexlify e0 = 0x9a7dc3e0f2a3531035b18541df28b8407502c2101970862d19b107ea7dc37554e5ac620b3ce4be38e5d6fd6b1920aef9e017aa383e3c1dd8e7847dc7715832fa450d1b572cfe133c702c598ed022d40ad193608bcfeb9b9aebc910dd3257caa42e503764475b89bb99056822e21ba5723d9eee3196a6fca3debd1c7687fd310d n0 = 0xa98c363cf72b3bce39bae63a9d3d5ba0acaa7e81f9b1191ce20bb0b54a8c19216d20af640121c482e882c0772671280af9f42c764128a94104266dd65c0bcd93766e0f0ce119072302b7f3e5cc4b5cfece38e4124041a8f8dcbdb9193f35bede2c284e40f80398bf0ba0609229fa27faa2d51c552ff1ed911a6f6f220b7b6fed c0 = 0x57fcf94d27451fc35386e0f6eff53c6540ccff51862c992f4b59d0d49fa350493041c5be2f54a37f3afe81aa5e9a738461b3b709a4611a7289c83d769cb02f3c5d18e65d68f6fff1df0418c8a7351be1d7cce1a7514797c9bdc67d969224d783a5d004d67a5ef986d564ab1945e5c83a53d8d1dcb5e45323764a200e737b80c e1 = 0xbb31e6433057edfed88b6a37e4419a828d1575b2b9d04a5058cd912d5efb06b2f0c5c06c5d0dd35ebeda8afa8a9cc945c244c13fc501c76e720c2c04cab70c9f906c4a810defdd84c3a38507cdf79b4e4b0c7770cc3d2d862ea9bd5fe2469290d9d2a09c8164437e9d5b7b3a9c49d111e5caa9577f8ed1ef1916ec4cb71bbb8d n1 = 0xbcc2c4f4f51abb236b411f1f9d86d71133eb2d4ffe45a319b6ab6df1174b9ee619e696666702655b6c185735298cc008e9b7df842c480d3d42bb67228b6c7408a7afe68ab85ee1c80f43c8c52764c79ffdecc6e3a5ea76c1123affe9f02c649e5f5ca0a4082107ce4a2040e5756bf6a2b34757aefa5fb6fec6d7a9e86f0c8159 c1 = 0xacf91d2b6a300a60193485ef2e1127b5863c69da71ab9e7d71a3213e960a73e42f8e8031bf0ef20184ae0a259fd50260aacce06546af2f8bbef8a2f360c8f7511ad9c99d8715012ce0a4fa8dbba8c10d74f477156076bdfda80dc449eec3b45c7cd82802ecce7635e186d29744df04fcf812dc7e2d2f3c8cd751e4fcea43db1e e2 = 0x332f82f338c8b84524103d310d59fc541b66705948c57eaf972b26bb209a6ddde3d6930948a559ac1a3a26790cb1a133a90b999b164d4e22014b27660dad4e5639ffc19bcd2e4961c5b00b9116f49c3c02880bb3ad32972287442d6a86a9c86cd3981ee1084df4322edb9c5da39146e10de0586c8b5433a851d649a45c5a73cd n2 = 0xd0ad4d11576bb041ea2ce53f354dba362a93411a37f4a529e8b5eeae83a3437df6bd5e4e1f87a4d324a6ce2850f3568c929f5d5f73fef45bda03fa7bff00304a1eb833ce3535ee3552aa62b644f0d3c1679fe2c57b978c695f03e5b2d18d9b0821c7e0ca332f552b12e2b7109210d051bbe9d9b9e3cc3b16c81e77ebca65aca3 c2 = 0xc59078ae7cb454c970f272f595da71ae2b681156a1ce7112d9b96346f38bcdca87192ea39ac273851210e9f98f0d89f1bc657ce69ca14708cba8b319160a1f67b8cfc3643dc9b6a70769d8d64a9a3504d799f3d9afca7c7114880f4ccb5bef35738e660e4ede1c884f4a60f1f0e559fb754abd8e4b905ad3626a876bea43ec8e M = isqrt(max(n0, n1, n2)) M = 10704523536419069847275584063070587220303695362157261593514212717132031073368631333467085885236049291630529090309346493924305038011673707087598638071644281 B = matrix(ZZ, [ [M, e0, e1, e2], [0, -n0, 0, 0], [0, 0, -n1, 0], [0, 0, 0, -n2], ]) BL = B.","title":"Writeup for Crypto problems in SCTF 2020"},{"content":"NLFSR task.py\nfrom flag import a, b, c, d, flag assert flag == \u0026quot;De1CTF{\u0026quot; + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \u0026quot;}\u0026quot; assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6] ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i \u0026amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do def genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\u0026quot;data\u0026quot;, \u0026quot;w+\u0026quot;).write(s) genkey(128 * 1024) LFSR部分把r左移一位，m和r二进制值共同为1位数的奇偶决定空位补1或0。\n每次combine()会把4个LFSR进行一些运算，最终只会返回1bit值，通过这1bit的信息我们可以把ao，bo，co，do的状态分成两类：\ndef test(tar): for ao in [0, 1]: for bo in [0, 1]: for co in [0, 1]: for do in [0, 1]: if (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do == tar: print(\u0026quot;ao={},bo={},co={},do={}\u0026quot;.format(ao, bo, co, do)) test(0) combine()返回0时对应的8个状态：\nao=0,bo=0,co=0,do=0 ao=0,bo=0,co=1,do=1 ao=0,bo=1,co=0,do=0 ao=0,bo=1,co=0,do=1 ao=0,bo=1,co=1,do=0 ao=0,bo=1,co=1,do=1 ao=1,bo=0,co=0,do=0 ao=1,bo=0,co=1,do=1 combine()返回1时对应的8个状态：\nao=0,bo=0,co=0,do=1 ao=0,bo=0,co=1,do=0 ao=1,bo=0,co=0,do=1 ao=1,bo=0,co=1,do=0 ao=1,bo=1,co=0,do=0 ao=1,bo=1,co=0,do=1 ao=1,bo=1,co=1,do=0 ao=1,bo=1,co=1,do=1 CTF wiki上有一个类似的题:\nhttps://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/nfsr/\n可以看到这题也是有75%的概率combine()返回值和ao的值相等，可以从这里爆破a。\nma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) f = open(\u0026quot;data\u0026quot;, \u0026quot;r\u0026quot;) S = f.read() S = S[:100] # 为了提高一点效率，可以先从小的开始尝试，找不到合适的就改一改 def bruteforce(): for a in range(2**18, 2**19): a_tmp = a cnt = 0 for i in S: a_tmp = lfsr(a_tmp, ma) if a_tmp \u0026amp; 1 == int(i): cnt += 1 if cnt / len(S) \u0026gt; 0.7: # 这里也是慢慢改着算的...会有多个输出，然后把概率提高到0.74-0.76，逐个验证一下 print(a) print(cnt / len(S)) bruteforce() 现在很容易得到了a的值363445，现在通过类似的方法可以枚举b，观察上面两组状态，可以看到有75%的概率 combine() 返回值和 ao, bo 的同或值（相同为真，相异为假）相等。\na = 363445 ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) f = open(\u0026quot;data\u0026quot;,\u0026quot;r\u0026quot;) S = f.read() S = S[:100]#为了提高一点效率，可以先从小的开始尝试，找不到合适的就改一改 def bruteforce(): for b in range(2**18, 2**19): a_tmp, b_tmp = a, b cnt = 0 for i in S: tmp = 0 a_tmp = lfsr(a_tmp, ma) b_tmp = lfsr(b_tmp, mb) if (a_tmp \u0026amp; 1) == (b_tmp \u0026amp; 1): # 同或关系 tmp = 1 else: tmp = 0 if tmp == int(i): cnt += 1 if cnt / len(S) \u0026gt; 0.7: # 这里也是慢慢改着算的...会有多个输出，然后把概率提高到0.74-0.76，逐个验证一下 print(b) print(cnt / len(S)) bruteforce() 改一改就可以用来枚举b了，从输出中逐个验证，得到494934。\na和b都知道了，c和d比较小可以直接爆破了，一共刚好也是2^19bits。\na = 363445 b = 494934 ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) f = open(\u0026quot;data\u0026quot;,\u0026quot;r\u0026quot;) S = f.read() S = S[:100] # 为了提高一点效率，可以先从小的开始尝试，找不到合适的就改一改 def bruteforce(): global a,b for c in range(4096, 8192): for d in range(32, 64): cnt = 0 a_tmp, b_tmp, c_tmp, d_tmp = a, b, c, d for i in S: a_tmp = lfsr(a_tmp, ma) b_tmp = lfsr(b_tmp, mb) c_tmp = lfsr(c_tmp, mc) d_tmp = lfsr(d_tmp, md) [ao, bo, co, do] = [t \u0026amp; 1 for t in [a_tmp, b_tmp, c_tmp, d_tmp]] if int(i) == (bo * ao) ^ (bo * co) ^ (bo * do) ^ co ^ do: cnt += 1 if cnt / len(S) == 1: # 这里可以要求的很严格了，当然要100%满足 print(c) print(d) return bruteforce() 得到 d = 4406，c = 63。\na = 363445, b = 494934, c = 4406, d = 63 转换hex拼接得到flag：De1CTF{58bb578d5611363f}\neasyRSA task.py\nfrom Crypto.Util.number import * import gmpy2 import random from FLAG import flag def genE(lcm,limit): while True: r = random.randint(limit,limit*0x1000000000001) d = gmpy2.next_prime(r) e = gmpy2.invert(d,lcm) if isPrime(e): break return e p = getStrongPrime(1024) q = getStrongPrime(1024) n = p * q lcm = gmpy2.lcm(p - 1, q - 1) limit = gmpy2.iroot(n, 3)[0] e1,d1 = genE(lcm, limit) e2,d2 = genE(lcm, limit) phi = (p - 1) * (q - 1) d1 = gmpy2.invert(e1, phi) d2 = gmpy2.invert(e2, phi) e = [e1,e2] plain = bytes_to_long(flag) cipher = pow(plain, e[random.getrandbits(1)], n) print('N:' + str(n)) print('e1:' + str(e1)) print('e2:' + str(e2)) print('cipher:' + str(cipher)) D^3CTF有一道和这题类似的题目，wp也很详细\u0026hellip;\u0026hellip;\nhttps://gist.github.com/LurkNoi/dfe86ed4d16776242251318b380336e7\n构造好的矩阵竟然可以直接拿来用，直接LLL就可以解出来d1，d2\u0026hellip;.\n由于我们不知道genE()中d的具体的bit_length，在d的范围数量级内进行枚举。\nexp.sage:\nn= 24402191928494981635640497435944050736451453218629774561432653700273120014058697415669445779441226800209154604159648942665855233706977525093135734838825433023506185915211877990448599462290859092875150657461517275171867229282791419867655722945527203477335565212992510088077874648530075739380783193891617730212062455173395228143660241234491822044677453330325054451661281530021397747260054593565182679642519767415355255125571875708238139022404975788807868905750857687120708529622235978672838872361435045431974203089535736573597127746452000608771150171882058819685487644883286497700966396731658307013308396226751130001733 e1= 4046316324291866910571514561657995962295158364702933460389468827072872865293920814266515228710438970257021065064390281148950759462687498079736672906875128944198140931482449741147988959788282715310307170986783402655196296704611285447752149956531303574680859541910243014672391229934386132475024308686852032924357952489090295552491467702140263159982675018932692576847952002081478475199969962357685826609238653859264698996411770860260854720047710943051229985596674736079206428312934943752164281391573970043088475625727793169708939179742630253381871307298938827042259481077482527690653141867639100647971209354276568204913 e2= 1089598671818931285487024526159841107695197822929259299424340503971498264804485187657064861422396497630013501691517290648230470308986030853450089582165362228856724965735826515693970375662407779866271304787454416740708203748591727184057428330386039766700161610534430469912754092586892162446358263283169799095729696407424696871657157280716343681857661748656695962441400433284766608408307217925949587261052855826382885300521822004968209647136722394587701720895365101311180886403748262958990917684186947245463537312582719347101291391169800490817330947249069884756058179616748856032431769837992142653355261794817345492723 m1 = n ^ (1 / 2) m1 = int(m1) def GCD(a, b): if a % b == 0: return b else: return GCD(b, a % b) def autoflag(t): m2 = n ^ (1 + t) m2 = int(m2) print(t) B2 = matrix([[1, -n, 0, n**2], [0, e1, -e1, -e1*n], [0, 0, e2, -e2*n], [0, 0, 0, e1*e2]]) D2 = matrix([[n, 0, 0, 0], [0, m1, 0, 0], [0, 0, m2, 0], [0, 0, 0, 1]]) M = B2 * D2 # k1k2, k2d1, k1d2, d1d2 for vec in M.LLL()[:1]: b1, b2, b3, b4 = vec x2 = Matrix([[b1, b2, b3, b4]]) * M.inverse() a,b,c,d = x2[0] print(GCD(b, d)) print(GCD(c, d)) print(\u0026quot;DONE\u0026quot;) t = 0.3334 while t \u0026lt; 0.3570: # 0.3334 - 0.3569 t += 0.0001 autoflag(t) # 0.3550 # 13055886542241324849606848300654111050213895018931668525112390666717463659828011236495055020349316934910897599568907550458905937640534150366439142917379092077356477487038001707677114834324987975339711919914028174834026692 # 10524758552977623950522576266095598971604066598976786723316565384341562423375977453510267182029447059155214674557556041512997808420285719007717780425013978916702926738382048840861185251222579340831080549153967201958081132 exp.py\nfrom Crypto.Util.number import * n = 24402191928494981635640497435944050736451453218629774561432653700273120014058697415669445779441226800209154604159648942665855233706977525093135734838825433023506185915211877990448599462290859092875150657461517275171867229282791419867655722945527203477335565212992510088077874648530075739380783193891617730212062455173395228143660241234491822044677453330325054451661281530021397747260054593565182679642519767415355255125571875708238139022404975788807868905750857687120708529622235978672838872361435045431974203089535736573597127746452000608771150171882058819685487644883286497700966396731658307013308396226751130001733 e1 = 4046316324291866910571514561657995962295158364702933460389468827072872865293920814266515228710438970257021065064390281148950759462687498079736672906875128944198140931482449741147988959788282715310307170986783402655196296704611285447752149956531303574680859541910243014672391229934386132475024308686852032924357952489090295552491467702140263159982675018932692576847952002081478475199969962357685826609238653859264698996411770860260854720047710943051229985596674736079206428312934943752164281391573970043088475625727793169708939179742630253381871307298938827042259481077482527690653141867639100647971209354276568204913 e2 = 1089598671818931285487024526159841107695197822929259299424340503971498264804485187657064861422396497630013501691517290648230470308986030853450089582165362228856724965735826515693970375662407779866271304787454416740708203748591727184057428330386039766700161610534430469912754092586892162446358263283169799095729696407424696871657157280716343681857661748656695962441400433284766608408307217925949587261052855826382885300521822004968209647136722394587701720895365101311180886403748262958990917684186947245463537312582719347101291391169800490817330947249069884756058179616748856032431769837992142653355261794817345492723 c = 5089249888618459947548074759524589606478578815336059949176718157024022678024841758856813241335191315643869492784030633661717346809979076682611760035885176766380484743187692409876479000444892361744552075578050587677106211969169204446554196613453202059517114911102484740265052582801216204900709316109336061861758409342194372241877343837978525533125320239702501424169171652846761028157198499078668564324989313965631396082388643288419557330802071756151476264735731881236024649655623821974147680672733406877428067299706347289297950375309050765330625591315867546015398294367460744885903257153104507066970239487158506328863 d1 = 13055886542241324849606848300654111050213895018931668525112390666717463659828011236495055020349316934910897599568907550458905937640534150366439142917379092077356477487038001707677114834324987975339711919914028174834026692 d2 = 10524758552977623950522576266095598971604066598976786723316565384341562423375977453510267182029447059155214674557556041512997808420285719007717780425013978916702926738382048840861185251222579340831080549153967201958081132 d1 = d1 // 4 d2 = d2 // 4 m = pow(c, d1, n) print(long_to_bytes(m)) flag：De1CTF{4ef5e5b2-c169-47e2-b90e-9421c56f2f5e}\n感觉自己菜爆了\u0026hellip;自闭比赛，做的时间最长的一题ECDH最终还是没弄出来，一直感觉是Invalid Curve Attack，因为服务器端没有检测发送的点是否在开始的那条椭圆曲线上。赛后发现，是因为自己在选取 bi 的时候，n%p==0 没有加上 ==0 \u0026hellip;\u0026hellip; 不过作为入队考核题，最终还是做出来了顺利进队。\nECDH 拿来代码可以看到我们可以向服务器发送一个点Gi(Exchange)，然后可以为我们加密一段msg(Encrypt)，返回给我们secret*Gi合并 x y 后与 msg 异或的结果，我们收到这个结果再与msg异或一下然后分离 x y 就可以得到点secret*Gi 了。我们的目的是得到并向服务器发送secret的值，就能得到flag啦。\n简化一下：发送点Gi，得到点secret*Gi，计算secret并发送，得到flag。\n$$ E:y^2=x^3+Ax+B $$\n注意到计算secret*Gi的mul()和add()函数并没有用到椭圆曲线 $E$ 的参数B，也没有检查Gi是否为E(A, B, q)上的点。所以我们可以构造E'(A, Bi, q)，然后发送曲线 $E\u0026rsquo;$ 上的点 Gi，所以程序在计算 secret*Gi 的时候，它以为是在 $E$ 上计算，其实被骗了，是在 $E\u0026rsquo;$ 上计算。发送多组Gi最终可以得到足够的数据通过剩余定理合并，得到secret，这种攻击就是 Invalid Curve Attack。\nInvalid Curve Attack Local Preparation\n随机选取 Bi，并计算此时的 $E\u0026rsquo;$ 的阶 $n$，判断$n$是否能被一个小素数 qi 整除，如果可以就保留 Bi，qi。 在 $E\u0026rsquo;$ 上找一个随机点 $H$ ,并计算 $Gi=(n\u0026rsquo;/q)H$ ，检查 Gi 是否为无穷远点就可以了，是的话重新选这个随机点 $H$ ，不是就把这个 Gi 保存。 这样就得到了一组 (bi, qi, Gi)，不断重复一二两步，直到所有的 qi 之积大于 $q^2$ 就退出循环。 Online Attack：\n发送点Gi ，得到程序返回的secret*Gi 在 $(0,qi)$ 范围内枚举ti ，使其满足ti*Gi == secret*Gi，计算 $t_i^2\\ mod\\ q_i$，这时有 $secret^2 = t_i^2\\ mod\\ q_i$。 重复上面两步，发送完所有的Gi，保存到了所有的 $t_i^2\\ mod\\ q_i$。然后用剩余定理合并所有的 $t_i^2$，得到 $t^2$ 也就是 $secret^2$，开平方根就得到了secret。 Writeup 在计算参数列表Bi，qi，Gi的时候，要注意到程序最多只能和我们交互 90 次，交互两次才能完成发送Gi和加密msg，所以qi的个数需要小于 45 ，最好给qi定一个不太小的下限（我的是5000），以保证qi个数较少。我先生成一个 5000 之后1000 个素数的列表作为qi可选的空间。\n本地计算参数列表的脚本：\nfrom random import randint from gmpy2 import sqrt,invert,mpz sieve_base=[5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249] q = 0xdd7860f2c4afe6d96059766ddd2b52f7bb1ab0fce779a36f723d50339ab25bbd a = 0x4cee8d95bb3f64db7d53b078ba3a904557425e2a6d91c5dfbf4c564a3f3619fa zero = (0,0) F=FiniteField(q) def f(b,x): return (pow(x,3,q) + a*x + b) % q def add(p1,p2): if p1 == zero: return p2 if p2 == zero: return p1 (p1x,p1y),(p2x,p2y) = p1,p2 if p1x == p2x and (p1y != p2y or p1y == 0): return zero if p1x == p2x:#p1y == p2y and p1y != 0 and p2y != 0 tmp = (3 * p1x * p1x + a) * invert(mpz(2 * p1y) , mpz(q)) % q else: tmp = (p2y - p1y) * invert(mpz(p2x - p1x) , mpz(q)) % q x = (tmp * tmp - p1x - p2x) % q y = (tmp * (p1x - x) - p1y) % q return (int(x),int(y)) def mul(n,p): r = zero tmp = p while 0 \u0026lt; n: if n \u0026amp; 1 == 1: r = add(r,tmp) n, tmp = n \u0026gt;\u0026gt; 1, add(tmp,tmp) return r def Offline_Precomputations(): prime_list = [sieve_base[i] for i in range(1000)] Gi_list = [] qlist = [] bi_list=[] qi_product = 1 bi=1 while(qi_product \u0026lt; q*q): bi += 1 E=EllipticCurve(F,[a,bi]) n = E.order() print(n) find_a_small_factor = False for i in range(1000): if n % prime_list[i]==0 and prime_list[i] not in qlist: print(\u0026quot;find a small factor\u0026quot;) find_a_small_factor = True qi_product *= prime_list[i] qlist.append(prime_list[i]) bi_list.append(bi) print(qlist) break if not find_a_small_factor: continue H=E.random_point() inf=H-H while True: G = H * int(n / qlist[-1]) if G == inf: H = E.random_point() else: break print(\u0026quot;find!\u0026quot;) print(G) Gi_list.append((G[0], G[1])) print(bi_list) print(qlist) print(Gi_list) Offline_Precomputations() 上面的脚本大约5分钟就可以算完。输出的三个参数列表存在一个文件里：\nbi = [4, 9, 26, 28, 30, 32, 34, 40, 41, 48, 73, 86, 111, 112, 117, 119, 129, 132, 136, 141, 161, 165, 174, 188, 197, 203, 206, 213, 214, 220, 238, 242, 275, 276, 279, 291, 299, 303, 322, 336] qi = [5657, 10903, 8191, 12157, 6073, 9241, 10687, 12893, 6719, 13859, 8117, 10301, 13099, 5527, 8737, 10631, 5107, 5693, 6079, 10657, 5927, 6113, 7873, 6217, 11047, 12113, 5147, 9103, 11057, 5923, 7027, 5717, 10501, 13063, 9127, 10133, 5477, 5471, 13421, 13759] Gi = [(30872500276756167396951474090124654304794923360667192467226675667448229681665, 83322930424192373524322173116603156345074046542792982303484797472143217961368), (14142904415645449119907336377416481926864703912427562730055735074219145549101, 63849575435191102844140385926897263301061935266189659881317580955016050734189), (40969882994648530081916876655161985963830665410329660538461272172469167125728, 64454878682771462004362411962366300840173052580225189911399858039534581888077), (82877418346404951750675480072867011998991569892157974398985334984663117854149, 50978626336645847463851041692845664756477024069940277266625847972958761358368), (24746817534136625356292362813181235589280973302944023820185154275643462413727, 35639977980669594960678433763010741945515185245445353404428172737631739386899), (47282371694648556570679118847655449358963795004556531118348527180031145177969, 59966019181805023632948187657492552643801632478184881090936975601106229146410), (60712030606261917519568264199639402100574447377118122922524413101203741263120, 17176385919318377183171082088625527451825035445063657268915215986521393888340), (9027327243716998211781862199426408307326022952644379162790068878797188141818, 61009803152391976811447442545097299173436840401745624638955569832237555829473), (92251054066253126334428165182631564129665870611725669183888213682798259095972, 37074010565672199367874176622919563060597398699989235438216793443482295287409), (69695373440573629766708856342663276081186838699125800152765630981947711052121, 48178899944132882283599919400524668308064902957209651369122200378268323952425), (75102389801455858956597493216399156984694788514035038175249758211883103626870, 3412785211107654591249094160052537680385541044296766274185340746624483729733), (59866676681443934667114838077713240838957123181519735125754606765849866097347, 8805439985411086835249824924575402161831279521146603579645222384004542285519), (12347621918708465606908238516379113916518065052190877557445387463476295403583, 51928978269977560591638042857241338407310718393549367181739959706805873995534), (73062544334117217418276419902996007214091231775581805844308159628155628211807, 55784571416852533002117425486589483198762732580845853891284112905769938188897), (44682682941088257636486520064393268330678693434401068570127680280728944744998, 28173971913162137009249858457142752453546282574869173219057002120131181452593), (34242130021719570117253003762778941164580411253476500654240946260487756864086, 26766153725875538986947107451673755197819092915585191972024061524601120879860), (90422336812399003145559066044427724490604468992899648595340676974027580958703, 80165372718141463422545565405008761999799501548366301938489635724657401745713), (85140176786053085584193314208172740416786705738102554549989875569197541552264, 75358833217208468040762514687496665850414066877171064073115458896807483076615), (94771825545395933071508776706118073614882175454078396622630715974723704155151, 4745535117825351976526807256991485492783614974043324040684972741775042815990), (100171525035097286097545492976792764465735962531594898393076116754456861358755, 53705979238119204251739160477914836172776252121476309657209714496275276427389), (29971095349578324382901593694826617004225871191689145192858680308549101683404, 57184898779794807742616054554045038792327449405632903218800390085959225225204), (55407687548794482628601357728242040226311193190028208583744883161144062368296, 33314617302527601701593772443278423878871997724393245022228170147527022751718), (32239990110815338831999530368651186051237902011177167660513454938097407801162, 671602395501769727771718955063041871367596087541253612345325738676335116280), (3917571690569088369262203391165226228446787670578414099634000210229258526360, 70634026931612954431222806160218359603337677957192750882837663783030579509624), (2207035926055248213529107319579032297141765794563906833591403890711440160113, 31331709971636821775115781873059884810730455527131288709744391474355953219901), (3932808658713491006509410084406394244966049429248145722157725209819345215434, 85142630046436265508647141294265284061206772024019380851950823942517231823894), (1539521617181156915158018487872776183950574207896802451837845170244377427387, 24449866531527118897857255763228849849561887485160194129175253493403448504125), (75002212857098569438403863439809398015781294312789119873167994247755527333762, 87002220226810953045826905675716400420036092226734517178134089426254171587715), (92010592279557832306039829536051295550204502236267688784472039931587463456035, 58613481301723072528738357273612194677387937582367011948647990512041392950153), (83393344736952817655018385178901587930844106489134650611100773558042073140443, 30300689939783331476278918304361371781367897595104621620522420376841330066554), (91078061094403429716572485362499716404082941862048489035495641570495237378110, 40971255337503044023637629176353045221129744187378119183810433410253577683959), (16985546008320601827759048065524362704024280157173465715933238635277424622056, 22696940558362620242678088324333793057494067258280802605002237508630082994109), (19170284381687584388622601167478242887418206491615217123996130596733428386742, 75748545718743128162585628787582641365201763301552227607403853384807587009859), (26473683045754776494164819126676658456171602164787921730420301045177016736609, 4281911904902758858355404226807051591134777088628269518372910631801533181905), (53676622464735659552656571188215866927322104668956095743777971851020661674358, 32274152263769486066368214670965452735712224610879606790658391470777079972556), (17029079575716446729702735874302371314145352046618367406530611486482710572360, 69357146029376150656652047840232370865246341002948175613826165204918209020338), (34727300648324783340958409739006112355711035230437824170066703947960201976886, 1587307801581137361413368586082506549606770098958439500002828849164565562848), (20877893922423278084054972379788392567821904480521987253174872716560062157784, 6715702336736936301726721938396211844295333186474291987353293376813588111160), (31562274556840802328980745172266502601827082447947556734372585420455740249090, 34305476342176933832701449433075719459820433000960976107182392312648682867355), (19690328408555852060974020099573760475212244087504943265526342735564565974214, 85979847994448727599368990309145050030837733437134982952836810810966647646533)] 有了参数列表就可以干服务器上的程序了：\nimport string from LIST import qi, Gi from pwn import remote from hashlib import sha256 from gmpy2 import invert, iroot from functools import reduce msg = \u0026quot;80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026quot; q = 0xdd7860f2c4afe6d96059766ddd2b52f7bb1ab0fce779a36f723d50339ab25bbd a = 0x4cee8d95bb3f64db7d53b078ba3a904557425e2a6d91c5dfbf4c564a3f3619fa b = 0x56cbc73d8d2ad00e22f12b930d1d685136357d692fa705dae25c66bee23157b8 zero = (0, 0) def proof_of_work(txt, Hash): S = string.ascii_letters+string.digits for a in S: for b in S: for c in S: for d in S: if sha256((a + b + c + d + txt).encode()).hexdigest() == Hash: print(a + b + c + d) return a + b + c + d def add(p1, p2): if p1 == zero: return p2 if p2 == zero: return p1 (p1x, p1y), (p2x, p2y) = p1, p2 if p1x == p2x and (p1y != p2y or p1y == 0): return zero if p1x == p2x: # p1y == p2y and p1y != 0 and p2y != 0 tmp = (3 * p1x * p1x + a) * invert(2 * p1y, q) % q else: tmp = (p2y - p1y) * invert(p2x - p1x, q) % q x = (tmp * tmp - p1x - p2x) % q y = (tmp * (p1x - x) - p1y) % q return (int(x), int(y)) def mul(n, p): r = zero tmp = p while 0 \u0026lt; n: if n \u0026amp; 1 == 1: r = add(r, tmp) n, tmp = n \u0026gt;\u0026gt; 1, add(tmp, tmp) return r def CRT(m, a): Num = len(m) M = reduce(lambda x, y: x*y, m) Mi = [M // i for i in m] t = [invert(Mi[i], m[i]) for i in range(Num)] x = 0 for i in range(Num): x += a[i] * t[i] * Mi[i] return x % M def stringToPoint(p): i = 0 while p[i] != ',': i += 1 return (int(p[1:i]), int(p[i+1:-1])) def exchange(xi, yi): tmp = r.recvline() print(tmp) tmp = r.recvline() print(tmp) r.send(str(xi) + \u0026quot;\\n\u0026quot;) print(xi) tmp = r.recvline() print(tmp) r.send(str(yi) + \u0026quot;\\n\u0026quot;) print(yi) tmp = r.recvline() print(tmp) tmp = r.recvline() print(tmp) def encrypt(msg): tmp = r.recvline() print(tmp) r.send(str(msg) + '\\n') tmp=r.recvline() print(tmp) res = int(r.recvline().strip().decode(), 16) print(res) res ^= int(msg, 16) print(\u0026quot;res =\u0026quot;, hex(res)) tmp = r.recvline() print(tmp) return res def keysToPoint(res): res = bin(res)[2:] y = int(res[-256:], 2) x = int(res, 2) \u0026gt;\u0026gt; 256 return (x, y) def getPoint(xi, yi, msg): r.send(\u0026quot;Exchange\\n\u0026quot;) exchange(xi, yi) r.send(\u0026quot;Encrypt\\n\u0026quot;) res = encrypt(msg) return keysToPoint(res) # proof_of_work r = remote('134.175.225.42', 8848) r.recvuntil(\u0026quot;XXXX+\u0026quot;) nonce = r.recv(16).decode() r.recvuntil(\u0026quot; == \u0026quot;) target = r.recv(64).decode() w = proof_of_work(nonce, target) r.send(str(w)) print(\u0026quot;----------proof of work is ok!----------\u0026quot;) # Start_work r.recvuntil(\u0026quot;q: \u0026quot;) q = int(r.recvline().strip().decode()) r.recvuntil(\u0026quot;a: \u0026quot;) a = int(r.recvline().strip().decode()) r.recvuntil(\u0026quot;b: \u0026quot;) b = int(r.recvline().strip().decode()) r.recvuntil(\u0026quot;P: \u0026quot;) P = stringToPoint(r.recvline().strip().decode()) r.recvuntil(\u0026quot;Q: \u0026quot;) Q = stringToPoint(r.recvline().strip().decode()) print(\u0026quot;q :\u0026quot;, q, \u0026quot;\\na :\u0026quot;, hex(a), \u0026quot;\\nb :\u0026quot;, hex(b), \u0026quot;\\nP :\u0026quot;, P, \u0026quot;\\nQ :\u0026quot;, Q) exchange(1, 1) qlen = len(Gi) t = [] for i in range(len(qi)): print(\u0026quot;--------------------{}th\u0026quot;.format(i)) X = getPoint(Gi[i][0], Gi[i][1], msg) ti = 0 for j in range(qi[i]): if mul(j, (Gi[i][0], Gi[i][1])) == X: ti = j t.append((ti * ti) % qi[i]) break print(\u0026quot;ti :\u0026quot;, ti) print(t) ans = CRT(qi, t) secret = iroot(ans, 2)[0] print(secret) if mul(secret, P) == Q: print(\u0026quot;checked\u0026quot;) r.send(\u0026quot;Backdoor\\n\u0026quot;) tmp = r.recvline() print(tmp) r.send(str(secret) + \u0026quot;\\n\u0026quot;) temp1 = r.recvline() print(temp1) temp2 = r.recvline() print(temp2) ","permalink":"https://slightwind.cn/posts/ctf/writeup-for-crypto-problems-in-de1ctf-2020/","summary":"NLFSR task.py\nfrom flag import a, b, c, d, flag assert flag == \u0026quot;De1CTF{\u0026quot; + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \u0026quot;}\u0026quot; assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6] ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31 def lfsr(r, m): return ((r \u0026lt;\u0026lt; 1) \u0026amp; 0xffffff) ^ (bin(r \u0026amp; m).count('1') % 2) def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i \u0026amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do def genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\u0026quot;data\u0026quot;, \u0026quot;w+\u0026quot;).","title":"Writeup for Crypto problems in De1CTF 2020"},{"content":"\u0026ldquo;not_RSA\u0026rdquo; in DASCTF 看了大佬的博客才知道是 Paillier cryptosystem，wtcl\u0026hellip; 不过还是记录一下自己推导的解题过程\n直接使用现成的 Paillier cryptosystem 解密算法解决这题非常容易，分解 n 然后直接套 decrypt 函数就解开了\u0026hellip;\n题目：\nfrom Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inverse from secret import flag,p,q from sympy import isprime,nextprime import random m = bytes_to_long(flag) n = p * q g = n + 1 r = random.randint(1, n) c = (pow(g, m, n * n) * pow(r, n, n * n)) % (n * n) print('c =', c) print('n =', n) 主要加密过程是：\n$$ \\begin{aligned} c\u0026amp;\\equiv(g^m \\ mod \\ n^2)(r^n \\ mod \\ n^2) \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv g^m r^n \\ \u0026amp;(mod \\ n^2) \\end{aligned} $$\n其中有\n$$ \\begin{aligned} g^m\u0026amp;\\equiv (n+1)^m \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv C_m^0 n^0 + C_m^1 n^1 +C_m^2n^2+\u0026hellip;+C_m^mn^m \\ \u0026amp;(mod \\ n^2) \\\\ \u0026amp;\\equiv C_m^0 n^0 + C_m^1 n^1 \\ \u0026amp;(mod \\ n^2)\\\\ \u0026amp;\\equiv 1 + mn \\ \u0026amp;(mod \\ n^2) \\end{aligned} $$\n所以得到 $c\\equiv g^m r^n\\equiv (1 + mn)r^n \\ (mod \\ n^2)$\n现在就要想办法消除掉 $r^n$ 的影响，不难发现 $r^n\\ mod\\ n = c\\ mod\\ n$。\n所以我们需要由 $r^n\\ mod\\ n$ 得到 $r$ 的值或者 $r^n\\ mod\\ n^2$的值，才可以对 $r^n$ 在模 $n^2$ 下求逆元。这里我这个菜鸡想了好久\u0026hellip;最终想到将 $r^n\\ mod\\ n$ 分别对 $n$ 的两个因数 $p,q$ 取模，然后再用中国剩余定理（CRT）合并，从而得到 $r$。\n然后我们只需要计算 $r^n\\ mod\\ n^2$ 的逆元并与 $c$ 相乘，就得到 $(1+mn)\\ mod\\ n^2$，也就得到了 $m$。\nfrom Crypto.Util.number import long_to_bytes, inverse from functools import reduce c = 29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549 n = 6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093 p = 80006336965345725157774618059504992841841040207998249416678435780577798937819 q = 80006336965345725157774618059504992841841040207998249416678435780577798937447 g = n + 1 phi = (p - 1) * (q - 1) rn = c % n x1 = rn % p d1 = inverse(q, p - 1) r1 = pow(x1, d1, p) x2 = rn % q d2 = inverse(p, q - 1) r2 = pow(x2, d2, q) def CRT(m, a): Num = len(m) M = reduce(lambda x, y: x * y, m) Mi = [M // i for i in m] t = [inverse(Mi[i], m[i]) for i in range(Num)] x = 0 for i in range(Num): x += a[i] * t[i] * Mi[i] return x % M r = CRT([p, q], [r1, r2]) R = pow(r, n, n * n) R_inv = inverse(R, n * n) mn = (c * R_inv) % (n * n) m = (mn - 1) // n print(long_to_bytes(m)) Paillier Crytposystem 选取素数 $p, q$，计算 $n=p\\cdot q$，$\\lambda =lcm(p-1,q-1)$，选取 $g\\in\\Z_{n^2}^*$满足 $g$ 的阶是 $n$ 的倍数。\n其中公钥为：$n, g$，私钥为：$p, q,\\lambda$。\n加密时明文 $m\u0026lt;n$，选取随机的 $r \\in \\Z_n^*$，计算出密文 $c=g^m r^n \\ mod \\ n^2$。\n解密时的密文 $c\u0026lt;n^2$，明文 $m=\\cfrac{L(c^\\lambda\\ mod\\ n^2)}{L(g^\\lambda\\ mod\\ n^2)}\\ (mod\\ n)$，其中 $L(u)=\\cfrac{u-1}{n}$。\n在选取合适的 $g$ 的时候，需要判断 $g$ 的阶是否为 $n$ 的倍数，等价于判断 $GCD(L(g^\\lambda\\ mod\\ n^2),n)=1$。\nfrom Crypto.Util.number import * from gmpy2 import lcm class Paillier(): def __init__(self): pass def encrypt(self, m): p, q = getPrime(512), getPrime(512) n = p * q self.n = n assert m \u0026lt; n Lcm = lcm(p - 1, q - 1) g = getRandomRange(1, n*n) while GCD(self.L(pow(g, Lcm, n * n)), n) != 1: g = getRandomRange(1, n * n) r = getRandomRange(1, n) return (pow(g, m, n * n) * pow(r, n, n * n)) % (n * n), p, q, g def decrypt(self, c, p, q, g): n = p*q assert c \u0026lt; n*n Lcm = lcm(p - 1, q - 1) self.n = n self.d = inverse((p - 1) * (q-1), n) m_c = self.L(pow(c, Lcm, n * n)) m_g = self.L(pow(g, Lcm, n * n)) m = m_c*inverse(m_g, n) % n return m def L(self, u): return (u - 1) // self.n m = bytes_to_long(b'flag{1234567890}') P = Paillier() c, p, q, g = P.encrypt(m) M = P.decrypt(c, p, q, g) print(long_to_bytes(M)) # b'flag{1234567890}' 使用 Paillier 解密就可以直接解这一题。\nexp:\nfrom Crypto.Util.number import long_to_bytes,inverse from gmpy2 import lcm c = 29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549 n = 6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093 p = 80006336965345725157774618059504992841841040207998249416678435780577798937819 q = 80006336965345725157774618059504992841841040207998249416678435780577798937447 g = n + 1 phi = (p - 1) * (q - 1) def decrypt(c, p, q, g): n = p * q Lcm = lcm(p - 1, q - 1) m_c = (pow(c, Lcm, n * n) - 1) // n m_g = (pow(g, Lcm, n * n) - 1) // n m = m_c * inverse(m_g, n) % n return m m = decrypt(c, p, q, g) print(long_to_bytes(m)) #b'flag{5785203dbe6e8fd8bdbab860f5718155}' ","permalink":"https://slightwind.cn/posts/ctf/learn-paillier-crytposystem-from-not_rsa-in-dasctf/","summary":"\u0026ldquo;not_RSA\u0026rdquo; in DASCTF 看了大佬的博客才知道是 Paillier cryptosystem，wtcl\u0026hellip; 不过还是记录一下自己推导的解题过程\n直接使用现成的 Paillier cryptosystem 解密算法解决这题非常容易，分解 n 然后直接套 decrypt 函数就解开了\u0026hellip;\n题目：\nfrom Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inverse from secret import flag,p,q from sympy import isprime,nextprime import random m = bytes_to_long(flag) n = p * q g = n + 1 r = random.randint(1, n) c = (pow(g, m, n * n) * pow(r, n, n * n)) % (n * n) print('c =', c) print('n =', n) 主要加密过程是：","title":"Learn Paillier crytposystem from \"not_RSA\" in DASCTF"},{"content":"Notes for $An\\ Introduction\\ to\\ Mathematical\\ Cryptography$\n“A toy model of a real public key cryptosystem” 这里以 An Introduction to Mathematical Cryptography 书中的一个简单的加密模型为例，简单介绍一下通过高斯格基规约算法（Gaussian Lattice Reduction）解决二维的格上的寻找最短向量问题。\n最近在书中看到这个，刚好 西电新生赛@Mini L-CTF 有两个题目刚好是用这个模型实现的，当做例题整个 writeup。\ntask.py\nfrom Crypto.Util.number import bytes_to_long, getPrime, inverse from gmpy2 import iroot q = getPrime(1024) f = getPrime(511) g = getPrime(511) while g \u0026lt; iroot(q//4, 2)[0] or g \u0026gt; iroot(q//2, 2)[0]: g = getPrime(511) f_inv_q = inverse(f, q) h = f_inv_q * g % q m = bytes_to_long(b'flag') # flag is base**(flag) r = getPrime(510) e = (r * h + m) % q print(f) print(g) print(q) print(e) ''' f = 4685394431238242086047454699939574117865082734421802876855769683954689809016908045500281898911462887906190042764753834184270447603004244910544167081517863 g = 5326402554595682620065287001809742915798424911036766723537742672943459577709829465021452623299712724999868094408519004699993233519540500859134358256211397 q = 172620634756442326936446284386446310176482010539257694929884002472846127607264743380697653537447369089693337723649017402105400257863085638725058903969478143249108126132543502414741890867122949021941524916405444824353100158506448429871964258931750339247018885114052623963451658829116065142400435131369957050799 e = 130055004464808383851466991915980644718382040848563991873041960765504627910537316320531719771695727709826775790697704799143461018934672453482988811575574961674813001940313918329737944758875566038617074550624823884742484696611063406222986507537981571075140436761436815079809518206635499600341038593553079293254 ''' 其中私钥为 ( f , g ) ，公钥为 ( q , h ) ，这个已经给了私钥，所以解密过程非常简单。\n$$ e \\equiv rh+m \\equiv \\frac{rg}{f}+m \\ (mod \\ q) $$\n两边同时乘 $f$: $$ \\tag{1}ef \\equiv rg+mf \\ (mod \\ q) $$\n这时注意到 $g$ 的范围是 $\\sqrt{\\frac{q}{4}} \u0026lt; g \u0026lt; \\sqrt{\\frac{q}{2}}$，所以：\n$$ rg+fm\u0026lt; \\sqrt{\\frac{q}{2}}\\sqrt{\\frac{q}{2}}+\\sqrt{\\frac{q}{2}}\\sqrt{\\frac{q}{4}}\u0026lt; q $$\n那么同余式 $(1)$，可以直接看做等式：\n$$ \\tag{2}ef = rg+mf $$\n接下来只需计算：\n$$ (ef)f^{-1}\\equiv (rg+mf)f^{-1} \\equiv rgf^{-1}+mff^{-1} \\equiv mff^{-1}\\equiv m \\ (mod\\ g) $$\n就得到明文了。\nfrom Crypto.Util.number import long_to_bytes,inverse f = 4685394431238242086047454699939574117865082734421802876855769683954689809016908045500281898911462887906190042764753834184270447603004244910544167081517863 g = 5326402554595682620065287001809742915798424911036766723537742672943459577709829465021452623299712724999868094408519004699993233519540500859134358256211397 q = 172620634756442326936446284386446310176482010539257694929884002472846127607264743380697653537447369089693337723649017402105400257863085638725058903969478143249108126132543502414741890867122949021941524916405444824353100158506448429871964258931750339247018885114052623963451658829116065142400435131369957050799 e = 130055004464808383851466991915980644718382040848563991873041960765504627910537316320531719771695727709826775790697704799143461018934672453482988811575574961674813001940313918329737944758875566038617074550624823884742484696611063406222986507537981571075140436761436815079809518206635499600341038593553079293254 m = (e*f % q) % g m *= inverse(f, g) print(long_to_bytes(m % g)) # y0u_ar3_s0_f@st 从公钥得到私钥 上面只是介绍了这个简单的加密模型，如果要破解它，就要从公钥 $(q,h)$ 计算出私钥 $(f,g)$ ，其中 $h=g/f$，并且 $g$ 和 $f$ 都是在 $\\sqrt{q}$ 的数量级。\n所以可以找到符合条件的 $(F,G)$ 就可以解密了，所以构建向量： $$ F(1,h)-R(0,q)=(F,G) $$ 其中 $v_1=(1,h),\\ v_2=(0,q)$，所以短向量 $(F, G)$ 在格 $L={a_1v_1,a_2v_2}$ 中。\n现在问题就被转化成二维的格的最短向量问题，由于是二维的格，可以用高斯格基规约算法。\nfrom gmpy2 import iroot, sqrt from Crypto.Util.number import * q = 126982824744410328945797087760338772632266265605499464155168564006938381164343998332297867219509875837758518332737386292044402913405044815273140449332476472286262639891581209911570020757347401235079120185293696746139599783586620242086604902725583996821566303642800016358224555557587702599076109172899781757727 h = 31497596336552470100084187834926304075869321337353584228754801815485197854209104578876574798202880445492465226847681886628987815101276129299179423009194336979092146458547058477361338454307308727787100367492619524471399054846173175096003547542362283035506046981301967777510149938655352986115892410982908002343 e = 81425203325802096867547935279460713507554656326547202848965764201702208123530941439525435560101593619326780304160780819803407105746324025686271927329740552019112604285594877520543558401049557343346169993751022158349472011774064975266164948244263318723437203684336095564838792724505516573209588002889586264735 def gaussian(v1, v2): while True: if sqrt(v2[0]**2+v2[1]**2) \u0026lt; sqrt(v1[0]**2+v1[1]**2): v1, v2 = v2, v1 m = int((v1[0]*v2[0]+v1[1]*v2[1])/(v1[0]**2+v1[1]**2)) if m == 0: return (v1, v2) v2 = [v2[0]-m*v1[0], v2[1]-m*v1[1]] s1, s2 = gaussian([1, h], [0, q]) f, g = s1[0], s1[1] m = (e * f % q) % g m *= inverse(f, g) print(long_to_bytes(m % g)) # l1Ii5n0tea5y ","permalink":"https://slightwind.cn/posts/crypto/find-short-vectors-in-two-dimensional-lattices/","summary":"Notes for $An\\ Introduction\\ to\\ Mathematical\\ Cryptography$\n“A toy model of a real public key cryptosystem” 这里以 An Introduction to Mathematical Cryptography 书中的一个简单的加密模型为例，简单介绍一下通过高斯格基规约算法（Gaussian Lattice Reduction）解决二维的格上的寻找最短向量问题。\n最近在书中看到这个，刚好 西电新生赛@Mini L-CTF 有两个题目刚好是用这个模型实现的，当做例题整个 writeup。\ntask.py\nfrom Crypto.Util.number import bytes_to_long, getPrime, inverse from gmpy2 import iroot q = getPrime(1024) f = getPrime(511) g = getPrime(511) while g \u0026lt; iroot(q//4, 2)[0] or g \u0026gt; iroot(q//2, 2)[0]: g = getPrime(511) f_inv_q = inverse(f, q) h = f_inv_q * g % q m = bytes_to_long(b'flag') # flag is base**(flag) r = getPrime(510) e = (r * h + m) % q print(f) print(g) print(q) print(e) ''' f = 4685394431238242086047454699939574117865082734421802876855769683954689809016908045500281898911462887906190042764753834184270447603004244910544167081517863 g = 5326402554595682620065287001809742915798424911036766723537742672943459577709829465021452623299712724999868094408519004699993233519540500859134358256211397 q = 172620634756442326936446284386446310176482010539257694929884002472846127607264743380697653537447369089693337723649017402105400257863085638725058903969478143249108126132543502414741890867122949021941524916405444824353100158506448429871964258931750339247018885114052623963451658829116065142400435131369957050799 e = 130055004464808383851466991915980644718382040848563991873041960765504627910537316320531719771695727709826775790697704799143461018934672453482988811575574961674813001940313918329737944758875566038617074550624823884742484696611063406222986507537981571075140436761436815079809518206635499600341038593553079293254 ''' 其中私钥为 ( f , g ) ，公钥为 ( q , h ) ，这个已经给了私钥，所以解密过程非常简单。","title":"Find short vectors in two-dimensional lattices"},{"content":"模数两两互素时 from Crypto.Util.number import inverse from functools import reduce def crt(a, m): '''Return a solution to a Chinese Remainder Theorem problem. ''' M = reduce(lambda x, y: x * y, m) Mi = [M // i for i in m] t = [inverse(Mi[i], m[i]) for i in range(len(m))] x = sum([a[i] * t[i] * Mi[i] for i in range(len(m))]) return x % M 不满足模数两两互素时 这种情况有最小解 $x$ 满足条件，很多博客也讲的很详细，但是没找到 Python 写的\u0026hellip;\n与 $m$ 互素时一样，$m$ 不互素时显然也会有无限个解 $X = k \\cdot M + x$ ，但是 $m$ 之间不互素时，在模 $M$ 的意义下也可能会有多个解。\n$x$ 为最小解，$m_1 , m_2 , \\dots , m_n$ 的最小公倍数为 $L$，$X \u0026lt; M$ ，易知 $X = x + k \\cdot L$ ，枚举 $k$ 就可以了。\nfrom Crypto.Util.number import GCD, inverse from functools import reduce def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def crt_minial(a, m): '''Return the minial solution to a Chinese Remainder Theorem problem. ''' assert len(a) == len(m), f\u0026quot;length of {a} is not equal to {b}\u0026quot; m1, a1, lcm = m[0], a[0], m[0] for i in range(1, len(m)): c = a[i] - a1 g, k, _ = egcd(m1, m[i]) lcm = lcm * m[i] // GCD(lcm, m[i]) assert c % g == 0, 'No Answer!' t = m[i] // g a1 += m1 * (((c // g * k) % t + t) % t) m1 = m[i] // g * m1 return a1 ","permalink":"https://slightwind.cn/posts/crypto/chinese-remainder-theorem/","summary":"模数两两互素时 from Crypto.Util.number import inverse from functools import reduce def crt(a, m): '''Return a solution to a Chinese Remainder Theorem problem. ''' M = reduce(lambda x, y: x * y, m) Mi = [M // i for i in m] t = [inverse(Mi[i], m[i]) for i in range(len(m))] x = sum([a[i] * t[i] * Mi[i] for i in range(len(m))]) return x % M 不满足模数两两互素时 这种情况有最小解 $x$ 满足条件，很多博客也讲的很详细，但是没找到 Python 写的\u0026hellip;\n与 $m$ 互素时一样，$m$ 不互素时显然也会有无限个解 $X = k \\cdot M + x$ ，但是 $m$ 之间不互素时，在模 $M$ 的意义下也可能会有多个解。","title":"Chinese Remainder Theorem"},{"content":"HGAME 2020 week1 writeup Web Cosmos 的博客 看提示去 GitHub 上找这个网站的源代码，搜索 Cosmos Hgame 就可以找到，点开 3 commits，点开 new file 就可以看到： aGdhbWV7ZzF0X2xlQGtfMXNfZGFuZ2VyMHVzXyEhISF9 base64 解码得到 flag: hgame{g1t_le@k_1s_danger0us_!!!} Crypto InfantRSA 题目：\np = 681782737450022065655472455411; q = 675274897132088253519831953441; e = 13; c = pow(m, e, p * q) = 275698465082361070145173688411496311542172902608559859019841 exp：\np = 681782737450022065655472455411 q = 675274897132088253519831953441 e = 13 c = 275698465082361070145173688411496311542172902608559859019841 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % m d = modinv(e, (p - 1) * (q - 1)) m = pow(c, d, p * q) print(hex(m)) Affine 题目:\nimport gmpy2 from secret import A, B, flag assert flag.startswith('hgame{') and flag.endswith('}') TABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM' MOD = len(TABLE) cipher = '' for b in flag: i = TABLE.find(b) if i == -1: cipher += b else: ii = (A * i + B) % MOD cipher += TABLE[ii] print(cipher) # A8I5z{xr1A_J7ha_vG_TpH410} 仿射加密解密，（$A^{-1}$ 为 $A$ 对 MOD 的逆元）。 $$ c = (A\\cdot x + B) \\bmod MOD \\\\ m = A^{-1} (c − B) \\bmod MOD $$\n可以看出想解密要知道A和B ，我们已知hgame{被加密成了A8I5z{，我们只需要取前两个字符就可以枚举出A和B了，从 12变到46（ h变成A），从11变到 33（g变成8），模数MOD为TABLE的长度62。 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ for(int i = 0; i \u0026lt; 62; i++) for(int j = 0; j \u0026lt; 62; j++) if(((i * 12 + j) % 62 == 46) \u0026amp;\u0026amp; ((i * 11 + j) % 62 == 33) \u0026amp;\u0026amp; ((i * 7 + j) % 62 == 43)){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; break; } return 0; } 得到A = 13和B = 14就可以解密了： import gmpy2 TABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM' cipher = 'A8I5z{xr1A_J7ha_vG_TpH410}' def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % m MOD = len(TABLE) A = 13 B = 14 C = modinv(A, MOD) flag = '' for b in cipher: i = TABLE.find(b) if i == -1: flag += b else: ii = C * (i - B) % MOD flag += TABLE[ii] print(flag) # hgame{M4th_u5Ed_iN_cRYpt0} not_One-time 题目：\nimport os import random import string import binascii import base64 from secret import flag assert flag.startswith(b'hgame{') and flag.endswith(b'hgame{') flag_len = len(flag) def xor(s1, s2): #assert len(s1)==len(s2) return bytes(map((lambda x: x[0] ^ x[1]), zip(s1, s2))) random.seed(os.urandom(8)) keystream = ''.join([random.choice(string.ascii_letters + string.digits) for _ in range(flag_len)]) keystream = keystream.encode() print(base64.b64encode(xor(flag, keystream)).decode()) 这题可以通过nc连接服务器，所以可以得到很多的flag密文，而且已知flag以hgame{开始以}结束。\n加密脚本就是用flag和随机等长字符串异或运算然后输出base64编码后的结果，一开始在网上各种找资料，流加密多次密钥攻击，发现都是这样:\n如果攻击者可以拿到 A、B 的密文 E(A)、E(B) ，以及攻击者自己的明文 B，就可以在无需知道密钥的情况下计算出 A 的明文： A = E(A) xor E(B) xor B\n在 GitHub 上也可以找到many-time-pad-attack的脚本，也是需要有一段自己的字符串让脚本加密一次才能推出其他的明文。而这题显然不可以上传一个字符串让服务器上的脚本把 flag 和自己的字符串异或一下再发给自己…\n然而想到一个集合内的字符相互异或的结果也是一个很有限的集合，反过来如果知道一个异或的结果，我们就可以大概知道这个结果可能是哪些字符异或出来的，称这些字符组成的集合为 A，那么以此类推（多次 nc 下来一些密文）得到集合 B，C，D\u0026hellip; 然后取这些集合的交集就可以极大地缩小这个位置可能的字符集合。 exp：\nimport base64 import gmpy2 yb = [ 'XC8JIVMTKws0JmU/d0p6eEgAGAE/TGd+NkF0JUZ0W1YGGX8fXHsdXygPFA==', 'OikNXwJPCn8hBgQHDRI1Bmt+MVErax9eJhw9Ky0VdS4+AXIjQ0UoRigARA==', 'XxIJXlYiGgU6G2lfDV4JYWxCUgkQZxRyDzRwHiExcjNqLwsIb11hYQhTSQ==', 'JQ0vBRQyInETGEBXclMCARBCVAgGGmpiHR52NDwIZSw1PkVuWAQZUHUOGw==', 'DFUxIgJDIVE9BmJZLRMCWxRdIyIkfEtHKksgIUExZFAZElIeVWY2dTspJQ==', 'HxE1IxUtI1EaO3ZbA0YbCxZcKyo9eWkUOyY/KUIlWREvU0ptfWQXfyoDMA==', 'DiwqBi9IFAQdAF8nPRp9ZFBbLCFXZx5OLzofJjN0ZTMyDFUsQAQ2Ww4wDA==', 'ACQiXyQRNEY/EglaH2gedU17EDALRRJASQgzEwERXAs9EgIXbGQTYQgfEw==', 'DFUMPCsaAHwPG1wAARofRkoAL1Qcf1N/BCNwVyEkAgc6U3E3FAQZfBItPA==', 'OzQmBxcIQn4vRkM9JBIrYGdiMAEueWpWRhwCMEIuZi44Lmc0SUc4fy0jFw==', 'IwQ0LAsCEXs3MgI6PkkLSWxcCV8cSk9BFxsNDSUXAVURLQM6SgYqcgwDFg==', 'DxMDBF1MHlg9NEY+dn4gA0VeCy4RRBdDCQh2EzJ0UCNtG0YYXF9pexo0LA==', 'JAwZOiMYNHEBGAFYH1osfENeNTILax9jDQIsKjt1WAUcHFQLY3E8VnUyBQ==', 'LgYVKD8UFl0mOFxZLmE+QUx0KAQySFBHHRh2ViY6Sj45XHc3ZwU+cBYpLQ==', 'BS8gOVUBHlxBC3s5DH5/Q21CFB4Wen8eTxE9UDYXfwgGD0krXQc0bi0wMA==', 'LDYzOAQQJ1xBCQkkLWA1UnQFMRcXV2IVJgsmCzQTWyAHWlgdfmQ6YjkNDg==', 'IBUKJjATJ0URJn89EEkeShUCJgU8SxNcEz0zPjcacTEeKkE1an0kdwUvPw==', 'XjMmARAXJ1U8G18CDkAKW35UMiw3QxVRRkV3AgRxAR4+OH4pSUIRUnoQHA==', 'PxMSIw40F0YmCwgeDUc0dBZxGS4Rd0x/SiUxFBAtZw9qKQQpYAc6ZxAXTg==', 'MDMMDyABOGE6EnUWF0Z1ZhBsKCwjRmoWPwEJLEwzZVIMPV44eQQaWDozKQ==', 'Xj8kNzYqAlAeR3YtKXIfWlxmUgZSWkJtHzYmHgI5Bg4IW2ocZmIxBHoXEA==', 'IBUXDCI1BnctHQQ9dn0MVkxsFSgEXXx+CSYCUSYpRjU6DUpgWVodDAEGGw==', 'DREYGQszP0oaEXAkN1k3QkteBVAWaktiOyQWVxg0AxVvI3cRHWYUWCsyMg==', 'LDMwG1cqIH0iKUQIE30hf2B7UjIffhRKS0M1Hiw0XC49CQYSZE8jX3JXMA==', 'IAYiWA8XAF4mHGNXPVI6B21NLwIcVVRLN0ZwNwc2fCAMGX8yZGAcDSQnMA==', 'Lhc0ClAUG0IiOFYaM2x8dXRtUTBRdFNCESscUTY3VwsvJGAwFQ0bXSs2TA==', 'CgQEDzdLAVBNGkgiHXI8RRJNEC0UW0BzJiYDVQEWazIcJXQ/HnA0RToGRQ==', 'JFEQJDI/IQYCK1QaKWwfWFRSNA5WeBdfCEoENh5yfAcLKGMcH3EnWC5QFw==', 'PwgjIRcTBkMiRnY3Ek4EZ3RWBjYfHGJQLDwxLQwvSzwtHn0oamY4AhEKOQ==', 'HBNTCi0UOFAQNAEHFEUcUVBjDSxXRE0WNgd8IB0Nawc3DlE1R2YYAw8DNw==', 'ETNQDikdF2cdNnokDEk+BRRABDUNHkwWLCEuIxIJYTcZIUkSe1scYjsnJw==', 'CjZSKiYBF0E+GGI4KRo+BhV6VjMtW2pvTwA2J0Z1ZiNpAVQTW3wFeikmDA==', 'CwMRI1Q3AnoPHn9ZDWAaRWd2MxQKWxV8J0MHAD0NajYvG1QVWw0UXXUoSQ==', 'Wi4RJSkoCnYNRHMUME8eC0B5EQxWdx50LSQJDUZ7YzQaGXApYG0XTiJdCw==', 'CiMrOQIjEFIPIgQ3MGAiZncAOzAURUxNFEQmMiUrXgg7LEQTY0QCci4nKg==', 'KlcRVS8sCFAFOgQkA3EoV0EGBhAEfBd3KyoDHUU1ai8rJkRqTFMkQjIBHg==', 'WQs0DFVNAnU2NWc2cRp0RF5MWD4IYGcQEEcQJT8NXxIdWFc2TGUGcywyJQ==', 'KywDNRIaRFdFRF4NEX0jXWthIB0jTFxKHwd3Dk0OZzMpOEYPZ0ApXzY9Cw==', 'HDRRGR0XJ34DQ1kaA058W2JiDi8IQXVHBhohMD02eyUwKF0eGmQUbgxSTQ==', 'WR0tLjBCCFYGJ3otF18eelZ0NQ0NW0NANQciEBwLSTc1O3oATH8eXSQ8Jw==', 'PAI4IVcDM1oBRAUHd0YMa1FgCSYMYU1fMTEmEgJ7fxQoUkcURncVWAYVNg==', 'Jy0tNyxPRwUyQWleP0B0XUViVgMHTlBWL0QWKTg7YlMFLWoYR2Elc3sHKg==', 'DQoWFyEwCEUzJl0IcF4dYUh5Vh4/FWpzECM2ABx2Rg4UWWsMekYBTnQKCw==', 'AFUvJTwYJn0nAHcACnIoYHV5DRYIZHNNOUAMPgAgClVpH3pqZFJoBjsdHA==', 'XwJXKyZOM2I0R3ctEUYISmtwAyYpGVxSLCYTIwAnYFYwG1wQf19gTStUSw==', 'WT8CXQ8fQGsyEl49CV8DBEZ9WTcwbm50TDEwIj06QTRuIXttYF0RVhRWDg==', 'OgovCQo1H1IlOEc6cmp1akNfLQU2ZkpiC0txDAMZYQgUIUoTXnsWfBMDOQ==', 'OSILWjw6CngZBAkdDmYcakFnWBAcYhB/TwAKAAEGYBAYB1VvTHAjbnYiRQ==', 'GTVQN1UdEHkSJX0cKUgefFBUIiggQ0VEJAIADQYaZFZoMnQMV3QzYgVUOQ==', 'GAEvXVM3JAAiGgcLAF44YmEDNSohYxBgCUE/XD4FRCEUI2kNXFhjQnRROg==', 'ORQKLiEhBUs4S2AicEgmdFJSNC9Ud2xWOxovXTB2dlMSUwZte1xmBAQ0Tg==', 'P1BTOV0tFFsXNVMYNUc6ARJ/MAokG3FRDhofHiQyUAc0CGEXQ2QfVxc3BQ==', 'JhMZHgE0B0sSEH0EMEMXR3FnMgEiSmdtRkd2AwYwXAJuXH0QGwQEQ3AiEw==', 'DVMGKREaEwU+OEEqDGB5QktCNxQtSlNSBCE2FT8xAhRoDWsdSWYIWjQOFA==' ] for i in range(0, 54): yb[i] = base64.b64decode(yb[i]).decode() yb[i] = bytes(yb[i], encoding='utf-8') # KeySpace里面可以加其他的字符 KeySpace = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890{}-' leng = len(KeySpace) def maybe(Hex): ans = '' for i in range(0, leng): for j in range(i, leng): x = KeySpace[i] ^ KeySpace[j] if x == Hex: ans += chr(KeySpace[i]) + chr(KeySpace[j]) return ans def PublicChr(aa, bb): anss = '' laa = len(aa) lbb = len(bb) for i in range(0, laa): for j in range(0, lbb): if aa[i] == bb[j]: if anss.find(aa[i]) == -1: anss += aa[i] return anss for i in range(0, 43): Ans = PublicChr(maybe(yb[0][i]), maybe(yb[1][i])) for j in range(0, 54): Ans = PublicChr(maybe(yb[j][i]), Ans) print(Ans) hgame{r3us1nG+M3$5age-\u0026amp;\u0026amp;~rEduC3d_k3Y-5P4Ce}\nReorder 这题只有nc连接，随便输入会发现顺序被打乱后输出，最后输出打乱后的flag，所以只要按顺序输入字母数字然后看是怎样被打乱的，就说明flag也被用同样的方法打乱了，直接复原即可。\nhgame{jU$t+5ImpL3_PeRmuTATi0n!!}\nMisc 欢迎参加HGame！ 来来来，签个到吧～ Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t 注：若解题得到的是无hgame{}字样的 flag 花括号内内容，请手动添加hgame{}后提交。 【Notice】解出来的字母均为大写\nbase64 解码，然后摩斯电码解码。\nhgame{W3LC0METO2020HGAM3}\n壁纸 binwalk提取出来个加密过的zip，然后两秒爆破数字出密码76953815 。 Unicode转中文。 hgame{Do_y0u_KnOW_uNiC0d3?}\n克苏鲁神话 题目解压出一个Bacon.txt，一个 Novel.zip。 zip 爆破使用明文攻击（Plain-text），明文文件选择加密后的 Bacon.zip 。得到可以直接解压的 Novel.zip 。 解压Novel.zip发现加密的doc文件。Bacon.txt里的大小写转换为B和A，然后培根解密。 AABABABABBAAAAAAABBAAABBBABAAAAAABBAAABBAABAAABBABABAAAABBABAAABBABBBAAAABA\n解密后：FLAGHIDDENINDOC\ndoc 里一篇文章，看不到 flag ，Word：「选项」-「显示」-「隐藏文字」。拉到文章底部看到 flag 。 hgame{Y0u_h@Ve_F0Und_mY_S3cReT}\n签到题ProPlus Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y h jnsxf qjFjf jnb rg fiyykwtbsnkm tm xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn. JRFVJYFZVRUAGMAI Three fences first, Five Caesar next. English sentense first, zip password next.\n按提示分别操作两段字符串，栅栏三个一组解密后，凯撒移位5个，上面的会变成一段话，下面的是密码：EAVMUBAQHQMVEPDT。 解压看到里面的 txt 内容是一堆 ook ，网站在线解码 ，然后 base32 ，接着 base64 。 base64 解出来的明文会乱码，只能查看16进制，开头是89 50 4e 47，png 的文件头，复制。 winHex：「文件」-「新建」-「1Bytes」-「确定」-「Ctrl+V 粘贴」- 选择「Ascii Hex」然后删去开头的“00”，然后另存为 xxx.png。 得到二维码，扫了就出 flag。 hgame{3Nc0dInG_@lL_iN_0Ne!}\n","permalink":"https://slightwind.cn/posts/ctf/hgame-2020-week1-writeup/","summary":"HGAME 2020 week1 writeup Web Cosmos 的博客 看提示去 GitHub 上找这个网站的源代码，搜索 Cosmos Hgame 就可以找到，点开 3 commits，点开 new file 就可以看到： aGdhbWV7ZzF0X2xlQGtfMXNfZGFuZ2VyMHVzXyEhISF9 base64 解码得到 flag: hgame{g1t_le@k_1s_danger0us_!!!} Crypto InfantRSA 题目：\np = 681782737450022065655472455411; q = 675274897132088253519831953441; e = 13; c = pow(m, e, p * q) = 275698465082361070145173688411496311542172902608559859019841 exp：\np = 681782737450022065655472455411 q = 675274897132088253519831953441 e = 13 c = 275698465082361070145173688411496311542172902608559859019841 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g !","title":"HGAME 2020 week1 writeup"},{"content":"Experience 2023.7 ~ : Software Development Engineer @Huawei\n2022.7 ~ 2022.9: Software Development Intern @Huawei\n2022.5 ~ 2022.7: Security Research Intern @Sangfor\n2021.7 ~ 2021.9: Security Research Intern @DBAPP Security\nEducation 2019.8 ~ 2023.6: Information Security @NJUPT\nContact Email: slightwindsec@gmail.com\nEmail: cy@njupt.edu.cn\n","permalink":"https://slightwind.cn/about/","summary":"Experience 2023.7 ~ : Software Development Engineer @Huawei\n2022.7 ~ 2022.9: Software Development Intern @Huawei\n2022.5 ~ 2022.7: Security Research Intern @Sangfor\n2021.7 ~ 2021.9: Security Research Intern @DBAPP Security\nEducation 2019.8 ~ 2023.6: Information Security @NJUPT\nContact Email: slightwindsec@gmail.com\nEmail: cy@njupt.edu.cn","title":"About"},{"content":"","permalink":"https://slightwind.cn/categories/","summary":"categories","title":"Categories"}]